{"config":{"indexing":"full","lang":["ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HZNU TI1049(2020) Status Retired. Members Name ID Grade Profession Lyuzhi Pan Dup4 2017 Software Engineering Tiansong Luo ltslts 2017 Computer Science Zhezhen Xia groggy_ 2017 Computer Science Onsite Name Date Award Rank Solved A B C D E F G H I J K L M 2020 CCPC Qinhuangdao 2020.10.18 Bronze 99 5/12 O . O . O O O . . . . . Comment: O for passing during the contest \u00d8 for passing after the contest ! for attempted but failed \u00b7for having not attempted yet Trainings Random Trainings Name Date Rank Solved \u7b2c\u5341\u4e03\u5c4a\u4e2d\u56fd\u8ba1\u91cf\u5927\u5b66\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b 2020.9.26 6/573 11/14 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Name Date Rank Solved 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day1 2020.10.01 20/293 6/10 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day2 2020.10.02 39/401 9/10 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day3 2020.10.03 22/425 4/10 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day4 2020.10.04 34/294 5/10 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day5 2020.10.05 12/277 5/11 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day6 2020.10.06 12/252 5/11 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day7 2020.10.07 12/249 5/11 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day8 2020.10.08 15/164 6/11","title":"HZNU TI1049(2020)"},{"location":"#status","text":"Retired.","title":"Status"},{"location":"#members","text":"Name ID Grade Profession Lyuzhi Pan Dup4 2017 Software Engineering Tiansong Luo ltslts 2017 Computer Science Zhezhen Xia groggy_ 2017 Computer Science","title":"Members"},{"location":"#onsite","text":"Name Date Award Rank Solved A B C D E F G H I J K L M 2020 CCPC Qinhuangdao 2020.10.18 Bronze 99 5/12 O . O . O O O . . . . . Comment: O for passing during the contest \u00d8 for passing after the contest ! for attempted but failed \u00b7for having not attempted yet","title":"Onsite"},{"location":"#trainings","text":"","title":"Trainings"},{"location":"#random-trainings","text":"Name Date Rank Solved \u7b2c\u5341\u4e03\u5c4a\u4e2d\u56fd\u8ba1\u91cf\u5927\u5b66\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b 2020.9.26 6/573 11/14","title":"Random Trainings"},{"location":"#\u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9","text":"Name Date Rank Solved 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day1 2020.10.01 20/293 6/10 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day2 2020.10.02 39/401 9/10 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day3 2020.10.03 22/425 4/10 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day4 2020.10.04 34/294 5/10 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day5 2020.10.05 12/277 5/11 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day6 2020.10.06 12/252 5/11 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day7 2020.10.07 12/249 5/11 2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day8 2020.10.08 15/164 6/11","title":"\u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9"},{"location":"2020/nowcoder-national-day-training-party/day1/","text":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day1 Contents Contest Info Solutions Problem A. ABB \u9898\u610f \u601d\u8def Problem B. Be Geeks! \u9898\u610f \u601d\u8def Problem C. Bob in Wonderland \u9898\u610f \u601d\u8def Problem D. Deep800080 \u9898\u610f \u601d\u8def Problem E. Zeldain Garden \u9898\u610f \u601d\u8def Problem F. Light Emitting Hindenburg \u9898\u610f \u601d\u8def Problem G. K==S \u9898\u610f \u601d\u8def Problem H. Ponk Warshall \u9898\u610f \u601d\u8def Problem I. Saba1000kg \u9898\u610f \u601d\u8def Problem J. The Bugs \u9898\u610f \u601d\u8def Contest Info Practice Link Solved A B C D E F G H I J 6/10 O O O O O - - O - - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions Problem A. ABB Solved By Dup4. 00:08(+) \u9898\u610f \u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 S S \uff0c\u95ee\u5728\u8be5\u5b57\u7b26\u4e32\u672b\u5c3e\u6700\u5c11\u6dfb\u52a0\u591a\u5c11\u4e2a\u5b57\u7b26\u4f7f\u5f97\u8be5\u5b57\u7b26\u4e32\u80fd\u591f\u53d8\u6210\u4e00\u4e2a\u56de\u6587\u4e32\uff1f \u601d\u8def \u627e\u4e00\u4e2a\u6700\u957f\u7684\u56de\u6587\u540e\u7f00\uff0c\u7136\u540e\u5728\u672b\u5c3e\u8865\u9f50\u524d\u7f00\u6240\u5bf9\u5e94\u7684\u56de\u6587\u7684\u90a3\u90e8\u5206\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 4e5 + 10 ; int n ; char s [ N ]; struct Manacher { int len , l ; char Ma [ N << 1 ]; int Mp [ N << 1 ]; void work ( char * s ) { len = strlen ( s ); l = 0 ; Ma [ l ++ ] = '$' ; Ma [ l ++ ] = '#' ; for ( int i = 0 ; i < len ; ++ i ) { Ma [ l ++ ] = s [ i ]; Ma [ l ++ ] = '#' ; } Ma [ l ] = 0 ; int mx = 0 , id = 0 ; for ( int i = 0 ; i < l ; ++ i ) { Mp [ i ] = mx > i ? min ( Mp [ 2 * id - i ], mx - i ) : 1 ; while ( Ma [ i + Mp [ i ]] == Ma [ i - Mp [ i ]]) Mp [ i ] ++ ; if ( i + Mp [ i ] > mx ) { mx = i + Mp [ i ]; id = i ; } } } bool check ( int l , int r ) { int il = ( l + 1 ) * 2 , ir = ( r + 1 ) * 2 ; int mid = ( il + ir ) / 2 ; int len = ( r - l + 2 ) / 2 ; return ( Mp [ mid ] / 2 ) >= len ; } } man ; void run () { rd ( n ); cin >> s ; man . work ( s ); for ( int i = 0 ; i < n ; ++ i ) { if ( man . check ( i , n - 1 )) return pt ( i ); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem B. Be Geeks! Solved By Dup4. 01:19(+2) \u9898\u610f \u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684\u5e8f\u5217 a_i a_i , \u5b9a\u4e49\uff1a G(i, j) = \\gcd(a_i, a_{i + 1}, \\cdots, a_j) G(i, j) = \\gcd(a_i, a_{i + 1}, \\cdots, a_j) M(i, j) = \\max(a_i, a_{i + 1}, \\cdots, a_j) M(i, j) = \\max(a_i, a_{i + 1}, \\cdots, a_j) P(i, j) = G(i, j) \\cdot M(i, j) P(i, j) = G(i, j) \\cdot M(i, j) F(A) = \\sum P(i, j) F(A) = \\sum P(i, j) \u7136\u540e\u5c31\u662f\u8981\u6c42 F(A) F(A) \u3002 \u601d\u8def \u7b80\u5355\u6765\u8bf4\uff0c\u5c31\u662f\u6c42\u8fd9\u4e2a\u5e8f\u5217\u5f53\u4e2d\u4efb\u610f\u4e00\u4e2a\u8fde\u7eed\u5b50\u5e8f\u5217\u7684\u6700\u5927\u503c\u4e58\u4e0a\u5b50\u5e8f\u5217\u7684\u6700\u5927\u516c\u7ea6\u6570\u7684\u603b\u548c\u3002 \u9996\u5148\u6211\u4eec\u901a\u8fc7\u7b1b\u5361\u5c14\u6811\uff0c\u6c42\u51fa\u6bcf\u4e2a\u503c\u5b83\u6240\u63a7\u5236\u7684\u90a3\u6bb5\u8303\u56f4\u3002 \u7136\u540e\u679a\u4e3e\u6bcf\u4e2a\u503c\u4f5c\u4e3a\u6700\u5927\u503c\uff0c\u5e76\u4e14\u5047\u8bbe\u5b83\u63a7\u5236\u7684\u90a3\u6bb5\u5b57\u6bb5\u4e3a [l_i, r_i] [l_i, r_i] , \u7136\u540e\u679a\u4e3e\u77ed\u7684\u90a3\u8fb9\uff0c\u7528\u4e8c\u5206\u53bb\u5f04\u53e6\u4e00\u8fb9\u3002\u80fd\u8fd9\u4e48\u505a\u7684\u539f\u56e0\u662f\u56e0\u4e3a\uff0c\u4e00\u6bb5\u5e8f\u5217\u4e2d\uff0c\u63a7\u5236\u4e86\u8d77\u70b9\uff0c\u5bf9\u4e8e\u4e0d\u540c\u7ec8\u70b9\u6765\u8bf4\uff0c\u53ea\u6709 \\mathcal{O}(\\log n) \\mathcal{O}(\\log n) \u4e2a\u4e0d\u540c\u7684\u6700\u5927\u516c\u7ea6\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 2e5 + 10 ; constexpr int INF = 0x3f3f3f3f ; int n , a [ N ]; pII r [ N ]; struct Cartesian_Tree { struct node { int id , val , fa ; int son [ 2 ]; node () {} node ( int id , int val , int fa ) : id ( id ), val ( val ), fa ( fa ) { son [ 0 ] = son [ 1 ] = 0 ; } bool operator < ( const node & other ) const { return val > other . val ; } } t [ N ]; int root ; void init () { t [ 0 ] = node ( 0 , INF , 0 ); } void build ( int n , int * a ) { for ( int i = 1 ; i <= n ; ++ i ) { t [ i ] = node ( i , a [ i ], 0 ); } for ( int i = 1 ; i <= n ; ++ i ) { int k = i - 1 ; while ( t [ i ] < t [ k ]) { k = t [ k ]. fa ; } t [ i ]. son [ 0 ] = t [ k ]. son [ 1 ]; t [ k ]. son [ 1 ] = i ; t [ i ]. fa = k ; t [ t [ i ]. son [ 0 ]]. fa = i ; } root = t [ 0 ]. son [ 1 ]; } int dfs ( int u ) { if ( ! u ) return 0 ; int lsze = dfs ( t [ u ]. son [ 0 ]); int rsze = dfs ( t [ u ]. son [ 1 ]); r [ t [ u ]. id ] = pII ( lsze , rsze ); return lsze + rsze + 1 ; } } CT ; template < typename RMQItem , RMQItem base > struct RMQ { vector < RMQItem > v ; vector < vector < RMQItem >> tl , tr ; RMQItem op ( const RMQItem & a , const RMQItem & b ) { return __gcd ( a , b ); } int log2Up ( int n ) { int res = 0 ; while (( 1 << res ) < n ) res ++ ; return res ; } RMQ () {} RMQ ( const vector < RMQItem > & a ) { int n = a . size (); v = a ; tl = tr = vector < vector < RMQItem >> ( log2Up ( n ) + 1 , vector < RMQItem > ( n )); for ( int k = 0 ; ( 1 << k ) <= n ; ++ k ) { int ones = ( 1 << k ) - 1 ; RMQItem tmp = base ; for ( int i = 0 ; i < n ; ++ i ) { tmp = op ( tmp , a [ i ]); tl [ k ][ i ] = tmp ; if (( i & ones ) == ones ) tmp = base ; } tmp = base ; for ( int i = n - 1 ; i >= 0 ; -- i ) { tmp = op ( tmp , a [ i ]); tr [ k ][ i ] = tmp ; if (( i & ones ) == 0 ) tmp = base ; } } } RMQItem query ( int l , int r ) { -- l , -- r ; if ( l == r ) return v [ l ]; int num = 31 - __builtin_clz ( l ^ r ); return op ( tl [ num ][ r ], tr [ num ][ l ]); } }; RMQ < int , 0 > rmq ; int gao ( int l , int r , int _g ) { if ( l > r ) return 0 ; int res = 0 ; while ( l <= r ) { _g = __gcd ( _g , a [ l ]); int _l = l , _r = r , pos = _l ; while ( _r - _l >= 0 ) { int mid = ( _l + _r ) >> 1 ; if ( rmq . query ( l , mid ) % _g == 0 ) { pos = mid ; _l = mid + 1 ; } else { _r = mid - 1 ; } } chadd ( res , 1l l * ( pos - l + 1 ) * _g % mod ); l = pos + 1 ; } return res ; } int gao1 ( int l , int r , int _g ) { if ( l > r ) return 0 ; int res = 0 ; while ( l <= r ) { _g = __gcd ( _g , a [ r ]); int _l = l , _r = r , pos = _r ; while ( _r - _l >= 0 ) { int mid = ( _l + _r ) >> 1 ; if ( rmq . query ( mid , r ) % _g == 0 ) { pos = mid ; _r = mid - 1 ; } else { _l = mid + 1 ; } } chadd ( res , 1l l * ( r - pos + 1 ) * _g % mod ); r = pos - 1 ; } return res ; } void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]); CT . init (); CT . build ( n , a ); CT . dfs ( CT . root ); vector < int > vec ( a + 1 , a + 1 + n ); rmq = RMQ < int , 0 > ( vec ); int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { int now = 0 ; if ( r [ i ]. fi < r [ i ]. se ) { int _g = 0 ; for ( int j = 0 ; j <= r [ i ]. fi ; ++ j ) { _g = __gcd ( _g , a [ i - j ]); chadd ( now , gao ( i , i + r [ i ]. se , _g )); } } else { int _g = 0 ; for ( int j = 0 ; j <= r [ i ]. se ; ++ j ) { _g = __gcd ( _g , a [ i + j ]); chadd ( now , gao1 ( i - r [ i ]. fi , i , _g )); } } chadd ( res , 1l l * now * a [ i ] % mod ); // dbg(i, i - r[i].fi, i + r[i].se, now); } pt ( res ); } int main () { // ios::sync_with_stdio(false); // cin.tie(nullptr); cout.tie(nullptr); // cout << fixed << setprecision(20); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem C. Bob in Wonderland Solved By Dup4. 01:50(+1) \u9898\u610f \u7ed9\u51fa\u4e00\u68f5\u6811\uff0c\u6bcf\u6b21\u53ef\u4ee5\u65ad\u6389\u4e00\u6761\u8fb9\u53d8\u6210\u4e24\u4e2a\u8fde\u901a\u5757\uff0c\u7136\u540e\u53ef\u4ee5\u52a0\u5165\u4e00\u6761\u8fb9\uff0c\u5c06\u4e24\u4e2a\u8fde\u901a\u5757\u8fde\u901a\u3002 \u95ee\u6700\u5c11\u591a\u5c11\u6b21\u64cd\u4f5c\u53ef\u4ee5\u5c06\u8fd9\u68f5\u6811\u53d8\u6210\u4e00\u4e2a\u94fe\u3002 \u601d\u8def \u5982\u679c\u662f\u4e00\u68f5\u6709\u6839\u6811\uff0c\u90a3\u4e48\u8d2a\u5fc3\u7b56\u7565\u662f\u56fa\u5b9a\u7684\uff0c\u5c31\u662f\u5bf9\u4e8e\u4e00\u4e2a\u70b9\uff0c\u5047\u8bbe\u5b83\u7684\u5b69\u5b50\u6709 x x \u4e2a\uff0c\u90a3\u4e48\u5bf9\u4e8e\u8fd9\u4e2a\u70b9\uff0c\u8981\u65ad\u6389 x - 1 x - 1 \u6761\u8fb9\u3002 \u73b0\u5728\u7684\u95ee\u9898\u662f\uff0c\u8fd9\u662f\u4e00\u68f5\u65e0\u6839\u6811\uff0c\u90a3\u4e48\u6362\u6839 DP \u4e00\u4e0b\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 3e5 + 10 ; constexpr int INF = 0x3f3f3f3f ; int n , f [ N ], g [ N ], fa [ N ], sze [ N ]; vector < vector < int >> G ; void dfs ( int u ) { sze [ u ] = 0 ; for ( auto & v : G [ u ]) { if ( v == fa [ u ]) continue ; fa [ v ] = u ; dfs ( v ); ++ sze [ u ]; f [ u ] += f [ v ]; } f [ u ] += max ( 0 , sze [ u ] - 1 ); } void dfs1 ( int u ) { for ( auto & v : G [ u ]) { if ( v == fa [ u ]) continue ; int _g = g [ u ]; if ( u == 1 ) _g += max ( 0 , sze [ u ] - 2 ); else _g += max ( 0 , sze [ u ] - 1 ); _g += f [ u ]; _g -= f [ v ]; _g -= max ( 0 , sze [ u ] - 1 ); g [ v ] += _g ; dfs1 ( v ); } } void run () { rd ( n ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v ; i < n ; ++ i ) { rd ( u , v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } memset ( f , 0 , sizeof f ); memset ( g , 0 , sizeof g ); fa [ 1 ] = 0 ; dfs ( 1 ); dfs1 ( 1 ); int res = INF ; for ( int i = 1 ; i <= n ; ++ i ) { chmin ( res , f [ i ] + g [ i ]); // dbg(2, f[i] + g[i]); } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem D. Deep800080 Solved By Dup4 & lts. 04:50(+7) \u9898\u610f \u7ed9\u51fa n n \u4e2a\u70b9\uff0c\u7136\u540e\u53ef\u4ee5\u5728\u901a\u8fc7 (0, 0) (0, 0) \u5230 (A, B) (A, B) \u7684\u8fd9\u6761\u76f4\u7ebf\u4e0a\u627e\u4e00\u4e2a\u70b9\u753b\u4e00\u4e2a\u5706\uff0c\u534a\u5f84\u4e3a R R \uff0c\u4f7f\u5f97\u8fd9\u4e2a\u5706\u80fd\u591f\u8986\u76d6\u5230\u5c3d\u53ef\u80fd\u591a\u7684\u70b9\u3002 \u95ee\u6700\u591a\u80fd\u8986\u76d6\u5230\u591a\u5c11\u4e2a\u70b9\uff1f \u601d\u8def \u4ee5\u6bcf\u4e2a\u70b9\u4e3a\u5706\u5fc3\uff0c\u534a\u5f84\u4e3a R R \u753b\u5706\uff0c\u7136\u540e\u5b83\u4f1a\u8ddf\u90a3\u6761\u76f4\u7ebf\u6700\u591a\u76f8\u4ea4\u4e24\u4e2a\u70b9\uff0c\u53ea\u8981\u6211\u4eec\u9009\u7684\u70b9\u843d\u5728\u8fd9\u4e24\u4e2a\u70b9\u786e\u5b9a\u7684\u7ebf\u6bb5\u4e4b\u5185\uff0c\u8fd9\u4e2a\u70b9\u5c31\u53ef\u4ee5\u88ab\u8986\u76d6\u3002 \u90a3\u4e48\u95ee\u9898\u53d8\u6210\u4e86\uff0c\u6709\u82e5\u5e72\u6761\u7ebf\u6bb5\uff0c\u95ee\u88ab\u7ebf\u6bb5\u8986\u76d6\u6b21\u6570\u6700\u591a\u7684\u70b9\u88ab\u8986\u76d6\u4e86\u591a\u5c11\u6b21\uff1f \u81f3\u4e8e\u7cbe\u5ea6\u95ee\u9898\u7684\u8bdd\uff0c\u6269\u5927\u4e00\u4e0b\u8f6c\u5316\u6210\u6574\u6570\u4f1a\u597d\u505a\u4e00\u70b9\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; using pDD = pair < db , db > ; using pDI = pair < db , int > ; using pLI = pair < ll , int > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 3e5 + 10 ; int n , r , a , b ; const db eps = 1e-5 ; const db PI = acos ( -1.0L ); int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; return x < 0 ? -1 : 1 ; } db sqr ( db x ) { return x * x ; } db fixOut ( db x ) { if ( sgn ( x ) == 0 ) return 0 ; return x ; } struct Point { db x , y ; Point ( db x = 0 , db y = 0 ) : x ( x ), y ( y ) {} void scan () { rd ( x , y ); } bool operator == ( const Point & b ) const { return sgn ( x - b . x ) == 0 && sgn ( y - b . y ) == 0 ; } bool operator < ( const Point & b ) const { return sgn ( x - b . x ) == 0 ? sgn ( y - b . y ) < 0 : x < b . x ; } Point operator + ( const Point & b ) const { return Point ( x + b . x , y + b . y ); } Point operator - ( const Point & b ) const { return Point ( x - b . x , y - b . y ); } Point operator * ( const db & b ) const { return Point ( x * b , y * b ); } Point operator / ( const db & b ) const { return Point ( x / b , y / b ); } db operator ^ ( const Point & b ) const { return x * b . y - y * b . x ; } db operator * ( const Point & b ) const { return x * b . x + y * b . y ; } db len () { return hypot ( x , y ); } db len2 () { return x * x + y * y ; } db dis ( Point b ) { return hypot ( x - b . x , y - b . y ); } db dis2 ( Point b ) { return ( x - b . x ) * ( x - b . x ) + ( y - b . y ) * ( y - b . y ); } Point trunc ( db r ) { db l = len (); if ( ! sgn ( l )) return * this ; r /= l ; return Point ( x * r , y * r ); } }; struct Line { Point s , e ; Line () {} Line ( Point s , Point e ) : s ( s ), e ( e ) {} bool operator == ( const Line & b ) const { return s == b . s && e == b . e ; } void adjust () { if ( e < s ) swap ( s , e ); } db length () { return s . dis ( e ); } db getAngle () { db k = atan2 ( e . y - s . y , e . x - s . x ); if ( sgn ( k ) < 0 ) k += PI ; if ( sgn ( k - PI ) == 0 ) k -= PI ; return k ; } int relationPoint ( Point p ) { int c = sgn (( p - s ) ^ ( e - s )); if ( c < 0 ) return 1 ; if ( c > 0 ) return 2 ; return 3 ; } bool pointOnSeg ( Point p ) { return sgn (( p - s ) ^ ( e - s )) == 0 && sgn (( p - s ) * ( p - e )) <= 0 ; } bool parallel ( Line b ) { return sgn (( e - s ) ^ ( b . e - b . s )) == 0 ; } int segCrossSeg ( Line b ) { int d1 = sgn (( e - s ) ^ ( b . s - s )); int d2 = sgn (( e - s ) ^ ( b . e - s )); int d3 = sgn (( b . e - b . s ) ^ ( s - b . s )); int d4 = sgn (( b . e - b . s ) ^ ( e - b . s )); if (( d1 ^ d2 ) == -2 && ( d3 ^ d4 ) == -2 ) return 2 ; return (( d1 == 0 && sgn (( b . s - s ) * ( b . s - e )) <= 0 ) || ( d2 == 0 && sgn (( b . e - s ) * ( b . e - e )) <= 0 ) || ( d3 == 0 && sgn (( s - b . s ) * ( s - b . e )) <= 0 ) || ( d4 == 0 && sgn (( e - b . s ) * ( e - b . e )) <= 0 )); } db disPointToLine ( Point p ) { return fabs (( p - s ) ^ ( e - s )) / length (); } db disPointToSeg ( Point p ) { if ( sgn (( p - s ) * ( e - s )) < 0 || sgn (( p - e ) * ( s - e )) < 0 ) return min ( p . dis ( s ), p . dis ( e )); return disPointToLine ( p ); } Point lineProg ( Point p ) { return s + ((( e - s ) * (( e - s ) * ( p - s ))) / (( e - s ). len2 ())); } }; struct Circle { Point p ; db r ; Circle () {} Circle ( Point p , db r ) : p ( p ), r ( r ) {} Circle ( db x , db y , db r ) : p ( Point ( x , y )), r ( r ) {} bool operator == ( const Circle & b ) const { return ( p == b . p ) && sgn ( r - b . r ) == 0 ; } bool operator < ( const Circle & b ) const { return (( p < b . p ) || (( p == b . p ) && sgn ( r - b . r ) < 0 )); } db area () { return PI * r * r ; } db circumference () { return PI * r * 2 ; } Point getPoint ( db rad ) { return Point ( p . x + cos ( rad ) * r , p . y + sin ( rad ) * r ); } int relationPoint ( Point b ) { db dis = b . dis ( p ); if ( sgn ( dis - r ) < 0 ) return 2 ; if ( sgn ( dis - r ) == 0 ) return 1 ; return 0 ; } int relationSeg ( Line b ) { db dis = b . disPointToSeg ( p ); if ( sgn ( dis - r ) < 0 ) return 2 ; if ( sgn ( dis - r ) == 0 ) return 1 ; return 0 ; } int relationLine ( Line b ) { db dis = b . disPointToLine ( p ); if ( sgn ( dis - r ) < 0 ) return 2 ; if ( sgn ( dis - r ) == 0 ) return 1 ; return 0 ; } int pointCrossLine ( Line b , Point & p1 , Point & p2 ) { if ( ! ( * this ). relationLine ( b )) return 0 ; Point a = b . lineProg ( p ); db d = b . disPointToLine ( p ); d = sqrt ( r * r - d * d ); if ( sgn ( d ) == 0 ) { p1 = p2 = a ; return 1 ; } p1 = a + ( b . e - b . s ). trunc ( d ); p2 = a - ( b . e - b . s ). trunc ( d ); return 2 ; } }; void run () { rd ( n , r , a , b ); Line l = Line ( Point ( 0 , 0 ), Point ( a , b )); int f = 0 ; if ( a == 0 ) f = 1 , a = b ; int L = 0 , R = a ; if ( L > R ) swap ( L , R ); vector < pLI > vec , _vec ; for ( int i = 1 ; i <= n ; ++ i ) { Point p ; p . scan (); Point p1 , p2 ; Circle c = Circle ( p , r ); int num = c . pointCrossLine ( l , p1 , p2 ); if ( f ) swap ( p1 . x , p1 . y ), swap ( p2 . x , p2 . y ); if ( num ) { db l = p1 . x ; db r = p2 . x ; if ( sgn ( l - r ) > 0 ) swap ( l , r ); // if (sgn(l - R) > 0) continue; // if (sgn(L - r) > 0) continue; // if (sgn(L - l) > 0) l = L; // if (sgn(r - R) > 0) r = R; ll _l = ll ( l * 1000000 ); ll _r = ll ( r * 1000000 ); vec . push_back ( pLI ( _l , 1 )); vec . push_back ( pLI ( _r + 1 , -1 )); } } sort ( all ( vec ), [ & ]( pLI a , pLI b ) { return a . fi < b . fi ; }); for ( auto & it : vec ) { if ( _vec . empty ()) _vec . push_back ( it ); else { if ( it . fi == _vec . back (). fi ) _vec . back (). se += it . se ; else { _vec . push_back ( it ); } } } int res = 0 , now = 0 ; for ( auto & it : _vec ) { now += it . se ; chmax ( res , now ); } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem E. Zeldain Garden Solved By Dup4. 01:28(+) \u9898\u610f \u6c42 [l, r] [l, r] \u4e2d\u6bcf\u4e2a\u6570\u7684\u56e0\u6570\u4e2a\u6570\u4e4b\u548c\u3002 \u601d\u8def [1, n] [1, n] \u4e2d\u7684\u56e0\u5b50\u6570\u4e4b\u548c\u7684\u7b54\u6848\u662f \\displaystyle \\sum\\limits_{i = 1}^n \\lfloor \\frac{n}{i} \\rfloor \\displaystyle \\sum\\limits_{i = 1}^n \\lfloor \\frac{n}{i} \\rfloor \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; ll l , r ; ll gao ( ll n ) { if ( n < 0 ) return 0 ; if ( n == 1 ) return 1 ; ll sq = sqrt ( n ); while ( sq * sq <= n ) ++ sq ; while ( sq * sq > n ) -- sq ; ll res = 0 ; for ( ll i = 1 ; i <= sq ; ++ i ) { res += n / i ; } res *= 2 ; res -= sq * sq ; return res ; } void run () { rd ( l , r ); pt ( gao ( r ) - gao ( l - 1 )); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem F. Light Emitting Hindenburg Upsolved By -. \u9898\u610f \u601d\u8def Problem G. K==S Upsolved By -. \u9898\u610f \u601d\u8def Problem H. Ponk Warshall Solved By Dup4 & lts. 02:26(+) \u9898\u610f \u7ed9\u51fa\u8fde\u4e2a\u4e2a\u5b57\u7b26\u4e32 S S \u548c T T \uff0c\u5e76\u4e14\u53ea\u6709\u56db\u79cd\u5b57\u7b26 A , C , G , T \uff0c\u53ea\u6709\u4e00\u79cd\u64cd\u4f5c\uff0c\u5c31\u662f\u4ea4\u6362 S S \u4e2d\u4efb\u610f\u4e24\u4e2a\u4f4d\u7f6e\u7684\u5b57\u7b26\uff0c\u95ee\u6700\u5c11\u9700\u8981\u591a\u5c11\u6b21\u64cd\u4f5c\u80fd\u591f\u5c06 S S \u53d8\u6210 T T \u3002 \u601d\u8def \u5bf9\u4e8e\u4e00\u4e2a\u73af\uff0c\u90a3\u4e48\u9700\u8981 \\mbox{\u73af\u7684\u957f\u5ea6} - 1 \\mbox{\u73af\u7684\u957f\u5ea6} - 1 \u6b21\u64cd\u4f5c\u80fd\u591f\u5c06\u8fd9\u4e2a\u73af\u4e0a\u7684\u6bcf\u4e00\u5bf9\u90fd\u590d\u539f\u3002 \u6bd4\u5982\u8bf4 AC \u548c CA \uff0c\u53ea\u9700\u8981\u4e00\u6b21\u4ea4\u6362\u3002 \u5e76\u4e14\u73af\u7684\u957f\u5ea6\u8d8a\u5c0f\u8d8a\u597d\uff0c\u5373\u73af\u7684\u4e2a\u6570\u8d8a\u591a\u8d8a\u597d\u3002 \u6211\u4eec\u867d\u7136\u4e0d\u77e5\u9053\u600e\u4e48\u8bc1\uff0c\u4f46\u662f\u6211\u4eec\u80fd\u731c\u51fa\u6765\u8d2a\u5fc3\u5148\u53bb\u627e\u4e8c\u5143\u73af\uff0c\u518d\u53bb\u627e\u4e09\u5143\u73af\uff0c\u518d\u53bb\u627e\u56db\u5143\u73af\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; using pCC = pair < char , char > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e6 + 10 ; int n ; char s [ N ], t [ N ]; map < pCC , int > mp ; void run () { cin >> ( s + 1 ) >> ( t + 1 ); n = strlen ( s + 1 ); // int cnt = 0; // for (auto &c1 : {'A', 'C', 'G', 'T'}) { // for (auto &c2 : {'A', 'C', 'G', 'T'}) { // if (c1 != c2) { // mp[pCC(c1, c2)] = ++cnt; // } // } // } for ( int i = 1 ; i <= n ; ++ i ) { char c1 = s [ i ]; char c2 = t [ i ]; if ( c1 != c2 ) { ++ mp [ pCC ( c1 , c2 )]; } } int res = 0 ; vector < char > vec ({ 'A' , 'C' , 'G' , 'T' }); for ( auto & c1 : vec ) { for ( auto & c2 : vec ) { if ( c1 != c2 ) { pCC t1 = pCC ( c1 , c2 ); pCC t2 = pCC ( c2 , c1 ); int Min = min ( mp [ t1 ], mp [ t2 ]); res += Min ; mp [ t1 ] -= Min ; mp [ t2 ] -= Min ; } } } do { char c1 = vec [ 0 ], c2 = vec [ 1 ], c3 = vec [ 2 ]; pII t1 = pCC ( c1 , c2 ); pII t2 = pCC ( c2 , c3 ); pII t3 = pCC ( c3 , c1 ); int Min = min ({ mp [ t1 ], mp [ t2 ], mp [ t3 ]}); res += Min * 2 ; mp [ t1 ] -= Min ; mp [ t2 ] -= Min ; mp [ t3 ] -= Min ; } while ( next_permutation ( all ( vec ))); int sum = 0 ; for ( auto & it : mp ) sum += it . se ; assert ( sum % 4 == 0 ); res += sum / 4 * 3 ; pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem I. Saba1000kg Upsolved By -. \u9898\u610f \u601d\u8def Problem J. The Bugs Upsolved By -. \u9898\u610f \u601d\u8def","title":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day1"},{"location":"2020/nowcoder-national-day-training-party/day1/#contest-info","text":"Practice Link Solved A B C D E F G H I J 6/10 O O O O O - - O - - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"2020/nowcoder-national-day-training-party/day1/#solutions","text":"","title":"Solutions"},{"location":"2020/nowcoder-national-day-training-party/day1/#problem-a-abb","text":"Solved By Dup4. 00:08(+)","title":"Problem A. ABB"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u9898\u610f","text":"\u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 S S \uff0c\u95ee\u5728\u8be5\u5b57\u7b26\u4e32\u672b\u5c3e\u6700\u5c11\u6dfb\u52a0\u591a\u5c11\u4e2a\u5b57\u7b26\u4f7f\u5f97\u8be5\u5b57\u7b26\u4e32\u80fd\u591f\u53d8\u6210\u4e00\u4e2a\u56de\u6587\u4e32\uff1f","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u601d\u8def","text":"\u627e\u4e00\u4e2a\u6700\u957f\u7684\u56de\u6587\u540e\u7f00\uff0c\u7136\u540e\u5728\u672b\u5c3e\u8865\u9f50\u524d\u7f00\u6240\u5bf9\u5e94\u7684\u56de\u6587\u7684\u90a3\u90e8\u5206\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 4e5 + 10 ; int n ; char s [ N ]; struct Manacher { int len , l ; char Ma [ N << 1 ]; int Mp [ N << 1 ]; void work ( char * s ) { len = strlen ( s ); l = 0 ; Ma [ l ++ ] = '$' ; Ma [ l ++ ] = '#' ; for ( int i = 0 ; i < len ; ++ i ) { Ma [ l ++ ] = s [ i ]; Ma [ l ++ ] = '#' ; } Ma [ l ] = 0 ; int mx = 0 , id = 0 ; for ( int i = 0 ; i < l ; ++ i ) { Mp [ i ] = mx > i ? min ( Mp [ 2 * id - i ], mx - i ) : 1 ; while ( Ma [ i + Mp [ i ]] == Ma [ i - Mp [ i ]]) Mp [ i ] ++ ; if ( i + Mp [ i ] > mx ) { mx = i + Mp [ i ]; id = i ; } } } bool check ( int l , int r ) { int il = ( l + 1 ) * 2 , ir = ( r + 1 ) * 2 ; int mid = ( il + ir ) / 2 ; int len = ( r - l + 2 ) / 2 ; return ( Mp [ mid ] / 2 ) >= len ; } } man ; void run () { rd ( n ); cin >> s ; man . work ( s ); for ( int i = 0 ; i < n ; ++ i ) { if ( man . check ( i , n - 1 )) return pt ( i ); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day1/#problem-b-be-geeks","text":"Solved By Dup4. 01:19(+2)","title":"Problem B. Be Geeks!"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u9898\u610f_1","text":"\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684\u5e8f\u5217 a_i a_i , \u5b9a\u4e49\uff1a G(i, j) = \\gcd(a_i, a_{i + 1}, \\cdots, a_j) G(i, j) = \\gcd(a_i, a_{i + 1}, \\cdots, a_j) M(i, j) = \\max(a_i, a_{i + 1}, \\cdots, a_j) M(i, j) = \\max(a_i, a_{i + 1}, \\cdots, a_j) P(i, j) = G(i, j) \\cdot M(i, j) P(i, j) = G(i, j) \\cdot M(i, j) F(A) = \\sum P(i, j) F(A) = \\sum P(i, j) \u7136\u540e\u5c31\u662f\u8981\u6c42 F(A) F(A) \u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u601d\u8def_1","text":"\u7b80\u5355\u6765\u8bf4\uff0c\u5c31\u662f\u6c42\u8fd9\u4e2a\u5e8f\u5217\u5f53\u4e2d\u4efb\u610f\u4e00\u4e2a\u8fde\u7eed\u5b50\u5e8f\u5217\u7684\u6700\u5927\u503c\u4e58\u4e0a\u5b50\u5e8f\u5217\u7684\u6700\u5927\u516c\u7ea6\u6570\u7684\u603b\u548c\u3002 \u9996\u5148\u6211\u4eec\u901a\u8fc7\u7b1b\u5361\u5c14\u6811\uff0c\u6c42\u51fa\u6bcf\u4e2a\u503c\u5b83\u6240\u63a7\u5236\u7684\u90a3\u6bb5\u8303\u56f4\u3002 \u7136\u540e\u679a\u4e3e\u6bcf\u4e2a\u503c\u4f5c\u4e3a\u6700\u5927\u503c\uff0c\u5e76\u4e14\u5047\u8bbe\u5b83\u63a7\u5236\u7684\u90a3\u6bb5\u5b57\u6bb5\u4e3a [l_i, r_i] [l_i, r_i] , \u7136\u540e\u679a\u4e3e\u77ed\u7684\u90a3\u8fb9\uff0c\u7528\u4e8c\u5206\u53bb\u5f04\u53e6\u4e00\u8fb9\u3002\u80fd\u8fd9\u4e48\u505a\u7684\u539f\u56e0\u662f\u56e0\u4e3a\uff0c\u4e00\u6bb5\u5e8f\u5217\u4e2d\uff0c\u63a7\u5236\u4e86\u8d77\u70b9\uff0c\u5bf9\u4e8e\u4e0d\u540c\u7ec8\u70b9\u6765\u8bf4\uff0c\u53ea\u6709 \\mathcal{O}(\\log n) \\mathcal{O}(\\log n) \u4e2a\u4e0d\u540c\u7684\u6700\u5927\u516c\u7ea6\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 2e5 + 10 ; constexpr int INF = 0x3f3f3f3f ; int n , a [ N ]; pII r [ N ]; struct Cartesian_Tree { struct node { int id , val , fa ; int son [ 2 ]; node () {} node ( int id , int val , int fa ) : id ( id ), val ( val ), fa ( fa ) { son [ 0 ] = son [ 1 ] = 0 ; } bool operator < ( const node & other ) const { return val > other . val ; } } t [ N ]; int root ; void init () { t [ 0 ] = node ( 0 , INF , 0 ); } void build ( int n , int * a ) { for ( int i = 1 ; i <= n ; ++ i ) { t [ i ] = node ( i , a [ i ], 0 ); } for ( int i = 1 ; i <= n ; ++ i ) { int k = i - 1 ; while ( t [ i ] < t [ k ]) { k = t [ k ]. fa ; } t [ i ]. son [ 0 ] = t [ k ]. son [ 1 ]; t [ k ]. son [ 1 ] = i ; t [ i ]. fa = k ; t [ t [ i ]. son [ 0 ]]. fa = i ; } root = t [ 0 ]. son [ 1 ]; } int dfs ( int u ) { if ( ! u ) return 0 ; int lsze = dfs ( t [ u ]. son [ 0 ]); int rsze = dfs ( t [ u ]. son [ 1 ]); r [ t [ u ]. id ] = pII ( lsze , rsze ); return lsze + rsze + 1 ; } } CT ; template < typename RMQItem , RMQItem base > struct RMQ { vector < RMQItem > v ; vector < vector < RMQItem >> tl , tr ; RMQItem op ( const RMQItem & a , const RMQItem & b ) { return __gcd ( a , b ); } int log2Up ( int n ) { int res = 0 ; while (( 1 << res ) < n ) res ++ ; return res ; } RMQ () {} RMQ ( const vector < RMQItem > & a ) { int n = a . size (); v = a ; tl = tr = vector < vector < RMQItem >> ( log2Up ( n ) + 1 , vector < RMQItem > ( n )); for ( int k = 0 ; ( 1 << k ) <= n ; ++ k ) { int ones = ( 1 << k ) - 1 ; RMQItem tmp = base ; for ( int i = 0 ; i < n ; ++ i ) { tmp = op ( tmp , a [ i ]); tl [ k ][ i ] = tmp ; if (( i & ones ) == ones ) tmp = base ; } tmp = base ; for ( int i = n - 1 ; i >= 0 ; -- i ) { tmp = op ( tmp , a [ i ]); tr [ k ][ i ] = tmp ; if (( i & ones ) == 0 ) tmp = base ; } } } RMQItem query ( int l , int r ) { -- l , -- r ; if ( l == r ) return v [ l ]; int num = 31 - __builtin_clz ( l ^ r ); return op ( tl [ num ][ r ], tr [ num ][ l ]); } }; RMQ < int , 0 > rmq ; int gao ( int l , int r , int _g ) { if ( l > r ) return 0 ; int res = 0 ; while ( l <= r ) { _g = __gcd ( _g , a [ l ]); int _l = l , _r = r , pos = _l ; while ( _r - _l >= 0 ) { int mid = ( _l + _r ) >> 1 ; if ( rmq . query ( l , mid ) % _g == 0 ) { pos = mid ; _l = mid + 1 ; } else { _r = mid - 1 ; } } chadd ( res , 1l l * ( pos - l + 1 ) * _g % mod ); l = pos + 1 ; } return res ; } int gao1 ( int l , int r , int _g ) { if ( l > r ) return 0 ; int res = 0 ; while ( l <= r ) { _g = __gcd ( _g , a [ r ]); int _l = l , _r = r , pos = _r ; while ( _r - _l >= 0 ) { int mid = ( _l + _r ) >> 1 ; if ( rmq . query ( mid , r ) % _g == 0 ) { pos = mid ; _r = mid - 1 ; } else { _l = mid + 1 ; } } chadd ( res , 1l l * ( r - pos + 1 ) * _g % mod ); r = pos - 1 ; } return res ; } void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]); CT . init (); CT . build ( n , a ); CT . dfs ( CT . root ); vector < int > vec ( a + 1 , a + 1 + n ); rmq = RMQ < int , 0 > ( vec ); int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { int now = 0 ; if ( r [ i ]. fi < r [ i ]. se ) { int _g = 0 ; for ( int j = 0 ; j <= r [ i ]. fi ; ++ j ) { _g = __gcd ( _g , a [ i - j ]); chadd ( now , gao ( i , i + r [ i ]. se , _g )); } } else { int _g = 0 ; for ( int j = 0 ; j <= r [ i ]. se ; ++ j ) { _g = __gcd ( _g , a [ i + j ]); chadd ( now , gao1 ( i - r [ i ]. fi , i , _g )); } } chadd ( res , 1l l * now * a [ i ] % mod ); // dbg(i, i - r[i].fi, i + r[i].se, now); } pt ( res ); } int main () { // ios::sync_with_stdio(false); // cin.tie(nullptr); cout.tie(nullptr); // cout << fixed << setprecision(20); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day1/#problem-c-bob-in-wonderland","text":"Solved By Dup4. 01:50(+1)","title":"Problem C. Bob in Wonderland"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u9898\u610f_2","text":"\u7ed9\u51fa\u4e00\u68f5\u6811\uff0c\u6bcf\u6b21\u53ef\u4ee5\u65ad\u6389\u4e00\u6761\u8fb9\u53d8\u6210\u4e24\u4e2a\u8fde\u901a\u5757\uff0c\u7136\u540e\u53ef\u4ee5\u52a0\u5165\u4e00\u6761\u8fb9\uff0c\u5c06\u4e24\u4e2a\u8fde\u901a\u5757\u8fde\u901a\u3002 \u95ee\u6700\u5c11\u591a\u5c11\u6b21\u64cd\u4f5c\u53ef\u4ee5\u5c06\u8fd9\u68f5\u6811\u53d8\u6210\u4e00\u4e2a\u94fe\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u601d\u8def_2","text":"\u5982\u679c\u662f\u4e00\u68f5\u6709\u6839\u6811\uff0c\u90a3\u4e48\u8d2a\u5fc3\u7b56\u7565\u662f\u56fa\u5b9a\u7684\uff0c\u5c31\u662f\u5bf9\u4e8e\u4e00\u4e2a\u70b9\uff0c\u5047\u8bbe\u5b83\u7684\u5b69\u5b50\u6709 x x \u4e2a\uff0c\u90a3\u4e48\u5bf9\u4e8e\u8fd9\u4e2a\u70b9\uff0c\u8981\u65ad\u6389 x - 1 x - 1 \u6761\u8fb9\u3002 \u73b0\u5728\u7684\u95ee\u9898\u662f\uff0c\u8fd9\u662f\u4e00\u68f5\u65e0\u6839\u6811\uff0c\u90a3\u4e48\u6362\u6839 DP \u4e00\u4e0b\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 3e5 + 10 ; constexpr int INF = 0x3f3f3f3f ; int n , f [ N ], g [ N ], fa [ N ], sze [ N ]; vector < vector < int >> G ; void dfs ( int u ) { sze [ u ] = 0 ; for ( auto & v : G [ u ]) { if ( v == fa [ u ]) continue ; fa [ v ] = u ; dfs ( v ); ++ sze [ u ]; f [ u ] += f [ v ]; } f [ u ] += max ( 0 , sze [ u ] - 1 ); } void dfs1 ( int u ) { for ( auto & v : G [ u ]) { if ( v == fa [ u ]) continue ; int _g = g [ u ]; if ( u == 1 ) _g += max ( 0 , sze [ u ] - 2 ); else _g += max ( 0 , sze [ u ] - 1 ); _g += f [ u ]; _g -= f [ v ]; _g -= max ( 0 , sze [ u ] - 1 ); g [ v ] += _g ; dfs1 ( v ); } } void run () { rd ( n ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v ; i < n ; ++ i ) { rd ( u , v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } memset ( f , 0 , sizeof f ); memset ( g , 0 , sizeof g ); fa [ 1 ] = 0 ; dfs ( 1 ); dfs1 ( 1 ); int res = INF ; for ( int i = 1 ; i <= n ; ++ i ) { chmin ( res , f [ i ] + g [ i ]); // dbg(2, f[i] + g[i]); } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day1/#problem-d-deep800080","text":"Solved By Dup4 & lts. 04:50(+7)","title":"Problem D. Deep800080"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u9898\u610f_3","text":"\u7ed9\u51fa n n \u4e2a\u70b9\uff0c\u7136\u540e\u53ef\u4ee5\u5728\u901a\u8fc7 (0, 0) (0, 0) \u5230 (A, B) (A, B) \u7684\u8fd9\u6761\u76f4\u7ebf\u4e0a\u627e\u4e00\u4e2a\u70b9\u753b\u4e00\u4e2a\u5706\uff0c\u534a\u5f84\u4e3a R R \uff0c\u4f7f\u5f97\u8fd9\u4e2a\u5706\u80fd\u591f\u8986\u76d6\u5230\u5c3d\u53ef\u80fd\u591a\u7684\u70b9\u3002 \u95ee\u6700\u591a\u80fd\u8986\u76d6\u5230\u591a\u5c11\u4e2a\u70b9\uff1f","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u601d\u8def_3","text":"\u4ee5\u6bcf\u4e2a\u70b9\u4e3a\u5706\u5fc3\uff0c\u534a\u5f84\u4e3a R R \u753b\u5706\uff0c\u7136\u540e\u5b83\u4f1a\u8ddf\u90a3\u6761\u76f4\u7ebf\u6700\u591a\u76f8\u4ea4\u4e24\u4e2a\u70b9\uff0c\u53ea\u8981\u6211\u4eec\u9009\u7684\u70b9\u843d\u5728\u8fd9\u4e24\u4e2a\u70b9\u786e\u5b9a\u7684\u7ebf\u6bb5\u4e4b\u5185\uff0c\u8fd9\u4e2a\u70b9\u5c31\u53ef\u4ee5\u88ab\u8986\u76d6\u3002 \u90a3\u4e48\u95ee\u9898\u53d8\u6210\u4e86\uff0c\u6709\u82e5\u5e72\u6761\u7ebf\u6bb5\uff0c\u95ee\u88ab\u7ebf\u6bb5\u8986\u76d6\u6b21\u6570\u6700\u591a\u7684\u70b9\u88ab\u8986\u76d6\u4e86\u591a\u5c11\u6b21\uff1f \u81f3\u4e8e\u7cbe\u5ea6\u95ee\u9898\u7684\u8bdd\uff0c\u6269\u5927\u4e00\u4e0b\u8f6c\u5316\u6210\u6574\u6570\u4f1a\u597d\u505a\u4e00\u70b9\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; using pDD = pair < db , db > ; using pDI = pair < db , int > ; using pLI = pair < ll , int > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 3e5 + 10 ; int n , r , a , b ; const db eps = 1e-5 ; const db PI = acos ( -1.0L ); int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; return x < 0 ? -1 : 1 ; } db sqr ( db x ) { return x * x ; } db fixOut ( db x ) { if ( sgn ( x ) == 0 ) return 0 ; return x ; } struct Point { db x , y ; Point ( db x = 0 , db y = 0 ) : x ( x ), y ( y ) {} void scan () { rd ( x , y ); } bool operator == ( const Point & b ) const { return sgn ( x - b . x ) == 0 && sgn ( y - b . y ) == 0 ; } bool operator < ( const Point & b ) const { return sgn ( x - b . x ) == 0 ? sgn ( y - b . y ) < 0 : x < b . x ; } Point operator + ( const Point & b ) const { return Point ( x + b . x , y + b . y ); } Point operator - ( const Point & b ) const { return Point ( x - b . x , y - b . y ); } Point operator * ( const db & b ) const { return Point ( x * b , y * b ); } Point operator / ( const db & b ) const { return Point ( x / b , y / b ); } db operator ^ ( const Point & b ) const { return x * b . y - y * b . x ; } db operator * ( const Point & b ) const { return x * b . x + y * b . y ; } db len () { return hypot ( x , y ); } db len2 () { return x * x + y * y ; } db dis ( Point b ) { return hypot ( x - b . x , y - b . y ); } db dis2 ( Point b ) { return ( x - b . x ) * ( x - b . x ) + ( y - b . y ) * ( y - b . y ); } Point trunc ( db r ) { db l = len (); if ( ! sgn ( l )) return * this ; r /= l ; return Point ( x * r , y * r ); } }; struct Line { Point s , e ; Line () {} Line ( Point s , Point e ) : s ( s ), e ( e ) {} bool operator == ( const Line & b ) const { return s == b . s && e == b . e ; } void adjust () { if ( e < s ) swap ( s , e ); } db length () { return s . dis ( e ); } db getAngle () { db k = atan2 ( e . y - s . y , e . x - s . x ); if ( sgn ( k ) < 0 ) k += PI ; if ( sgn ( k - PI ) == 0 ) k -= PI ; return k ; } int relationPoint ( Point p ) { int c = sgn (( p - s ) ^ ( e - s )); if ( c < 0 ) return 1 ; if ( c > 0 ) return 2 ; return 3 ; } bool pointOnSeg ( Point p ) { return sgn (( p - s ) ^ ( e - s )) == 0 && sgn (( p - s ) * ( p - e )) <= 0 ; } bool parallel ( Line b ) { return sgn (( e - s ) ^ ( b . e - b . s )) == 0 ; } int segCrossSeg ( Line b ) { int d1 = sgn (( e - s ) ^ ( b . s - s )); int d2 = sgn (( e - s ) ^ ( b . e - s )); int d3 = sgn (( b . e - b . s ) ^ ( s - b . s )); int d4 = sgn (( b . e - b . s ) ^ ( e - b . s )); if (( d1 ^ d2 ) == -2 && ( d3 ^ d4 ) == -2 ) return 2 ; return (( d1 == 0 && sgn (( b . s - s ) * ( b . s - e )) <= 0 ) || ( d2 == 0 && sgn (( b . e - s ) * ( b . e - e )) <= 0 ) || ( d3 == 0 && sgn (( s - b . s ) * ( s - b . e )) <= 0 ) || ( d4 == 0 && sgn (( e - b . s ) * ( e - b . e )) <= 0 )); } db disPointToLine ( Point p ) { return fabs (( p - s ) ^ ( e - s )) / length (); } db disPointToSeg ( Point p ) { if ( sgn (( p - s ) * ( e - s )) < 0 || sgn (( p - e ) * ( s - e )) < 0 ) return min ( p . dis ( s ), p . dis ( e )); return disPointToLine ( p ); } Point lineProg ( Point p ) { return s + ((( e - s ) * (( e - s ) * ( p - s ))) / (( e - s ). len2 ())); } }; struct Circle { Point p ; db r ; Circle () {} Circle ( Point p , db r ) : p ( p ), r ( r ) {} Circle ( db x , db y , db r ) : p ( Point ( x , y )), r ( r ) {} bool operator == ( const Circle & b ) const { return ( p == b . p ) && sgn ( r - b . r ) == 0 ; } bool operator < ( const Circle & b ) const { return (( p < b . p ) || (( p == b . p ) && sgn ( r - b . r ) < 0 )); } db area () { return PI * r * r ; } db circumference () { return PI * r * 2 ; } Point getPoint ( db rad ) { return Point ( p . x + cos ( rad ) * r , p . y + sin ( rad ) * r ); } int relationPoint ( Point b ) { db dis = b . dis ( p ); if ( sgn ( dis - r ) < 0 ) return 2 ; if ( sgn ( dis - r ) == 0 ) return 1 ; return 0 ; } int relationSeg ( Line b ) { db dis = b . disPointToSeg ( p ); if ( sgn ( dis - r ) < 0 ) return 2 ; if ( sgn ( dis - r ) == 0 ) return 1 ; return 0 ; } int relationLine ( Line b ) { db dis = b . disPointToLine ( p ); if ( sgn ( dis - r ) < 0 ) return 2 ; if ( sgn ( dis - r ) == 0 ) return 1 ; return 0 ; } int pointCrossLine ( Line b , Point & p1 , Point & p2 ) { if ( ! ( * this ). relationLine ( b )) return 0 ; Point a = b . lineProg ( p ); db d = b . disPointToLine ( p ); d = sqrt ( r * r - d * d ); if ( sgn ( d ) == 0 ) { p1 = p2 = a ; return 1 ; } p1 = a + ( b . e - b . s ). trunc ( d ); p2 = a - ( b . e - b . s ). trunc ( d ); return 2 ; } }; void run () { rd ( n , r , a , b ); Line l = Line ( Point ( 0 , 0 ), Point ( a , b )); int f = 0 ; if ( a == 0 ) f = 1 , a = b ; int L = 0 , R = a ; if ( L > R ) swap ( L , R ); vector < pLI > vec , _vec ; for ( int i = 1 ; i <= n ; ++ i ) { Point p ; p . scan (); Point p1 , p2 ; Circle c = Circle ( p , r ); int num = c . pointCrossLine ( l , p1 , p2 ); if ( f ) swap ( p1 . x , p1 . y ), swap ( p2 . x , p2 . y ); if ( num ) { db l = p1 . x ; db r = p2 . x ; if ( sgn ( l - r ) > 0 ) swap ( l , r ); // if (sgn(l - R) > 0) continue; // if (sgn(L - r) > 0) continue; // if (sgn(L - l) > 0) l = L; // if (sgn(r - R) > 0) r = R; ll _l = ll ( l * 1000000 ); ll _r = ll ( r * 1000000 ); vec . push_back ( pLI ( _l , 1 )); vec . push_back ( pLI ( _r + 1 , -1 )); } } sort ( all ( vec ), [ & ]( pLI a , pLI b ) { return a . fi < b . fi ; }); for ( auto & it : vec ) { if ( _vec . empty ()) _vec . push_back ( it ); else { if ( it . fi == _vec . back (). fi ) _vec . back (). se += it . se ; else { _vec . push_back ( it ); } } } int res = 0 , now = 0 ; for ( auto & it : _vec ) { now += it . se ; chmax ( res , now ); } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day1/#problem-e-zeldain-garden","text":"Solved By Dup4. 01:28(+)","title":"Problem E. Zeldain Garden"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u9898\u610f_4","text":"\u6c42 [l, r] [l, r] \u4e2d\u6bcf\u4e2a\u6570\u7684\u56e0\u6570\u4e2a\u6570\u4e4b\u548c\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u601d\u8def_4","text":"[1, n] [1, n] \u4e2d\u7684\u56e0\u5b50\u6570\u4e4b\u548c\u7684\u7b54\u6848\u662f \\displaystyle \\sum\\limits_{i = 1}^n \\lfloor \\frac{n}{i} \\rfloor \\displaystyle \\sum\\limits_{i = 1}^n \\lfloor \\frac{n}{i} \\rfloor \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; ll l , r ; ll gao ( ll n ) { if ( n < 0 ) return 0 ; if ( n == 1 ) return 1 ; ll sq = sqrt ( n ); while ( sq * sq <= n ) ++ sq ; while ( sq * sq > n ) -- sq ; ll res = 0 ; for ( ll i = 1 ; i <= sq ; ++ i ) { res += n / i ; } res *= 2 ; res -= sq * sq ; return res ; } void run () { rd ( l , r ); pt ( gao ( r ) - gao ( l - 1 )); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day1/#problem-f-light-emitting-hindenburg","text":"Upsolved By -.","title":"Problem F. Light Emitting Hindenburg"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u9898\u610f_5","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u601d\u8def_5","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day1/#problem-g-ks","text":"Upsolved By -.","title":"Problem G. K==S"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u9898\u610f_6","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u601d\u8def_6","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day1/#problem-h-ponk-warshall","text":"Solved By Dup4 & lts. 02:26(+)","title":"Problem H. Ponk Warshall"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u9898\u610f_7","text":"\u7ed9\u51fa\u8fde\u4e2a\u4e2a\u5b57\u7b26\u4e32 S S \u548c T T \uff0c\u5e76\u4e14\u53ea\u6709\u56db\u79cd\u5b57\u7b26 A , C , G , T \uff0c\u53ea\u6709\u4e00\u79cd\u64cd\u4f5c\uff0c\u5c31\u662f\u4ea4\u6362 S S \u4e2d\u4efb\u610f\u4e24\u4e2a\u4f4d\u7f6e\u7684\u5b57\u7b26\uff0c\u95ee\u6700\u5c11\u9700\u8981\u591a\u5c11\u6b21\u64cd\u4f5c\u80fd\u591f\u5c06 S S \u53d8\u6210 T T \u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u601d\u8def_7","text":"\u5bf9\u4e8e\u4e00\u4e2a\u73af\uff0c\u90a3\u4e48\u9700\u8981 \\mbox{\u73af\u7684\u957f\u5ea6} - 1 \\mbox{\u73af\u7684\u957f\u5ea6} - 1 \u6b21\u64cd\u4f5c\u80fd\u591f\u5c06\u8fd9\u4e2a\u73af\u4e0a\u7684\u6bcf\u4e00\u5bf9\u90fd\u590d\u539f\u3002 \u6bd4\u5982\u8bf4 AC \u548c CA \uff0c\u53ea\u9700\u8981\u4e00\u6b21\u4ea4\u6362\u3002 \u5e76\u4e14\u73af\u7684\u957f\u5ea6\u8d8a\u5c0f\u8d8a\u597d\uff0c\u5373\u73af\u7684\u4e2a\u6570\u8d8a\u591a\u8d8a\u597d\u3002 \u6211\u4eec\u867d\u7136\u4e0d\u77e5\u9053\u600e\u4e48\u8bc1\uff0c\u4f46\u662f\u6211\u4eec\u80fd\u731c\u51fa\u6765\u8d2a\u5fc3\u5148\u53bb\u627e\u4e8c\u5143\u73af\uff0c\u518d\u53bb\u627e\u4e09\u5143\u73af\uff0c\u518d\u53bb\u627e\u56db\u5143\u73af\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; using pCC = pair < char , char > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e6 + 10 ; int n ; char s [ N ], t [ N ]; map < pCC , int > mp ; void run () { cin >> ( s + 1 ) >> ( t + 1 ); n = strlen ( s + 1 ); // int cnt = 0; // for (auto &c1 : {'A', 'C', 'G', 'T'}) { // for (auto &c2 : {'A', 'C', 'G', 'T'}) { // if (c1 != c2) { // mp[pCC(c1, c2)] = ++cnt; // } // } // } for ( int i = 1 ; i <= n ; ++ i ) { char c1 = s [ i ]; char c2 = t [ i ]; if ( c1 != c2 ) { ++ mp [ pCC ( c1 , c2 )]; } } int res = 0 ; vector < char > vec ({ 'A' , 'C' , 'G' , 'T' }); for ( auto & c1 : vec ) { for ( auto & c2 : vec ) { if ( c1 != c2 ) { pCC t1 = pCC ( c1 , c2 ); pCC t2 = pCC ( c2 , c1 ); int Min = min ( mp [ t1 ], mp [ t2 ]); res += Min ; mp [ t1 ] -= Min ; mp [ t2 ] -= Min ; } } } do { char c1 = vec [ 0 ], c2 = vec [ 1 ], c3 = vec [ 2 ]; pII t1 = pCC ( c1 , c2 ); pII t2 = pCC ( c2 , c3 ); pII t3 = pCC ( c3 , c1 ); int Min = min ({ mp [ t1 ], mp [ t2 ], mp [ t3 ]}); res += Min * 2 ; mp [ t1 ] -= Min ; mp [ t2 ] -= Min ; mp [ t3 ] -= Min ; } while ( next_permutation ( all ( vec ))); int sum = 0 ; for ( auto & it : mp ) sum += it . se ; assert ( sum % 4 == 0 ); res += sum / 4 * 3 ; pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day1/#problem-i-saba1000kg","text":"Upsolved By -.","title":"Problem I. Saba1000kg"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u9898\u610f_8","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u601d\u8def_8","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day1/#problem-j-the-bugs","text":"Upsolved By -.","title":"Problem J. The Bugs"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u9898\u610f_9","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day1/#\u601d\u8def_9","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day2/","text":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day2 Contents Contest Info Solutions Problem A. AKU NEGARAKU \u9898\u610f \u601d\u8def Problem B. CHEAP DELIVERIES \u9898\u610f \u601d\u8def Problem C. ELI'S CURIOUS MIND \u9898\u610f \u601d\u8def Problem D. EXPLORACE \u9898\u610f \u601d\u8def Problem E. MATRIX MULTIPLICATION CALCULATOR \u9898\u610f \u601d\u8def Problem F. SUM OF SUB RECTANGLE AREAS \u9898\u610f \u601d\u8def Problem G. WAK SANI SATAY \u9898\u610f \u601d\u8def Problem H. STROOP EFFECT \u9898\u610f \u601d\u8def Problem I. SUPER BALL \u9898\u610f \u601d\u8def Problem J. VIRUS OUTBREAK \u9898\u610f \u601d\u8def Contest Info Practice Link Solved A B C D E F G H I J 10/10 O O O O O O O O \u00d8 O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions Problem A. AKU NEGARAKU Solved By Dup4. 00:20(+1) \u9898\u610f \u7ed9\u51fa n n \u4e2a\u6570\uff0c\u5e76\u4e14\u662f [1, n] [1, n] \u7684\u4e00\u4e2a\u6392\u5217\uff0c\u5e76\u4e14\u662f\u5347\u5e8f\u7684\u3002 \u8fd9 n n \u4e2a\u6570\u5f62\u6210\u4e00\u4e2a\u73af\uff0c\u7b2c\u4e00\u6b21\u7b2c m m \u4e2a\u6570\u5148\u51fa\u6765\uff0c\u7136\u540e\u5f80\u4e0b\u8f6e m m \u4e2a\u4f4d\u7f6e\u7684\u6570\u51fa\u6765\uff0c\u7136\u540e\u5f80\u4e0b\u8f6e m m \u4e2a\u4f4d\u7f6e\u7684\u6570\u51fa\u6765\u3002 \u95ee\u6700\u540e\u51fa\u6765\u7684\u90a3\u4e2a\u6570\u662f\u591a\u5c11\uff1f \u601d\u8def \u66b4\u529b\u6a21\u62df\u5c31\u6ca1\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m ; void run () { if ( n == 0 && m == 0 ) return ; vector < int > vec ; for ( int i = 1 ; i <= n ; ++ i ) vec . push_back ( i ); int st = m - 1 ; while ( SZ ( vec ) > 1 ) { // pt(*(vec.begin() + st)); st = ( st + SZ ( vec )) % SZ ( vec ); vec . erase ( vec . begin () + st ); st = ( st - 1 + SZ ( vec )) % SZ ( vec ); st = ( st + m ) % SZ ( vec ); } pt ( vec . back ()); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); while ( cin >> n >> m ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem B. CHEAP DELIVERIES Solved By Dup4. 03:11(+2) \u9898\u610f \u6709 n n \u4e2a\u70b9 m m \u6761\u8fb9\u7684\u65e0\u5411\u56fe\uff0c\u6709 k k \u8eba\u8fd0\u8f93\u9700\u6c42\uff0c\u8d77\u70b9\u4e3a f_i f_i \uff0c\u7ec8\u70b9\u4e3a d_i d_i \uff0c\u7ed3\u675f\u4e00\u8d9f\u9700\u6c42\u540e\u624d\u80fd\u5f00\u542f\u4e0b\u4e00\u8d9f\u9700\u6c42\u3002 \u95ee\u89e3\u51b3\u6240\u6709\u9700\u8981\u6700\u5c11\u9700\u8981\u591a\u5c11\u65f6\u95f4\uff1f \u601d\u8def \u5148\u5bf9\u6bcf\u4e2a\u9700\u6c42\u7684\u8d77\u70b9\u548c\u7ec8\u70b9\u4f5c\u4e3a\u8d77\u70b9\u8dd1\u6700\u77ed\u8def\u3002 \u7136\u540e\u72b6\u6001\u538b\u7f29 DP \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 2e4 + 10 ; constexpr int INF = 0x3f3f3f3f ; constexpr ll INFLL = 0x3f3f3f3f3f3f3f3f ; int n , m , k , id [ N ], fid [ N ]; pII a [ N ]; vector < vector < pII >> G ; ll f [ 1 << 19 ][ 19 ]; struct Dijkstra { struct node { int u ; ll w ; node ( int u = 0 , ll w = 0 ) : u ( u ), w ( w ) {} bool operator < ( const node & other ) const { return w > other . w ; } }; ll dis [ N ]; bool used [ N ]; void gao ( int s ) { for ( int i = 1 ; i <= n ; ++ i ) { dis [ i ] = INFLL ; used [ i ] = 0 ; } priority_queue < node > pq ; dis [ s ] = 0 ; pq . push ( node ( s , dis [ s ])); while ( ! pq . empty ()) { int u = pq . top (). u ; pq . pop (); if ( used [ u ]) continue ; used [ u ] = 1 ; for ( auto & it : G [ u ]) { int v = it . fi , w = it . se ; if ( dis [ v ] > dis [ u ] + w ) { dis [ v ] = dis [ u ] + w ; pq . push ( node ( v , dis [ v ])); } } } } } dij [ 50 ]; void run () { rd ( n , m , k ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v , w ; i <= m ; ++ i ) { rd ( u , v , w ); G [ u ]. push_back ( pII ( v , w )); G [ v ]. push_back ( pII ( u , w )); } memset ( id , 0 , sizeof id ); for ( int i = 0 ; i < k ; ++ i ) { rd ( a [ i ]. fi , a [ i ]. se ); if ( ! id [ a [ i ]. fi ]) id [ a [ i ]. fi ] = ++* id , fid [ * id ] = a [ i ]. fi ; if ( ! id [ a [ i ]. se ]) id [ a [ i ]. se ] = ++* id , fid [ * id ] = a [ i ]. se ; } for ( int i = 1 ; i <= * id ; ++ i ) dij [ i ]. gao ( fid [ i ]); memset ( f , 0x3f , sizeof f ); for ( int i = 0 ; i < k ; ++ i ) { f [ 1 << i ][ i ] = dij [ id [ a [ i ]. fi ]]. dis [ a [ i ]. se ]; } for ( int i = 1 ; i < 1 << k ; ++ i ) { for ( int j = 0 ; j < k ; ++ j ) if (( i >> j ) & 1 && f [ i ][ j ] < INF ) { for ( int o = 0 ; o < k ; ++ o ) if ( ! (( i >> o ) & 1 )) { chmin ( f [ i | ( 1 << o )][ o ], f [ i ][ j ] + dij [ id [ a [ o ]. fi ]]. dis [ a [ o ]. se ] + dij [ id [ a [ j ]. se ]]. dis [ a [ o ]. fi ]); } } } ll res = INFLL ; for ( int i = 0 ; i < k ; ++ i ) chmin ( res , f [( 1 << k ) - 1 ][ i ]); if ( res >= INFLL ) res = -1 ; pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem C. ELI'S CURIOUS MIND Solved By Dup4. 01:23(+) \u9898\u610f \u7ed9\u51fa\u4e00\u4e2a n n \uff0c\u95ee\u6709\u591a\u5c11\u4e2a\u6ee1\u8db3\u6761\u4ef6\u7684\u5b50\u96c6\uff1f \u600e\u6837\u7b97\u6ee1\u8db3\u6761\u4ef6\uff1f \u96c6\u5408\u4e2d\u7684\u4efb\u610f\u4e24\u4e2a\u6570\u4e0d\u76f8\u90bb\u3002 \u96c6\u5408\u4e2d\u4e0d\u80fd\u518d\u6dfb\u52a0\u4efb\u610f\u4e00\u4e2a [1, n] [1, n] \u5185\u7684\u6570\uff0c\u5e76\u4e14\u8be5\u96c6\u5408\u4ecd\u7136\u6ee1\u8db3\u7b2c\u4e00\u4e2a\u6761\u4ef6\u3002 \u601d\u8def \u8003\u8651 f[i] f[i] \u8868\u793a\u6700\u5927\u7684\u90a3\u4e2a\u6570\u662f i i \u5e76\u4e14\u6ee1\u8db3\u7b2c\u4e00\u4e2a\u6761\u4ef6\u7684\u96c6\u5408\u6570\u91cf\u3002 \u90a3\u4e48\u5bf9\u4e8e n n \uff0c\u5b83\u7684\u7b54\u6848\u5c31\u662f f[n] + f[n - 1] f[n] + f[n - 1] \u3002 \u8003\u8651 f[i] f[i] \u5982\u4f55\u9012\u63a8\uff1f \u9996\u5148\u5b83\u53ef\u4ee5\u5728 f[i - 2] f[i - 2] \u7684\u57fa\u7840\u4e0a\u52a0\u4e0a i i \uff0c\u4ecd\u7136\u6ee1\u8db3\u7b2c\u4e00\u4e2a\u6761\u4ef6\u3002 \u5176\u6b21\u5b83\u53ef\u4ee5\u5728 f[i - 3] f[i - 3] \u7684\u57fa\u7840\u4e0a\u52a0\u4e0a i i \uff0c\u4ecd\u7136\u6ee1\u8db3\u7b2c\u4e00\u4e2a\u6761\u4ef6\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e2 + 10 ; int n ; ll f [ N ]; void run () { if ( n <= 2 ) return pt ( 0 ); f [ 3 ] = 1 ; f [ 4 ] = 2 ; f [ 5 ] = 2 ; f [ 6 ] = 3 ; for ( int i = 7 ; i <= n ; ++ i ) { f [ i ] = f [ i - 2 ] + f [ i - 3 ]; } pt ( f [ n ] + f [ n - 1 ]); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( cin >> n && n ) { cout << \"Case #\" << _T << \": \" ; ++ _T ; run (); } // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem D. EXPLORACE Solved By Dup4. 00:55(+) \u9898\u610f \u9898\u610f\u6ca1\u8bfb\u61c2\uff0c\u611f\u89c9\u5c31\u662f\u6c42\u6700\u5c0f\u751f\u6210\u6811\u3002 \u601d\u8def \u6c42\u4e86\u6700\u5c0f\u751f\u6210\u6811\u5c31\u8fc7\u4e86\uff0c\u4f46\u662f\u6570\u636e\u8303\u56f4\u5f88\u8ff7\u60d1\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m ; struct Edge { int u , v , w ; Edge () {} Edge ( int u , int v , int w ) : u ( u ), v ( v ), w ( w ) {} bool operator < ( const Edge & other ) const { return w < other . w ; } } e [ N ]; int fa [ N ]; int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } void Kruskal () { int res = 0 ; memset ( fa , 0 , sizeof fa ); int tot = m ; sort ( e + 1 , e + 1 + tot ); for ( int i = 1 ; i <= tot ; ++ i ) { int u = e [ i ]. u , v = e [ i ]. v , w = e [ i ]. w ; int fu = find ( u ), fv = find ( v ); if ( fu == fv ) continue ; res += w ; fa [ fu ] = fv ; } pt ( res , \"meters\" ); } void run () { rd ( n , m ); for ( int i = 1 ; i <= m ; ++ i ) { rd ( e [ i ]. u , e [ i ]. v , e [ i ]. w ); } Kruskal (); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); // while (_T--) run(); for ( int kase = 1 ; kase <= _T ; ++ kase ) { cout << \"Case #\" << kase << \": \" ; run (); } // while (cin >> n) run(); // run(); return 0 ; } Problem E. MATRIX MULTIPLICATION CALCULATOR Solved By Dup4. 00:27(+) \u9898\u610f \u7ed9\u51fa\u4e24\u4e2a\u77e9\u9635\uff0c\u5982\u679c\u80fd\u591f\u76f8\u4e58\uff0c\u5c31\u6309\u683c\u5f0f\u8f93\u51fa\u76f8\u4e58\u7ed3\u679c\uff0c\u5426\u5219\u8f93\u51fa undefined \u3002 \u601d\u8def \u7b7e\u5230\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int m , n , p , q ; struct node { ll a [ 30 ][ 30 ]; node () {} } A , B , res ; void run () { for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { rd ( A . a [ i ][ j ]); } } for ( int i = 1 ; i <= p ; ++ i ) { for ( int j = 1 ; j <= q ; ++ j ) { rd ( B . a [ i ][ j ]); } } if ( n != p ) { cout << \"undefined \\n \" ; } else { for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= q ; ++ j ) { res . a [ i ][ j ] = 0 ; for ( int k = 1 ; k <= n ; ++ k ) { res . a [ i ][ j ] += A . a [ i ][ k ] * B . a [ k ][ j ]; } } } for ( int i = 1 ; i <= m ; ++ i ) { cout << \"|\" ; for ( int j = 1 ; j <= q ; ++ j ) { cout << \" \" << res . a [ i ][ j ]; } cout << \" | \\n \" ; } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( cin >> m >> n >> p >> q ) { if ( m == 0 && n == 0 && p == 0 && q == 0 ) break ; cout << \"Case #\" << _T << \": \\n \" ; ++ _T ; run (); } return 0 ; } Problem F. SUM OF SUB RECTANGLE AREAS Solved By Dup4 & lts. 02:06(+) \u9898\u610f \u7ed9\u51fa n n \uff0c\u6c42\u4e0b\u9762\u4ee3\u7801\u8f93\u51fa\u7684\u7ed3\u679c\u3002 sum = 0 for r1 = 0 to N-1 for c1 = 0 to N-1 for r2 = r1+1 to N for c2 = r2+1 to N sum = sum + (r2-r1)*(c2-c1) print(sum) \u601d\u8def \u961f\u53cb\u53d1\u73b0\u6837\u4f8b\u4e2d\u7684\u7b54\u6848\u90fd\u662f\u5e73\u65b9\u6570\uff0c\u7136\u540e\u6253\u4e86\u4e2a\u8868\u627e\u4e86\u627e\u89c4\u5f8b\u3002\u4f5c\u4e8c\u7ea7\u5dee\u5206\u540e\uff0c\u53d1\u73b0\u5e73\u65b9\u6839\u5b58\u5728\u5982\u4e0b\u89c4\u5f8b\uff1a 1 4 10 20 35 56 84 120 165 3 6 10 15 21 28 36 45 3 4 5 6 7 8 9 \u8fd9\u4e2a\u4e1c\u897f\u76f4\u63a5\u7528\u77e9\u9635\u5feb\u901f\u5e42\u9012\u63a8\u5c31\u53ef\u4ee5\u4e86\u3002 \u4f46\u662f\u961f\u53cb\u53d1\u73b0\u8fd9\u4e2a\u5e73\u65b9\u7684\u7b54\u6848\u5728\u6768\u8f89\u4e09\u89d2\u4e2d\u90fd\u51fa\u73b0\u4e86\uff1a \u90a3\u4e48\u8fd9\u662f\u4e0d\u662f\u610f\u5473\u7740\uff0c\u6ee1\u8db3\u67d0\u79cd\u89c4\u5f8b\u7684\u7ec4\u5408\u6570\u80fd\u591f\u7528\u77e9\u9635\u5feb\u901f\u5e42\u5feb\u901f\u6c42\u51fa\u6765\u3002 Code def mul ( a , b ): res = [ [ 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 ] ] for i in range ( 0 , 4 ): for j in range ( 0 , 4 ): # res[i][j] = 0 for k in range ( 0 , 4 ): res [ i ][ j ] += a [ i ][ k ] * b [ k ][ j ] #print(res[i][j]) return res def gao ( base , res , n ): while n > 0 : if ( n & 1 ) == 1 : res = mul ( res , base ) base = mul ( base , base ) n >>= 1 return res T = int ( input ()) for i in range ( T ): n = int ( input ()) base = [ [ 1 , 0 , 0 , 0 ], [ 1 , 1 , 0 , 0 ], [ 0 , 1 , 1 , 0 ], [ 0 , 0 , 1 , 1 ] ] res = [ [ 1 , 3 , 3 , 1 ], [ 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 ] ] # res = mul(res, base) # res = mul(res, base) # for i in range (4): # print(res[0][i], end=\" \") #print(\"\") # res = mul(res, base); res = gao ( base , res , n - 1 ) print ( res [ 0 ][ 0 ] ** 2 ) Problem G. WAK SANI SATAY Solved By groggy_. 03:05(+) \u9898\u610f \u7ed9\u51fa\u4e09\u79cd\u7c7b\u578b\u539f\u6750\u6599\u6bcf\u4efd\u7684\u552e\u4ef7\u3001\u52a0\u5de5\u8d39\u4ee5\u53ca\u6bcf\u516c\u65a4\u539f\u6750\u6599\u6210\u672c\u3002 \u7ed9\u51fa\u914d\u6599\u7684\u552e\u4ef7\u548c\u6210\u672c\u3002 \u6c42\u4e00\u5468\u5185\u7684\u51c0\u5229\u6da6\u3002 \u601d\u8def \u6309\u9898\u610f\u8ba1\u7b97\u5373\u53ef\u3002 Code #include <iostream> typedef long long ll ; using namespace std ; double solve ( ll chicken , ll beef , ll lamb , ll nasi ) { double net_profit = 0 ; net_profit += chicken * 0.8 ; net_profit += beef * 1 ; net_profit += lamb * 1.2 ; net_profit += nasi * 0.8 ; double gross_profit = 0 ; gross_profit += 15.5 * chicken ; gross_profit += 32 * beef ; gross_profit += 40 * lamb ; gross_profit /= 85 ; gross_profit += 0.2 * nasi ; return net_profit - gross_profit ; } int main () { int n ; int Case = 0 ; while ( cin >> n ) { if ( ! n ) break ; ll chicken = 0 , beef = 0 , lamb = 0 , nasi = 0 ; ll a , b , c , d ; double result = 0 ; while ( n -- ) { cin >> a >> b >> c >> d ; chicken += a ; beef += b ; lamb += c ; nasi += d ; result += solve ( a , b , c , d ); } printf ( \"Case #%d: RM%.2lf \\n \" , ++ Case , result ); } } Problem H. STROOP EFFECT Solved By groggy_. 04:23(+1) \u9898\u610f \u7ed9\u51fa\u4e00\u4e32\u5b57\u7b26\u4e32\u8981\u6c42\u5224\u65ad\u662f\u5426\u4e3a Stroop \u5b57\u7b26\u4e32\u7531\u591a\u4e2a\u4e24\u4f4d\u6570\u7ec4\u6210\uff0c\u4e24\u4f4d\u6570\u7684\u5341\u4f4d\u548c\u4e2a\u4f4d\u76f8\u540c\u4ee3\u8868\u4e00\u81f4\uff0c\u5426\u5219\u4ee3\u8868\u4e0d\u4e00\u81f4\u3002 \u601d\u8def \u7531\u4e24\u4f4d\u6570\u5f62\u6210\u56fe\u4e2d\u8868\u683c \u7b26\u5408\u8981\u6c42\u4e3a\uff1a 1\u3001\u8868\u683c\u4e2d\u4e00\u81f4\u548c\u4e0d\u4e00\u81f4\u6570\u91cf\u76f8\u540c 2\u3001\u8868\u683c\u6bcf\u884c\u4e00\u81f4\u548c\u4e0d\u4e00\u81f4\u6570\u91cf\u76f8\u540c 3\u3001\u8868\u683c\u6bcf\u5217\u4e00\u81f4\u548c\u4e0d\u4e00\u81f4\u6570\u91cf\u76f8\u540c 4\u3001\u5b57\u7b26\u4e32\u4e2d\u6570\u5b57\u7684\u5341\u4f4d\u548c\u4e2a\u4f4d\u6570\u4e0d\u80fd\u51fa\u73b0\u8fde\u7eed 3 \u4e2a\u53ca\u4ee5\u4e0a\u76f8\u540c \u6309\u8981\u6c42\u5224\u5b9a Code #include <cstring> #include <iostream> #include <vector> using namespace std ; int num [ 5 ][ 5 ]; bool jug () { int sum = 0 ; int sum1 = 0 ; for ( int i = 1 ; i <= 4 ; i ++ ) { for ( int j = 1 ; j <= 4 ; j ++ ) { sum += num [ i ][ j ]; if ( i == j ) sum1 += num [ i ][ j ]; } } if ( sum1 != sum - sum1 ) return 1 ; for ( int i = 1 ; i <= 4 ; i ++ ) { int total = 0 ; for ( int j = 1 ; j <= 4 ; j ++ ) { if ( i == j ) continue ; total += num [ i ][ j ]; } if ( total != num [ i ][ i ]) return 1 ; } for ( int j = 1 ; j <= 4 ; j ++ ) { int total = 0 ; for ( int i = 1 ; i <= 4 ; i ++ ) { if ( i == j ) continue ; total += num [ i ][ j ]; } if ( total != num [ j ][ j ]) return 1 ; } return 0 ; } int main () { int n ; cin >> n ; for ( int Case = 1 ; Case <= n ; Case ++ ) { memset ( num , 0 , sizeof num ); int flag = 0 ; int a ; vector < int > v1 , v2 ; while ( cin >> a ) { int t1 = a / 10 ; int t2 = a % 10 ; if ( t1 == 0 && t2 == 0 ) break ; num [ t1 ][ t2 ] ++ ; v1 . push_back ( t1 ); v2 . push_back ( t2 ); } for ( int i = 0 ; i < v1 . size (); i ++ ) { if ( i >= 2 && v1 [ i ] == v1 [ i - 1 ] && v1 [ i ] == v1 [ i - 2 ]) flag = 1 ; } for ( int i = 0 ; i < v2 . size (); i ++ ) { if ( i >= 2 && v2 [ i ] == v2 [ i - 1 ] && v2 [ i ] == v2 [ i - 2 ]) flag = 1 ; } if ( jug ()) flag = 1 ; if ( flag ) printf ( \"Case #%d: Not Stroop \\n \" , Case ); else printf ( \"Case #%d: Stroop \\n \" , Case ); } } Problem I. SUPER BALL Upsolved By Dup4. \u9898\u610f \u6709 n n \u4e2a\u5de5\u5382\uff0c m m \u79cd\u7403\uff0c\u7ed9\u51fa\u4efb\u610f\u4e24\u4e2a\u5de5\u5382\u4e4b\u95f4\u7684\u8fd0\u8f93\u65f6\u95f4\uff0c\u7ed9\u51fa\u6bcf\u4e2a\u5de5\u5382\u5bf9\u4e8e\u6bcf\u79cd\u7403\u751f\u4ea7\u548c\u56de\u6536\u5206\u522b\u6240\u9700\u7684\u82b1\u8d39\uff0c\u5982\u679c\u662f -1 -1 \u8868\u793a\u8be5\u5de5\u5382\u4e0d\u80fd\u751f\u4ea7\u6216\u56de\u6536\u8be5\u7403\u3002 \u73b0\u5728\u6709\u4e00\u4e2a\u5de5\u827a\u54c1\uff0c\u9700\u8981\u5236\u9020 q q \u4e2a\u7403\uff0c\u5e76\u4e14\u9700\u8981\u6309\u987a\u5e8f\u5355\u7ebf\u7a0b\u5236\u9020\uff0c\u5236\u9020\u5b8c\u4e86\u8fd8\u9700\u8981\u56de\u6536\u3002 \u4f46\u662f\u5236\u9020\u6700\u540e\u4e00\u4e2a\u7403\u548c\u56de\u6536\u6700\u540e\u4e00\u4e2a\u7403\u7684\u65f6\u5019\u6240\u5728\u7684\u5de5\u5382\u4e0d\u9700\u8981\u76f8\u540c\uff0c\u5e76\u4e14\u8fd9\u4e2d\u95f4\u4e5f\u4e0d\u9700\u8981\u8f6c\u79fb\u8d39\u7528\u3002 \u95ee\u751f\u4ea7\u548c\u56de\u6536\u8fc7\u7a0b\u6700\u5c11\u9700\u8981\u591a\u5c11\u8d39\u7528\u3002 \u601d\u8def \u4e24\u4e2a\u6d41\u7a0b\u57fa\u672c\u4e00\u81f4\uff0c\u53ea\u662f\u987a\u5e8f\u4e0d\u4e00\u6837\uff0c\u90a3\u4e48\u505a\u4e24\u904d DP \u5373\u53ef\u3002\u8003\u8651 f_{i, j} f_{i, j} \u8868\u793a\u76ee\u524d\u751f\u4ea7/\u56de\u6536\u5230\u7b2c i i \u4e2a\u7403\uff0c\u5f53\u524d\u5904\u4e8e\u7684\u5de5\u5382\u4e3a j j \u65f6\u7684\u6700\u5c0f\u8d39\u7528\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 5e2 + 10 ; constexpr ll INF = 0x3f3f3f3f3f3f3f3f ; int n , m ; ll D [ N ][ N ], R [ N ][ N ], G [ N ], g [ N ][ N ], f [ N ][ N ], h [ N ][ N ]; void run () { rd ( n , m ); for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { rd ( g [ i ][ j ]); } for ( int j = 1 ; j <= m ; ++ j ) { rd ( R [ i ][ j ]); } for ( int j = 1 ; j <= m ; ++ j ) { rd ( D [ i ][ j ]); } } rd ( * G ); for ( int i = 1 ; i <= * G ; ++ i ) rd ( G [ i ]); for ( int k = 1 ; k <= n ; ++ k ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { g [ i ][ j ] = min ( g [ i ][ j ], g [ i ][ k ] + g [ k ][ j ]); } } } // reverse(G + 1, G + 1 + *G); memset ( h , 0x3f , sizeof h ); memset ( h [ 0 ], 0 , sizeof h [ 0 ]); memset ( f , 0x3f , sizeof f ); memset ( f [ 0 ], 0 , sizeof f [ 0 ]); for ( int i = 0 ; i < * G ; ++ i ) { int x = G [ i + 1 ]; for ( int j = 1 ; j <= n ; ++ j ) if ( f [ i ][ j ] < INF ) { for ( int k = 1 ; k <= n ; ++ k ) { if ( R [ k ][ x ] != -1 ) { if ( ! i ) { f [ 1 ][ k ] = R [ k ][ x ]; continue ; } chmin ( f [ i + 1 ][ k ], f [ i ][ j ] + R [ k ][ x ] + g [ j ][ k ]); } } } } reverse ( G + 1 , G + 1 + * G ); for ( int i = 0 ; i < * G ; ++ i ) { int x = G [ i + 1 ]; for ( int j = 1 ; j <= n ; ++ j ) if ( h [ i ][ j ] < INF ) { for ( int k = 1 ; k <= n ; ++ k ) { if ( D [ k ][ x ] != -1 ) { if ( ! i ) { h [ 1 ][ k ] = D [ k ][ x ]; continue ; } chmin ( h [ i + 1 ][ k ], h [ i ][ j ] + D [ k ][ x ] + g [ j ][ k ]); } } } } ll res = INF ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { chmin ( res , f [ * G ][ i ] + h [ * G ][ j ]); // + g[i][j]); } } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem J. VIRUS OUTBREAK Solved By Dup4. 00:36(+) \u9898\u610f \u6c42\u51fa\u51e0\u4e2a\u6570\uff0c\u8ba9\u627e\u89c4\u5f8b\u3002 \u601d\u8def \u6590\u6ce2\u90a3\u5951\u3002 Code a = [ 0 ] * 500 a [ 1 ] = 1 a [ 2 ] = 1 for i in range ( 3 , 500 ): a [ i ] = a [ i - 1 ] + a [ i - 2 ] while True : n = int ( input ()) if n == - 1 : break print ( \"Hour: %d : %d cow(s) affected\" % ( n , a [ n ]))","title":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day2"},{"location":"2020/nowcoder-national-day-training-party/day2/#contest-info","text":"Practice Link Solved A B C D E F G H I J 10/10 O O O O O O O O \u00d8 O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"2020/nowcoder-national-day-training-party/day2/#solutions","text":"","title":"Solutions"},{"location":"2020/nowcoder-national-day-training-party/day2/#problem-a-aku-negaraku","text":"Solved By Dup4. 00:20(+1)","title":"Problem A. AKU NEGARAKU"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u9898\u610f","text":"\u7ed9\u51fa n n \u4e2a\u6570\uff0c\u5e76\u4e14\u662f [1, n] [1, n] \u7684\u4e00\u4e2a\u6392\u5217\uff0c\u5e76\u4e14\u662f\u5347\u5e8f\u7684\u3002 \u8fd9 n n \u4e2a\u6570\u5f62\u6210\u4e00\u4e2a\u73af\uff0c\u7b2c\u4e00\u6b21\u7b2c m m \u4e2a\u6570\u5148\u51fa\u6765\uff0c\u7136\u540e\u5f80\u4e0b\u8f6e m m \u4e2a\u4f4d\u7f6e\u7684\u6570\u51fa\u6765\uff0c\u7136\u540e\u5f80\u4e0b\u8f6e m m \u4e2a\u4f4d\u7f6e\u7684\u6570\u51fa\u6765\u3002 \u95ee\u6700\u540e\u51fa\u6765\u7684\u90a3\u4e2a\u6570\u662f\u591a\u5c11\uff1f","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u601d\u8def","text":"\u66b4\u529b\u6a21\u62df\u5c31\u6ca1\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m ; void run () { if ( n == 0 && m == 0 ) return ; vector < int > vec ; for ( int i = 1 ; i <= n ; ++ i ) vec . push_back ( i ); int st = m - 1 ; while ( SZ ( vec ) > 1 ) { // pt(*(vec.begin() + st)); st = ( st + SZ ( vec )) % SZ ( vec ); vec . erase ( vec . begin () + st ); st = ( st - 1 + SZ ( vec )) % SZ ( vec ); st = ( st + m ) % SZ ( vec ); } pt ( vec . back ()); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); while ( cin >> n >> m ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day2/#problem-b-cheap-deliveries","text":"Solved By Dup4. 03:11(+2)","title":"Problem B. CHEAP DELIVERIES"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u9898\u610f_1","text":"\u6709 n n \u4e2a\u70b9 m m \u6761\u8fb9\u7684\u65e0\u5411\u56fe\uff0c\u6709 k k \u8eba\u8fd0\u8f93\u9700\u6c42\uff0c\u8d77\u70b9\u4e3a f_i f_i \uff0c\u7ec8\u70b9\u4e3a d_i d_i \uff0c\u7ed3\u675f\u4e00\u8d9f\u9700\u6c42\u540e\u624d\u80fd\u5f00\u542f\u4e0b\u4e00\u8d9f\u9700\u6c42\u3002 \u95ee\u89e3\u51b3\u6240\u6709\u9700\u8981\u6700\u5c11\u9700\u8981\u591a\u5c11\u65f6\u95f4\uff1f","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u601d\u8def_1","text":"\u5148\u5bf9\u6bcf\u4e2a\u9700\u6c42\u7684\u8d77\u70b9\u548c\u7ec8\u70b9\u4f5c\u4e3a\u8d77\u70b9\u8dd1\u6700\u77ed\u8def\u3002 \u7136\u540e\u72b6\u6001\u538b\u7f29 DP \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 2e4 + 10 ; constexpr int INF = 0x3f3f3f3f ; constexpr ll INFLL = 0x3f3f3f3f3f3f3f3f ; int n , m , k , id [ N ], fid [ N ]; pII a [ N ]; vector < vector < pII >> G ; ll f [ 1 << 19 ][ 19 ]; struct Dijkstra { struct node { int u ; ll w ; node ( int u = 0 , ll w = 0 ) : u ( u ), w ( w ) {} bool operator < ( const node & other ) const { return w > other . w ; } }; ll dis [ N ]; bool used [ N ]; void gao ( int s ) { for ( int i = 1 ; i <= n ; ++ i ) { dis [ i ] = INFLL ; used [ i ] = 0 ; } priority_queue < node > pq ; dis [ s ] = 0 ; pq . push ( node ( s , dis [ s ])); while ( ! pq . empty ()) { int u = pq . top (). u ; pq . pop (); if ( used [ u ]) continue ; used [ u ] = 1 ; for ( auto & it : G [ u ]) { int v = it . fi , w = it . se ; if ( dis [ v ] > dis [ u ] + w ) { dis [ v ] = dis [ u ] + w ; pq . push ( node ( v , dis [ v ])); } } } } } dij [ 50 ]; void run () { rd ( n , m , k ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v , w ; i <= m ; ++ i ) { rd ( u , v , w ); G [ u ]. push_back ( pII ( v , w )); G [ v ]. push_back ( pII ( u , w )); } memset ( id , 0 , sizeof id ); for ( int i = 0 ; i < k ; ++ i ) { rd ( a [ i ]. fi , a [ i ]. se ); if ( ! id [ a [ i ]. fi ]) id [ a [ i ]. fi ] = ++* id , fid [ * id ] = a [ i ]. fi ; if ( ! id [ a [ i ]. se ]) id [ a [ i ]. se ] = ++* id , fid [ * id ] = a [ i ]. se ; } for ( int i = 1 ; i <= * id ; ++ i ) dij [ i ]. gao ( fid [ i ]); memset ( f , 0x3f , sizeof f ); for ( int i = 0 ; i < k ; ++ i ) { f [ 1 << i ][ i ] = dij [ id [ a [ i ]. fi ]]. dis [ a [ i ]. se ]; } for ( int i = 1 ; i < 1 << k ; ++ i ) { for ( int j = 0 ; j < k ; ++ j ) if (( i >> j ) & 1 && f [ i ][ j ] < INF ) { for ( int o = 0 ; o < k ; ++ o ) if ( ! (( i >> o ) & 1 )) { chmin ( f [ i | ( 1 << o )][ o ], f [ i ][ j ] + dij [ id [ a [ o ]. fi ]]. dis [ a [ o ]. se ] + dij [ id [ a [ j ]. se ]]. dis [ a [ o ]. fi ]); } } } ll res = INFLL ; for ( int i = 0 ; i < k ; ++ i ) chmin ( res , f [( 1 << k ) - 1 ][ i ]); if ( res >= INFLL ) res = -1 ; pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day2/#problem-c-elis-curious-mind","text":"Solved By Dup4. 01:23(+)","title":"Problem C. ELI'S CURIOUS MIND"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u9898\u610f_2","text":"\u7ed9\u51fa\u4e00\u4e2a n n \uff0c\u95ee\u6709\u591a\u5c11\u4e2a\u6ee1\u8db3\u6761\u4ef6\u7684\u5b50\u96c6\uff1f \u600e\u6837\u7b97\u6ee1\u8db3\u6761\u4ef6\uff1f \u96c6\u5408\u4e2d\u7684\u4efb\u610f\u4e24\u4e2a\u6570\u4e0d\u76f8\u90bb\u3002 \u96c6\u5408\u4e2d\u4e0d\u80fd\u518d\u6dfb\u52a0\u4efb\u610f\u4e00\u4e2a [1, n] [1, n] \u5185\u7684\u6570\uff0c\u5e76\u4e14\u8be5\u96c6\u5408\u4ecd\u7136\u6ee1\u8db3\u7b2c\u4e00\u4e2a\u6761\u4ef6\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u601d\u8def_2","text":"\u8003\u8651 f[i] f[i] \u8868\u793a\u6700\u5927\u7684\u90a3\u4e2a\u6570\u662f i i \u5e76\u4e14\u6ee1\u8db3\u7b2c\u4e00\u4e2a\u6761\u4ef6\u7684\u96c6\u5408\u6570\u91cf\u3002 \u90a3\u4e48\u5bf9\u4e8e n n \uff0c\u5b83\u7684\u7b54\u6848\u5c31\u662f f[n] + f[n - 1] f[n] + f[n - 1] \u3002 \u8003\u8651 f[i] f[i] \u5982\u4f55\u9012\u63a8\uff1f \u9996\u5148\u5b83\u53ef\u4ee5\u5728 f[i - 2] f[i - 2] \u7684\u57fa\u7840\u4e0a\u52a0\u4e0a i i \uff0c\u4ecd\u7136\u6ee1\u8db3\u7b2c\u4e00\u4e2a\u6761\u4ef6\u3002 \u5176\u6b21\u5b83\u53ef\u4ee5\u5728 f[i - 3] f[i - 3] \u7684\u57fa\u7840\u4e0a\u52a0\u4e0a i i \uff0c\u4ecd\u7136\u6ee1\u8db3\u7b2c\u4e00\u4e2a\u6761\u4ef6\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e2 + 10 ; int n ; ll f [ N ]; void run () { if ( n <= 2 ) return pt ( 0 ); f [ 3 ] = 1 ; f [ 4 ] = 2 ; f [ 5 ] = 2 ; f [ 6 ] = 3 ; for ( int i = 7 ; i <= n ; ++ i ) { f [ i ] = f [ i - 2 ] + f [ i - 3 ]; } pt ( f [ n ] + f [ n - 1 ]); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( cin >> n && n ) { cout << \"Case #\" << _T << \": \" ; ++ _T ; run (); } // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day2/#problem-d-explorace","text":"Solved By Dup4. 00:55(+)","title":"Problem D. EXPLORACE"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u9898\u610f_3","text":"\u9898\u610f\u6ca1\u8bfb\u61c2\uff0c\u611f\u89c9\u5c31\u662f\u6c42\u6700\u5c0f\u751f\u6210\u6811\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u601d\u8def_3","text":"\u6c42\u4e86\u6700\u5c0f\u751f\u6210\u6811\u5c31\u8fc7\u4e86\uff0c\u4f46\u662f\u6570\u636e\u8303\u56f4\u5f88\u8ff7\u60d1\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m ; struct Edge { int u , v , w ; Edge () {} Edge ( int u , int v , int w ) : u ( u ), v ( v ), w ( w ) {} bool operator < ( const Edge & other ) const { return w < other . w ; } } e [ N ]; int fa [ N ]; int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } void Kruskal () { int res = 0 ; memset ( fa , 0 , sizeof fa ); int tot = m ; sort ( e + 1 , e + 1 + tot ); for ( int i = 1 ; i <= tot ; ++ i ) { int u = e [ i ]. u , v = e [ i ]. v , w = e [ i ]. w ; int fu = find ( u ), fv = find ( v ); if ( fu == fv ) continue ; res += w ; fa [ fu ] = fv ; } pt ( res , \"meters\" ); } void run () { rd ( n , m ); for ( int i = 1 ; i <= m ; ++ i ) { rd ( e [ i ]. u , e [ i ]. v , e [ i ]. w ); } Kruskal (); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); // while (_T--) run(); for ( int kase = 1 ; kase <= _T ; ++ kase ) { cout << \"Case #\" << kase << \": \" ; run (); } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day2/#problem-e-matrix-multiplication-calculator","text":"Solved By Dup4. 00:27(+)","title":"Problem E. MATRIX MULTIPLICATION CALCULATOR"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u9898\u610f_4","text":"\u7ed9\u51fa\u4e24\u4e2a\u77e9\u9635\uff0c\u5982\u679c\u80fd\u591f\u76f8\u4e58\uff0c\u5c31\u6309\u683c\u5f0f\u8f93\u51fa\u76f8\u4e58\u7ed3\u679c\uff0c\u5426\u5219\u8f93\u51fa undefined \u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u601d\u8def_4","text":"\u7b7e\u5230\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int m , n , p , q ; struct node { ll a [ 30 ][ 30 ]; node () {} } A , B , res ; void run () { for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { rd ( A . a [ i ][ j ]); } } for ( int i = 1 ; i <= p ; ++ i ) { for ( int j = 1 ; j <= q ; ++ j ) { rd ( B . a [ i ][ j ]); } } if ( n != p ) { cout << \"undefined \\n \" ; } else { for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= q ; ++ j ) { res . a [ i ][ j ] = 0 ; for ( int k = 1 ; k <= n ; ++ k ) { res . a [ i ][ j ] += A . a [ i ][ k ] * B . a [ k ][ j ]; } } } for ( int i = 1 ; i <= m ; ++ i ) { cout << \"|\" ; for ( int j = 1 ; j <= q ; ++ j ) { cout << \" \" << res . a [ i ][ j ]; } cout << \" | \\n \" ; } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( cin >> m >> n >> p >> q ) { if ( m == 0 && n == 0 && p == 0 && q == 0 ) break ; cout << \"Case #\" << _T << \": \\n \" ; ++ _T ; run (); } return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day2/#problem-f-sum-of-sub-rectangle-areas","text":"Solved By Dup4 & lts. 02:06(+)","title":"Problem F. SUM OF SUB RECTANGLE AREAS"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u9898\u610f_5","text":"\u7ed9\u51fa n n \uff0c\u6c42\u4e0b\u9762\u4ee3\u7801\u8f93\u51fa\u7684\u7ed3\u679c\u3002 sum = 0 for r1 = 0 to N-1 for c1 = 0 to N-1 for r2 = r1+1 to N for c2 = r2+1 to N sum = sum + (r2-r1)*(c2-c1) print(sum)","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u601d\u8def_5","text":"\u961f\u53cb\u53d1\u73b0\u6837\u4f8b\u4e2d\u7684\u7b54\u6848\u90fd\u662f\u5e73\u65b9\u6570\uff0c\u7136\u540e\u6253\u4e86\u4e2a\u8868\u627e\u4e86\u627e\u89c4\u5f8b\u3002\u4f5c\u4e8c\u7ea7\u5dee\u5206\u540e\uff0c\u53d1\u73b0\u5e73\u65b9\u6839\u5b58\u5728\u5982\u4e0b\u89c4\u5f8b\uff1a 1 4 10 20 35 56 84 120 165 3 6 10 15 21 28 36 45 3 4 5 6 7 8 9 \u8fd9\u4e2a\u4e1c\u897f\u76f4\u63a5\u7528\u77e9\u9635\u5feb\u901f\u5e42\u9012\u63a8\u5c31\u53ef\u4ee5\u4e86\u3002 \u4f46\u662f\u961f\u53cb\u53d1\u73b0\u8fd9\u4e2a\u5e73\u65b9\u7684\u7b54\u6848\u5728\u6768\u8f89\u4e09\u89d2\u4e2d\u90fd\u51fa\u73b0\u4e86\uff1a \u90a3\u4e48\u8fd9\u662f\u4e0d\u662f\u610f\u5473\u7740\uff0c\u6ee1\u8db3\u67d0\u79cd\u89c4\u5f8b\u7684\u7ec4\u5408\u6570\u80fd\u591f\u7528\u77e9\u9635\u5feb\u901f\u5e42\u5feb\u901f\u6c42\u51fa\u6765\u3002 Code def mul ( a , b ): res = [ [ 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 ] ] for i in range ( 0 , 4 ): for j in range ( 0 , 4 ): # res[i][j] = 0 for k in range ( 0 , 4 ): res [ i ][ j ] += a [ i ][ k ] * b [ k ][ j ] #print(res[i][j]) return res def gao ( base , res , n ): while n > 0 : if ( n & 1 ) == 1 : res = mul ( res , base ) base = mul ( base , base ) n >>= 1 return res T = int ( input ()) for i in range ( T ): n = int ( input ()) base = [ [ 1 , 0 , 0 , 0 ], [ 1 , 1 , 0 , 0 ], [ 0 , 1 , 1 , 0 ], [ 0 , 0 , 1 , 1 ] ] res = [ [ 1 , 3 , 3 , 1 ], [ 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 ] ] # res = mul(res, base) # res = mul(res, base) # for i in range (4): # print(res[0][i], end=\" \") #print(\"\") # res = mul(res, base); res = gao ( base , res , n - 1 ) print ( res [ 0 ][ 0 ] ** 2 )","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day2/#problem-g-wak-sani-satay","text":"Solved By groggy_. 03:05(+)","title":"Problem G. WAK SANI SATAY"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u9898\u610f_6","text":"\u7ed9\u51fa\u4e09\u79cd\u7c7b\u578b\u539f\u6750\u6599\u6bcf\u4efd\u7684\u552e\u4ef7\u3001\u52a0\u5de5\u8d39\u4ee5\u53ca\u6bcf\u516c\u65a4\u539f\u6750\u6599\u6210\u672c\u3002 \u7ed9\u51fa\u914d\u6599\u7684\u552e\u4ef7\u548c\u6210\u672c\u3002 \u6c42\u4e00\u5468\u5185\u7684\u51c0\u5229\u6da6\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u601d\u8def_6","text":"\u6309\u9898\u610f\u8ba1\u7b97\u5373\u53ef\u3002 Code #include <iostream> typedef long long ll ; using namespace std ; double solve ( ll chicken , ll beef , ll lamb , ll nasi ) { double net_profit = 0 ; net_profit += chicken * 0.8 ; net_profit += beef * 1 ; net_profit += lamb * 1.2 ; net_profit += nasi * 0.8 ; double gross_profit = 0 ; gross_profit += 15.5 * chicken ; gross_profit += 32 * beef ; gross_profit += 40 * lamb ; gross_profit /= 85 ; gross_profit += 0.2 * nasi ; return net_profit - gross_profit ; } int main () { int n ; int Case = 0 ; while ( cin >> n ) { if ( ! n ) break ; ll chicken = 0 , beef = 0 , lamb = 0 , nasi = 0 ; ll a , b , c , d ; double result = 0 ; while ( n -- ) { cin >> a >> b >> c >> d ; chicken += a ; beef += b ; lamb += c ; nasi += d ; result += solve ( a , b , c , d ); } printf ( \"Case #%d: RM%.2lf \\n \" , ++ Case , result ); } }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day2/#problem-h-stroop-effect","text":"Solved By groggy_. 04:23(+1)","title":"Problem H. STROOP EFFECT"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u9898\u610f_7","text":"\u7ed9\u51fa\u4e00\u4e32\u5b57\u7b26\u4e32\u8981\u6c42\u5224\u65ad\u662f\u5426\u4e3a Stroop \u5b57\u7b26\u4e32\u7531\u591a\u4e2a\u4e24\u4f4d\u6570\u7ec4\u6210\uff0c\u4e24\u4f4d\u6570\u7684\u5341\u4f4d\u548c\u4e2a\u4f4d\u76f8\u540c\u4ee3\u8868\u4e00\u81f4\uff0c\u5426\u5219\u4ee3\u8868\u4e0d\u4e00\u81f4\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u601d\u8def_7","text":"\u7531\u4e24\u4f4d\u6570\u5f62\u6210\u56fe\u4e2d\u8868\u683c \u7b26\u5408\u8981\u6c42\u4e3a\uff1a 1\u3001\u8868\u683c\u4e2d\u4e00\u81f4\u548c\u4e0d\u4e00\u81f4\u6570\u91cf\u76f8\u540c 2\u3001\u8868\u683c\u6bcf\u884c\u4e00\u81f4\u548c\u4e0d\u4e00\u81f4\u6570\u91cf\u76f8\u540c 3\u3001\u8868\u683c\u6bcf\u5217\u4e00\u81f4\u548c\u4e0d\u4e00\u81f4\u6570\u91cf\u76f8\u540c 4\u3001\u5b57\u7b26\u4e32\u4e2d\u6570\u5b57\u7684\u5341\u4f4d\u548c\u4e2a\u4f4d\u6570\u4e0d\u80fd\u51fa\u73b0\u8fde\u7eed 3 \u4e2a\u53ca\u4ee5\u4e0a\u76f8\u540c \u6309\u8981\u6c42\u5224\u5b9a Code #include <cstring> #include <iostream> #include <vector> using namespace std ; int num [ 5 ][ 5 ]; bool jug () { int sum = 0 ; int sum1 = 0 ; for ( int i = 1 ; i <= 4 ; i ++ ) { for ( int j = 1 ; j <= 4 ; j ++ ) { sum += num [ i ][ j ]; if ( i == j ) sum1 += num [ i ][ j ]; } } if ( sum1 != sum - sum1 ) return 1 ; for ( int i = 1 ; i <= 4 ; i ++ ) { int total = 0 ; for ( int j = 1 ; j <= 4 ; j ++ ) { if ( i == j ) continue ; total += num [ i ][ j ]; } if ( total != num [ i ][ i ]) return 1 ; } for ( int j = 1 ; j <= 4 ; j ++ ) { int total = 0 ; for ( int i = 1 ; i <= 4 ; i ++ ) { if ( i == j ) continue ; total += num [ i ][ j ]; } if ( total != num [ j ][ j ]) return 1 ; } return 0 ; } int main () { int n ; cin >> n ; for ( int Case = 1 ; Case <= n ; Case ++ ) { memset ( num , 0 , sizeof num ); int flag = 0 ; int a ; vector < int > v1 , v2 ; while ( cin >> a ) { int t1 = a / 10 ; int t2 = a % 10 ; if ( t1 == 0 && t2 == 0 ) break ; num [ t1 ][ t2 ] ++ ; v1 . push_back ( t1 ); v2 . push_back ( t2 ); } for ( int i = 0 ; i < v1 . size (); i ++ ) { if ( i >= 2 && v1 [ i ] == v1 [ i - 1 ] && v1 [ i ] == v1 [ i - 2 ]) flag = 1 ; } for ( int i = 0 ; i < v2 . size (); i ++ ) { if ( i >= 2 && v2 [ i ] == v2 [ i - 1 ] && v2 [ i ] == v2 [ i - 2 ]) flag = 1 ; } if ( jug ()) flag = 1 ; if ( flag ) printf ( \"Case #%d: Not Stroop \\n \" , Case ); else printf ( \"Case #%d: Stroop \\n \" , Case ); } }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day2/#problem-i-super-ball","text":"Upsolved By Dup4.","title":"Problem I. SUPER BALL"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u9898\u610f_8","text":"\u6709 n n \u4e2a\u5de5\u5382\uff0c m m \u79cd\u7403\uff0c\u7ed9\u51fa\u4efb\u610f\u4e24\u4e2a\u5de5\u5382\u4e4b\u95f4\u7684\u8fd0\u8f93\u65f6\u95f4\uff0c\u7ed9\u51fa\u6bcf\u4e2a\u5de5\u5382\u5bf9\u4e8e\u6bcf\u79cd\u7403\u751f\u4ea7\u548c\u56de\u6536\u5206\u522b\u6240\u9700\u7684\u82b1\u8d39\uff0c\u5982\u679c\u662f -1 -1 \u8868\u793a\u8be5\u5de5\u5382\u4e0d\u80fd\u751f\u4ea7\u6216\u56de\u6536\u8be5\u7403\u3002 \u73b0\u5728\u6709\u4e00\u4e2a\u5de5\u827a\u54c1\uff0c\u9700\u8981\u5236\u9020 q q \u4e2a\u7403\uff0c\u5e76\u4e14\u9700\u8981\u6309\u987a\u5e8f\u5355\u7ebf\u7a0b\u5236\u9020\uff0c\u5236\u9020\u5b8c\u4e86\u8fd8\u9700\u8981\u56de\u6536\u3002 \u4f46\u662f\u5236\u9020\u6700\u540e\u4e00\u4e2a\u7403\u548c\u56de\u6536\u6700\u540e\u4e00\u4e2a\u7403\u7684\u65f6\u5019\u6240\u5728\u7684\u5de5\u5382\u4e0d\u9700\u8981\u76f8\u540c\uff0c\u5e76\u4e14\u8fd9\u4e2d\u95f4\u4e5f\u4e0d\u9700\u8981\u8f6c\u79fb\u8d39\u7528\u3002 \u95ee\u751f\u4ea7\u548c\u56de\u6536\u8fc7\u7a0b\u6700\u5c11\u9700\u8981\u591a\u5c11\u8d39\u7528\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u601d\u8def_8","text":"\u4e24\u4e2a\u6d41\u7a0b\u57fa\u672c\u4e00\u81f4\uff0c\u53ea\u662f\u987a\u5e8f\u4e0d\u4e00\u6837\uff0c\u90a3\u4e48\u505a\u4e24\u904d DP \u5373\u53ef\u3002\u8003\u8651 f_{i, j} f_{i, j} \u8868\u793a\u76ee\u524d\u751f\u4ea7/\u56de\u6536\u5230\u7b2c i i \u4e2a\u7403\uff0c\u5f53\u524d\u5904\u4e8e\u7684\u5de5\u5382\u4e3a j j \u65f6\u7684\u6700\u5c0f\u8d39\u7528\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 5e2 + 10 ; constexpr ll INF = 0x3f3f3f3f3f3f3f3f ; int n , m ; ll D [ N ][ N ], R [ N ][ N ], G [ N ], g [ N ][ N ], f [ N ][ N ], h [ N ][ N ]; void run () { rd ( n , m ); for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { rd ( g [ i ][ j ]); } for ( int j = 1 ; j <= m ; ++ j ) { rd ( R [ i ][ j ]); } for ( int j = 1 ; j <= m ; ++ j ) { rd ( D [ i ][ j ]); } } rd ( * G ); for ( int i = 1 ; i <= * G ; ++ i ) rd ( G [ i ]); for ( int k = 1 ; k <= n ; ++ k ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { g [ i ][ j ] = min ( g [ i ][ j ], g [ i ][ k ] + g [ k ][ j ]); } } } // reverse(G + 1, G + 1 + *G); memset ( h , 0x3f , sizeof h ); memset ( h [ 0 ], 0 , sizeof h [ 0 ]); memset ( f , 0x3f , sizeof f ); memset ( f [ 0 ], 0 , sizeof f [ 0 ]); for ( int i = 0 ; i < * G ; ++ i ) { int x = G [ i + 1 ]; for ( int j = 1 ; j <= n ; ++ j ) if ( f [ i ][ j ] < INF ) { for ( int k = 1 ; k <= n ; ++ k ) { if ( R [ k ][ x ] != -1 ) { if ( ! i ) { f [ 1 ][ k ] = R [ k ][ x ]; continue ; } chmin ( f [ i + 1 ][ k ], f [ i ][ j ] + R [ k ][ x ] + g [ j ][ k ]); } } } } reverse ( G + 1 , G + 1 + * G ); for ( int i = 0 ; i < * G ; ++ i ) { int x = G [ i + 1 ]; for ( int j = 1 ; j <= n ; ++ j ) if ( h [ i ][ j ] < INF ) { for ( int k = 1 ; k <= n ; ++ k ) { if ( D [ k ][ x ] != -1 ) { if ( ! i ) { h [ 1 ][ k ] = D [ k ][ x ]; continue ; } chmin ( h [ i + 1 ][ k ], h [ i ][ j ] + D [ k ][ x ] + g [ j ][ k ]); } } } } ll res = INF ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { chmin ( res , f [ * G ][ i ] + h [ * G ][ j ]); // + g[i][j]); } } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day2/#problem-j-virus-outbreak","text":"Solved By Dup4. 00:36(+)","title":"Problem J. VIRUS OUTBREAK"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u9898\u610f_9","text":"\u6c42\u51fa\u51e0\u4e2a\u6570\uff0c\u8ba9\u627e\u89c4\u5f8b\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day2/#\u601d\u8def_9","text":"\u6590\u6ce2\u90a3\u5951\u3002 Code a = [ 0 ] * 500 a [ 1 ] = 1 a [ 2 ] = 1 for i in range ( 3 , 500 ): a [ i ] = a [ i - 1 ] + a [ i - 2 ] while True : n = int ( input ()) if n == - 1 : break print ( \"Hour: %d : %d cow(s) affected\" % ( n , a [ n ]))","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day3/","text":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day3 Contents Contest Info Solutions Problem A. Leftbest \u9898\u610f \u601d\u8def Problem B. First Date \u9898\u610f \u601d\u8def Problem C. Sequence \u9898\u610f \u601d\u8def Problem D. Capture Stars \u9898\u610f \u601d\u8def Problem E. Triangulation \u9898\u610f \u601d\u8def Problem F. Points \u9898\u610f \u601d\u8def Problem G. ParallelNetworkAnalysis \u9898\u610f \u601d\u8def Problem H. Graph \u9898\u610f \u601d\u8def Problem I. Rooted Tree \u9898\u610f \u601d\u8def Problem J. Flowers \u9898\u610f \u601d\u8def Contest Info Practice Link Solved A B C D E F G H I J 5/10 O O - - - O - - \u00d8 O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions Problem A. Leftbest Solved By Dup4. 00:13(+) \u9898\u610f \u7ed9\u51fa n n \u4e2a\u6570\uff0c\u5bf9\u4e8e\u7b2c i i \u4e2a\u6570\uff0c\u8981\u6c42\u51fa\u5728\u5b83\u4e4b\u524d\u7684\u6bd4\u5b83\u5927\u7684\uff0c\u5e76\u4e14\u6700\u5c0f\u7684\u6570\uff0c\u5982\u679c\u4e0d\u5b58\u5728\u5c31\u4e3a 0 0 \uff0c\u7136\u540e\u5c06\u6240\u6709\u6570\u6c42\u548c\u3002 \u601d\u8def \u7ef4\u62a4\u4e00\u4e2a set \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , a [ N ]; void run () { rd ( n ); set < int > se ; ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { rd ( a [ i ]); auto pos = se . upper_bound ( a [ i ]); if ( pos != se . end ()) { res += * pos ; } se . insert ( a [ i ]); } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem B. First Date Solved By all. 03:15(+) \u9898\u610f \u7ed9\u51fa n n \u4e2a\u70b9\uff0c m m \u6761\u8fb9\u7684\u65e0\u5411\u56fe\uff0c\u6bcf\u6761\u8fb9\u6743\u4e3a x_i + a \\cdot y_i x_i + a \\cdot y_i \uff0c\u5176\u4e2d a \\in [0, 1] a \\in [0, 1] \u4e3a\u4e00\u4e2a\u968f\u673a\u56e0\u5b50\uff0c\u73b0\u5728\u6c42 S \\rightarrow T S \\rightarrow T \u7684\u6700\u77ed\u8def\u7684\u671f\u671b\u3002 \u601d\u8def \u56e0\u4e3a\u7cbe\u5ea6\u8981\u6c42\u5f88\u4f4e\uff0c\u76f4\u63a5\u7ed9\u968f\u673a\u56e0\u5b50\u6bcf\u6b21\u589e\u91cf 0.0001 0.0001 \u6a21\u62df\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; constexpr db INF = 0x3f3f3f3f ; int n , m , S , T ; db a ; const db eps = 1e-4 ; int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; return x < 0 ? -1 : 1 ; } struct E { int v , x , y ; E () {} E ( int v , int x , int y ) : v ( v ), x ( x ), y ( y ) {} }; vector < vector < E >> G ; struct Dijkstra { struct node { int u ; db w ; node ( int u = 0 , db w = 0 ) : u ( u ), w ( w ) {} bool operator < ( const node & other ) const { return sgn ( w - other . w ) > 0 ; } }; db dis [ N ]; bool used [ N ]; db gao ( int s ) { for ( int i = 1 ; i <= n ; ++ i ) { dis [ i ] = INF ; used [ i ] = 0 ; } priority_queue < node > pq ; dis [ s ] = 0 ; pq . push ( node ( s , dis [ s ])); while ( ! pq . empty ()) { int u = pq . top (). u ; pq . pop (); if ( used [ u ]) continue ; if ( u == T ) return dis [ T ]; used [ u ] = 1 ; for ( auto & it : G [ u ]) { int v = it . v , x = it . x , y = it . y ; db w = x + a * y ; if ( sgn ( dis [ v ] - dis [ u ] - w ) > 0 ) { dis [ v ] = dis [ u ] + w ; pq . push ( node ( v , dis [ v ])); } } } } } dij ; void run () { rd ( n , m , S , T ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v , x , y ; i <= m ; ++ i ) { rd ( u , v , x , y ); G [ u ]. push_back ( E ( v , x , y )); G [ v ]. push_back ( E ( u , x , y )); } db res = 0 ; for ( int i = 1 ; i <= 10000 ; ++ i ) { a = i * 0.0001 ; res += dij . gao ( S ) * 0.0001 ; } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem C. Sequence Upsolved By -. \u9898\u610f \u601d\u8def Problem D. Capture Stars Upsolved By -. \u9898\u610f \u601d\u8def Problem E. Triangulation Upsolved By -. \u9898\u610f \u601d\u8def Problem F. Points Solved By Dup4. 00:06(+) \u9898\u610f \u7ed9\u51fa\u4e00\u68f5\u6811\uff0c\u6c42\u5ea6\u6570\u4e3a 1 1 \u7684\u70b9\u7684\u4e2a\u6570\u3002 \u601d\u8def \u76f4\u63a5\u6c42\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , d [ N ]; void run () { rd ( n ); for ( int i = 1 , u , v ; i < n ; ++ i ) { rd ( u , v ); ++ d [ u ], ++ d [ v ]; } int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) res += d [ i ] == 1 ; pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem G. ParallelNetworkAnalysis Upsolved By -. \u9898\u610f \u601d\u8def Problem H. Graph Upsolved By -. \u9898\u610f \u601d\u8def Problem I. Rooted Tree Upsolved By Dup4. \u9898\u610f \u7ed9\u51fa n n \u4e2a\u70b9\uff0c\u73b0\u5728\u8981\u6784\u9020\u4e00\u68f5\u6811\uff0c\u4e0d\u8d85\u8fc7\u4e09\u5c42\uff0c\u5e76\u4e14\u4e0d\u540c\u6784\u7684\u65b9\u6848\u6570\u3002 \u601d\u8def \u7b2c\u4e00\u5c42\u663e\u7136\u53ea\u6709\u4e00\u4e2a\u70b9\uff0c\u90a3\u4e48\u5269\u4e0b n - 1 n - 1 \u4e2a\u70b9\u653e\u5728\u4e8c\u3001\u4e09\u5c42\u7684\u65b9\u6848\uff0c\u5176\u5b9e\u5c31\u662f n - 1 n - 1 \u7684\u6574\u6570\u5212\u5206\u65b9\u6848\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 998244353 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 5e5 + 10 ; constexpr int M = 1300 ; int n , f [ M ], g [ N ]; void gao () { f [ 1 ] = 1 , f [ 2 ] = 2 , f [ 3 ] = 5 , f [ 4 ] = 7 ; for ( int i = 5 ; i < M ; ++ i ) f [ i ] = 3 + 2 * f [ i - 2 ] - f [ i - 4 ]; g [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { ll sum [ 4 ] = { 0 }, now = 0 ; int j = 1 ; for (; f [ j + 3 ] <= i ; j += 4 ) { sum [ 0 ] += g [ i - f [ j ]]; sum [ 1 ] += g [ i - f [ j + 1 ]]; sum [ 2 ] -= g [ i - f [ j + 2 ]]; sum [ 3 ] -= g [ i - f [ j + 3 ]]; } now = ( sum [ 0 ] + sum [ 1 ] + sum [ 2 ] + sum [ 3 ]) % mod ; for (; f [ j ] <= i ; ++ j ) { if (( j + 1 ) >> 1 & 1 ) { now += g [ i - f [ j ]]; } else { now -= g [ i - f [ j ]]; } } now = ( now + mod ) % mod ; g [ i ] = now ; } } void run () { rd ( n ); gao (); pt ( g [ n - 1 ]); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem J. Flowers Solved By Dup4 & groggy_. 01:24(+6) \u9898\u610f \u7ed9\u51fa n n \u79cd\u82b1\uff0c\u6bcf\u79cd\u82b1\u6709 a_i a_i \u6735\uff0c\u8981\u6784\u6210\u4e00\u675f\u82b1\uff0c\u9700\u8981 m m \u79cd\u4e0d\u540c\u7684\u82b1\uff0c\u95ee\u6700\u591a\u80fd\u591f\u6784\u6210\u591a\u5c11\u675f\u82b1\uff1f \u601d\u8def \u4e8c\u5206\u7b54\u6848 x x \uff0c\u90a3\u4e48\u6bcf\u79cd\u82b1\u6700\u591a\u4f7f\u7528 x x \u6735\uff0c\u5e76\u4e14\u7f8e\u591a\u90fd\u80fd\u7528\u4e0a\u4e0d\u4f1a\u8fdd\u53cd\u89c4\u5219\u3002\u5047\u8bbe\u8fd9\u65f6\u6240\u6709\u53ef\u7528\u7684\u82b1\u6735\u6709 sum sum \u6735\uff0c\u90a3\u4e48\u53ea\u8981\u6709 \\displaystyle \\lfloor \\frac{sum}{m} \\rfloor \\geq x \\displaystyle \\lfloor \\frac{sum}{m} \\rfloor \\geq x \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; using pIL = pair < int , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 3e5 + 10 ; int n , m , a [ N ]; ll f [ N ]; bool ok ( ll x ) { // f[m] = x; // int pos = m; ll sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += min ( 1l l * a [ i ], x ); } return sum / m >= x ; // for (int i = 1; i <= n; ++i) { // ll t = a[i]; // vector <pIL> vec; // ll sum = 0; // while (pos && t && sum < x) { // if (t < f[pos]) { // f[pos] -= t; // vec.push_back(pIL(pos - 1, t)); // sum += t; // t = 0; // } else { // t -= f[pos]; // vec.push_back(pIL(pos - 1, f[pos])); // sum += f[pos]; // f[pos] = 0; // --pos; // } // } // for (auto &it : vec) { // f[it.fi] += it.se; // chmax(pos, it.fi); // } // } // for (int i = 0; i <= pos; ++i) f[i] = 0; // return !pos; } void run () { rd ( n , m ); memset ( f , 0 , sizeof f ); ll sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]), sum += a [ i ]; sort ( a + 1 , a + 1 + n ); reverse ( a + 1 , a + 1 + n ); ll l = 0 , r = sum / m , res = l ; while ( r - l >= 0 ) { ll mid = ( l + r ) >> 1 ; if ( ok ( mid )) { res = mid ; l = mid + 1 ; } else { r = mid - 1 ; } } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day3"},{"location":"2020/nowcoder-national-day-training-party/day3/#contest-info","text":"Practice Link Solved A B C D E F G H I J 5/10 O O - - - O - - \u00d8 O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"2020/nowcoder-national-day-training-party/day3/#solutions","text":"","title":"Solutions"},{"location":"2020/nowcoder-national-day-training-party/day3/#problem-a-leftbest","text":"Solved By Dup4. 00:13(+)","title":"Problem A. Leftbest"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u9898\u610f","text":"\u7ed9\u51fa n n \u4e2a\u6570\uff0c\u5bf9\u4e8e\u7b2c i i \u4e2a\u6570\uff0c\u8981\u6c42\u51fa\u5728\u5b83\u4e4b\u524d\u7684\u6bd4\u5b83\u5927\u7684\uff0c\u5e76\u4e14\u6700\u5c0f\u7684\u6570\uff0c\u5982\u679c\u4e0d\u5b58\u5728\u5c31\u4e3a 0 0 \uff0c\u7136\u540e\u5c06\u6240\u6709\u6570\u6c42\u548c\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u601d\u8def","text":"\u7ef4\u62a4\u4e00\u4e2a set \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , a [ N ]; void run () { rd ( n ); set < int > se ; ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { rd ( a [ i ]); auto pos = se . upper_bound ( a [ i ]); if ( pos != se . end ()) { res += * pos ; } se . insert ( a [ i ]); } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day3/#problem-b-first-date","text":"Solved By all. 03:15(+)","title":"Problem B. First Date"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u9898\u610f_1","text":"\u7ed9\u51fa n n \u4e2a\u70b9\uff0c m m \u6761\u8fb9\u7684\u65e0\u5411\u56fe\uff0c\u6bcf\u6761\u8fb9\u6743\u4e3a x_i + a \\cdot y_i x_i + a \\cdot y_i \uff0c\u5176\u4e2d a \\in [0, 1] a \\in [0, 1] \u4e3a\u4e00\u4e2a\u968f\u673a\u56e0\u5b50\uff0c\u73b0\u5728\u6c42 S \\rightarrow T S \\rightarrow T \u7684\u6700\u77ed\u8def\u7684\u671f\u671b\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u601d\u8def_1","text":"\u56e0\u4e3a\u7cbe\u5ea6\u8981\u6c42\u5f88\u4f4e\uff0c\u76f4\u63a5\u7ed9\u968f\u673a\u56e0\u5b50\u6bcf\u6b21\u589e\u91cf 0.0001 0.0001 \u6a21\u62df\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; constexpr db INF = 0x3f3f3f3f ; int n , m , S , T ; db a ; const db eps = 1e-4 ; int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; return x < 0 ? -1 : 1 ; } struct E { int v , x , y ; E () {} E ( int v , int x , int y ) : v ( v ), x ( x ), y ( y ) {} }; vector < vector < E >> G ; struct Dijkstra { struct node { int u ; db w ; node ( int u = 0 , db w = 0 ) : u ( u ), w ( w ) {} bool operator < ( const node & other ) const { return sgn ( w - other . w ) > 0 ; } }; db dis [ N ]; bool used [ N ]; db gao ( int s ) { for ( int i = 1 ; i <= n ; ++ i ) { dis [ i ] = INF ; used [ i ] = 0 ; } priority_queue < node > pq ; dis [ s ] = 0 ; pq . push ( node ( s , dis [ s ])); while ( ! pq . empty ()) { int u = pq . top (). u ; pq . pop (); if ( used [ u ]) continue ; if ( u == T ) return dis [ T ]; used [ u ] = 1 ; for ( auto & it : G [ u ]) { int v = it . v , x = it . x , y = it . y ; db w = x + a * y ; if ( sgn ( dis [ v ] - dis [ u ] - w ) > 0 ) { dis [ v ] = dis [ u ] + w ; pq . push ( node ( v , dis [ v ])); } } } } } dij ; void run () { rd ( n , m , S , T ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v , x , y ; i <= m ; ++ i ) { rd ( u , v , x , y ); G [ u ]. push_back ( E ( v , x , y )); G [ v ]. push_back ( E ( u , x , y )); } db res = 0 ; for ( int i = 1 ; i <= 10000 ; ++ i ) { a = i * 0.0001 ; res += dij . gao ( S ) * 0.0001 ; } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day3/#problem-c-sequence","text":"Upsolved By -.","title":"Problem C. Sequence"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u9898\u610f_2","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u601d\u8def_2","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day3/#problem-d-capture-stars","text":"Upsolved By -.","title":"Problem D. Capture Stars"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u9898\u610f_3","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u601d\u8def_3","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day3/#problem-e-triangulation","text":"Upsolved By -.","title":"Problem E. Triangulation"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u9898\u610f_4","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u601d\u8def_4","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day3/#problem-f-points","text":"Solved By Dup4. 00:06(+)","title":"Problem F. Points"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u9898\u610f_5","text":"\u7ed9\u51fa\u4e00\u68f5\u6811\uff0c\u6c42\u5ea6\u6570\u4e3a 1 1 \u7684\u70b9\u7684\u4e2a\u6570\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u601d\u8def_5","text":"\u76f4\u63a5\u6c42\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , d [ N ]; void run () { rd ( n ); for ( int i = 1 , u , v ; i < n ; ++ i ) { rd ( u , v ); ++ d [ u ], ++ d [ v ]; } int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) res += d [ i ] == 1 ; pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day3/#problem-g-parallelnetworkanalysis","text":"Upsolved By -.","title":"Problem G. ParallelNetworkAnalysis"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u9898\u610f_6","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u601d\u8def_6","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day3/#problem-h-graph","text":"Upsolved By -.","title":"Problem H. Graph"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u9898\u610f_7","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u601d\u8def_7","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day3/#problem-i-rooted-tree","text":"Upsolved By Dup4.","title":"Problem I. Rooted Tree"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u9898\u610f_8","text":"\u7ed9\u51fa n n \u4e2a\u70b9\uff0c\u73b0\u5728\u8981\u6784\u9020\u4e00\u68f5\u6811\uff0c\u4e0d\u8d85\u8fc7\u4e09\u5c42\uff0c\u5e76\u4e14\u4e0d\u540c\u6784\u7684\u65b9\u6848\u6570\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u601d\u8def_8","text":"\u7b2c\u4e00\u5c42\u663e\u7136\u53ea\u6709\u4e00\u4e2a\u70b9\uff0c\u90a3\u4e48\u5269\u4e0b n - 1 n - 1 \u4e2a\u70b9\u653e\u5728\u4e8c\u3001\u4e09\u5c42\u7684\u65b9\u6848\uff0c\u5176\u5b9e\u5c31\u662f n - 1 n - 1 \u7684\u6574\u6570\u5212\u5206\u65b9\u6848\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 998244353 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 5e5 + 10 ; constexpr int M = 1300 ; int n , f [ M ], g [ N ]; void gao () { f [ 1 ] = 1 , f [ 2 ] = 2 , f [ 3 ] = 5 , f [ 4 ] = 7 ; for ( int i = 5 ; i < M ; ++ i ) f [ i ] = 3 + 2 * f [ i - 2 ] - f [ i - 4 ]; g [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { ll sum [ 4 ] = { 0 }, now = 0 ; int j = 1 ; for (; f [ j + 3 ] <= i ; j += 4 ) { sum [ 0 ] += g [ i - f [ j ]]; sum [ 1 ] += g [ i - f [ j + 1 ]]; sum [ 2 ] -= g [ i - f [ j + 2 ]]; sum [ 3 ] -= g [ i - f [ j + 3 ]]; } now = ( sum [ 0 ] + sum [ 1 ] + sum [ 2 ] + sum [ 3 ]) % mod ; for (; f [ j ] <= i ; ++ j ) { if (( j + 1 ) >> 1 & 1 ) { now += g [ i - f [ j ]]; } else { now -= g [ i - f [ j ]]; } } now = ( now + mod ) % mod ; g [ i ] = now ; } } void run () { rd ( n ); gao (); pt ( g [ n - 1 ]); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day3/#problem-j-flowers","text":"Solved By Dup4 & groggy_. 01:24(+6)","title":"Problem J. Flowers"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u9898\u610f_9","text":"\u7ed9\u51fa n n \u79cd\u82b1\uff0c\u6bcf\u79cd\u82b1\u6709 a_i a_i \u6735\uff0c\u8981\u6784\u6210\u4e00\u675f\u82b1\uff0c\u9700\u8981 m m \u79cd\u4e0d\u540c\u7684\u82b1\uff0c\u95ee\u6700\u591a\u80fd\u591f\u6784\u6210\u591a\u5c11\u675f\u82b1\uff1f","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day3/#\u601d\u8def_9","text":"\u4e8c\u5206\u7b54\u6848 x x \uff0c\u90a3\u4e48\u6bcf\u79cd\u82b1\u6700\u591a\u4f7f\u7528 x x \u6735\uff0c\u5e76\u4e14\u7f8e\u591a\u90fd\u80fd\u7528\u4e0a\u4e0d\u4f1a\u8fdd\u53cd\u89c4\u5219\u3002\u5047\u8bbe\u8fd9\u65f6\u6240\u6709\u53ef\u7528\u7684\u82b1\u6735\u6709 sum sum \u6735\uff0c\u90a3\u4e48\u53ea\u8981\u6709 \\displaystyle \\lfloor \\frac{sum}{m} \\rfloor \\geq x \\displaystyle \\lfloor \\frac{sum}{m} \\rfloor \\geq x \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; using pIL = pair < int , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 3e5 + 10 ; int n , m , a [ N ]; ll f [ N ]; bool ok ( ll x ) { // f[m] = x; // int pos = m; ll sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += min ( 1l l * a [ i ], x ); } return sum / m >= x ; // for (int i = 1; i <= n; ++i) { // ll t = a[i]; // vector <pIL> vec; // ll sum = 0; // while (pos && t && sum < x) { // if (t < f[pos]) { // f[pos] -= t; // vec.push_back(pIL(pos - 1, t)); // sum += t; // t = 0; // } else { // t -= f[pos]; // vec.push_back(pIL(pos - 1, f[pos])); // sum += f[pos]; // f[pos] = 0; // --pos; // } // } // for (auto &it : vec) { // f[it.fi] += it.se; // chmax(pos, it.fi); // } // } // for (int i = 0; i <= pos; ++i) f[i] = 0; // return !pos; } void run () { rd ( n , m ); memset ( f , 0 , sizeof f ); ll sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]), sum += a [ i ]; sort ( a + 1 , a + 1 + n ); reverse ( a + 1 , a + 1 + n ); ll l = 0 , r = sum / m , res = l ; while ( r - l >= 0 ) { ll mid = ( l + r ) >> 1 ; if ( ok ( mid )) { res = mid ; l = mid + 1 ; } else { r = mid - 1 ; } } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day4/","text":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day4 Contents Contest Info Solutions Problem A. Digits Are Not Just Characters \u9898\u610f \u601d\u8def Problem B. Arithmetic Progressions \u9898\u610f \u601d\u8def Problem C. Emergency Evacuation \u9898\u610f \u601d\u8def Problem D. Shortest Common Non-Subsequence \u9898\u610f \u601d\u8def Problem E. Fair Chocolate-Cutting \u9898\u610f \u601d\u8def Problem F. What Goes Up Must Come Down \u9898\u610f \u601d\u8def Problem G. Ranks \u9898\u610f \u601d\u8def Problem H. Colorful Tree \u9898\u610f \u601d\u8def Problem I. Sixth Sense \u9898\u610f \u601d\u8def Problem J. Jokewithpermutation \u9898\u610f \u601d\u8def Contest Info Practice Link Solved A B C D E F G H I J 7/10 O O O \u00d8 - \u00d8 - O - O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions Problem A. Digits Are Not Just Characters Solved By Dup4. 00:38(+) \u9898\u610f \u7ed9\u51fa\u4e24\u4e2a\u5b57\u7b26\u4e32\uff0c\u6309\u7279\u5b9a\u89c4\u5219\u6bd4\u8f83\u5927\u5c0f\u3002 \u89c4\u5219\u5c31\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\uff0c\u5355\u4e2a\u5b57\u7b26\u89c6\u4e3a letter item \uff0c\u8fde\u7eed\u7684\u6570\u5b57\u89c6\u4e3a digit item \u3002 digit item \u6392\u5728 letter item \u524d\u9762\u3002 letter item \u4e4b\u95f4\u6309\u7167\u5b57\u5178\u5e8f\u6392\u5e8f\u3002 digit item \u6309\u7167\u5b9e\u9645\u7684\u503c\u6392\u5e8f\u3002 \u601d\u8def \u66b4\u529b\u6a21\u62df\u5373\u53ef\u3002 \u4f46\u662f\u6211\u7684\u4ee3\u7801\u4e5f\u592a\u957f\u4e86\u3002 \u5b66\u4e60\u4e86\u4e00\u6bb5\u4ee3\u7801\uff0c\u53d1\u73b0\u76f4\u63a5\u5904\u7406\u540e\uff0c\u7528 vector \u53bb\u6bd4\u8f83\u5c31\u884c\u4e86\uff0c\u5bf9\u4e8e\u5b57\u7b26\u7684\u5904\u7406\u8981\u5c06\u5b83\u5904\u7406\u6210\u4e00\u4e2a\u8f83\u5927\u7684\u6570\u5b57\u3002 \u7136\u540e\u53d1\u73b0\u9898\u610f\u4e2d\u5bf9\u4e8e\u300c\u6392\u5e8f\u300d\u7684\u5b9a\u4e49\uff0c\u5176\u5b9e\u5c31\u662f PHP \u4e2d\u7684 strnatcmp \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; vector < string > _get ( string s ) { vector < string > res ; string t = \"\" ; for ( auto & ch : s ) { if ( isdigit ( ch )) t += ch ; else { if ( ! t . empty ()) res . push_back ( t ); t . clear (); string _t = \"\" ; _t += ch ; res . push_back ( _t ); } } if ( ! t . empty ()) res . push_back ( t ); // for (auto &it : res) assert(SZ(it) > 0); return res ; } int toInt ( char ch ) { return ch - '0' ; } char gao ( string s , string t ) { if ( s == t ) return '+' ; vector < string > _s ( _get ( s )), _t ( _get ( t )); // pt(_s, _t); // return '+'; for ( int i = 0 ; i < min ( SZ ( _s ), SZ ( _t )); ++ i ) { string __s = _s [ i ]; string __t = _t [ i ]; // dbg(__s, __t); int d_s = isdigit ( __s [ 0 ]); int d_t = isdigit ( __t [ 0 ]); if ( d_s != d_t ) { if ( d_t ) return '-' ; return '+' ; } if ( __s != __t ) { if ( ! d_s ) { if ( __s < __t ) return '+' ; else return '-' ; } else { if ( SZ ( __s ) != SZ ( __t )) { if ( SZ ( __s ) < SZ ( __t )) return '+' ; else return '-' ; } for ( int j = 0 ; j < SZ ( __s ); ++ j ) { int n_s = toInt ( __s [ j ]); int n_t = toInt ( __t [ j ]); if ( n_s != n_t ) { if ( n_s < n_t ) return '+' ; else return '-' ; } } } } } if ( SZ ( s ) > SZ ( t )) return '-' ; else return '+' ; } void run () { rd ( n ); string s ; rd ( s ); for ( int i = 1 ; i <= n ; ++ i ) { string t ; rd ( t ); // cout << t << endl; pt ( gao ( s , t )); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Code #include <cctype> #include <iostream> #include <string> #include <vector> using namespace std ; const int N = 1010 ; vector < long long > v [ N ]; int main () { int n ; cin >> n ; string s ; for ( int k = 0 ; k <= n ; k ++ ) { cin >> s ; long long x = 0 ; for ( int i = 0 ; i < s . length (); i ++ ) { if ( isdigit ( s [ i ])) { x = x * 10 + ( s [ i ] ^ 0x30 ); } else { if ( x ) v [ k ]. push_back ( x ), x = 0 ; v [ k ]. push_back ( s [ i ] ^ ( 1l l << 32 )); } } if ( x ) v [ k ]. push_back ( x ); } for ( int i = 1 ; i <= n ; i ++ ) { cout << ( v [ i ] < v [ 0 ] ? '-' : '+' ) << endl ; } return 0 ; } Code <?php $n = intval ( fgets ( STDIN )); $s0 = trim ( fgets ( STDIN )); for ( $i = 0 ; $i < $n ; $i ++ ) { $s = trim ( fgets ( STDIN )); if ( strnatcmp ( $s0 , $s ) > 0 ) { $result = '-' ; } else { $result = '+' ; } echo \" $result\\n \" ; } Problem B. Arithmetic Progressions Solved By Dup4. 00:45(+) \u9898\u610f \u7ed9\u51fa n n \u4e2a\u6570 a_i a_i \uff0c\u627e\u4e00\u4e2a\u5b50\u5e8f\u5217\uff0c\u4f7f\u5f97\u8fd9\u4e2a\u5b50\u5e8f\u5217\u6392\u5e8f\u540e\u662f\u4e00\u4e2a\u300c\u7b49\u5dee\u6570\u5217\u300d\u3002 \u601d\u8def \u5148\u6392\u5e8f\u3002 f_{i, j} f_{i, j} \u8868\u793a\u7b49\u5dee\u6570\u5217\u7684\u6700\u540e\u4e00\u9879\u4e3a a_j a_j , \u5012\u6570\u7b2c\u4e8c\u9879\u4e3a a_i a_i \u7684\u6700\u5927\u957f\u5ea6\u662f\u591a\u5c11\u3002 \u56e0\u4e3a\u5012\u6570\u4e24\u4e2a\u6570\u786e\u5b9a\u4e86\uff0c\u5dee\u5c31\u786e\u5b9a\u4e86\uff0c\u7136\u540e\u679a\u4e3e i, j i, j \u627e\u524d\u9a71\u7684\u4e00\u4e2a k k \u8fdb\u884c\u8f6c\u79fb\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 5e3 + 10 ; int n , a [ N ], f [ N ][ N ]; unordered_map < int , int > mp ; void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]); sort ( a + 1 , a + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) mp [ a [ i ]] = i ; int res = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= i ; ++ j ) { if ( i == j ) f [ j ][ i ] = 1 ; else { f [ j ][ i ] = 2 ; int pre = a [ j ] - ( a [ i ] - a [ j ]); if ( mp . count ( pre )) { chmax ( f [ j ][ i ], f [ mp [ pre ]][ j ] + 1 ); } } } } for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) chmax ( res , f [ i ][ j ]); pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem C. Emergency Evacuation Solved By groggy_. 01:40(+) \u9898\u610f \u6709\u4e00\u8f86\u516c\u4ea4\u8f66\uff0c\u6709 n n \u884c\uff0c m m \u5217\uff0c\u5e76\u4e14\u4e24\u8fb9\u662f\u5bf9\u79f0\u7684\u3002 \u6bcf\u4e2a\u4f4d\u7f6e\u4e0a\u7684\u4eba\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\u9700\u8981\u4e00\u4e2a\u5355\u4f4d\u7684\u65f6\u95f4\uff0c\u95ee\u6240\u6709\u4eba\u5230\u8fbe\u51fa\u53e3\u9700\u8981\u591a\u5c11\u65f6\u95f4\uff1f \u601d\u8def \u56e0\u4e3a\u6b63\u7740\u505a\u4f1a\u53d1\u751f\u963b\u585e\uff0c\u6211\u4eec\u5c06\u8fd9\u4e2a\u8fc7\u7a0b\u53cd\u8fc7\u6765\uff0c\u5373\u521a\u5f00\u59cb\u5927\u5bb6\u90fd\u7b49\u5728\u51fa\u53e3\uff0c\u7136\u540e\u9700\u8981\u5230\u8fbe\u81ea\u5df1\u7684\u4f4d\u7f6e\u3002 \u6211\u4eec\u8ba9\u8def\u7a0b\u65f6\u95f4\u6700\u957f\u7684\u5148\u8d70\uff0c\u56e0\u4e3a\u8def\u7a0b\u65f6\u95f4\u957f\u7684\u4e0d\u4f1a\u963b\u585e\u8def\u7a0b\u65f6\u95f4\u77ed\u7684\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; void run () {} int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem D. Shortest Common Non-Subsequence Upsolved By Dup4. \u9898\u610f \u7ed9\u51fa\u4e24\u4e2a 01 \u4e32 s s \u548c t t \uff0c\u73b0\u5728\u8981\u6784\u9020\u4e00\u4e2a\u6700\u77ed\u7684 01 \u4e32\uff0c\u4f7f\u5f97\u8fd9\u4e2a 01 \u4e32\u65e2\u4e0d\u662f s s \u7684\u5b50\u5e8f\u5217\u4e5f\u4e0d\u662f t t \u7684\u5b50\u5e8f\u5217\u3002 \u8981\u6c42\u8f93\u51fa\u957f\u5ea6\u6700\u5c0f\u3001\u5176\u6b21\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u7b54\u6848\u3002 \u601d\u8def \u5047\u8bbe\u7b54\u6848\u4e3a n n \u4f4d\uff0c\u90a3\u4e48\u7b54\u6848\u7684\u524d n - 1 n - 1 \u4f4d\u6784\u6210\u7684 01 \u4e32\u80af\u5b9a\u662f s s \u548c\u5b50\u5e8f\u5217\u6216\u8005\u662f t t \u7684\u5b50\u5e8f\u5217\u3002 \u90a3\u4e48\u6211\u4eec\u5012\u7740 dp \uff0c f_{i, j} f_{i, j} \u8868\u793a s s \u4e32\u7684\u540e i i \u4f4d\uff0c t t \u4e32\u7684\u540e j j \u4f4d\u5931\u914d\u7684\u6700\u77ed\u957f\u5ea6\u3002 \u8981\u6c42\u5b57\u5178\u5e8f\u6700\u5c0f\uff0c\u6211\u4eec\u6b63\u7740\u8d2a\u5fc3\u5373\u53ef\u3002\u4f18\u5148\u653e 0 0 \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 4e3 + 10 ; constexpr int INF = 0x3f3f3f3f ; int n , lens , lent ; char s [ N ], t [ N ]; int h_s [ N ][ 2 ], h_t [ N ][ 2 ]; int g [ N ][ N ]; void gao1 ( char * s , int h [ N ][ 2 ]) { int len = strlen ( s + 1 ); int nx [ 2 ] = { len + 1 , len + 1 }; h [ len + 1 ][ 0 ] = h [ len + 1 ][ 1 ] = len + 1 ; for ( int i = len ; i >= 0 ; -- i ) { h [ i ][ 0 ] = nx [ 0 ]; h [ i ][ 1 ] = nx [ 1 ]; if ( i < 1 ) break ; nx [ s [ i ] - '0' ] = i ; } } void run () { cin >> ( s + 1 ) >> ( t + 1 ); lens = strlen ( s + 1 ); lent = strlen ( t + 1 ); gao1 ( s , h_s ); gao1 ( t , h_t ); memset ( g , 0x3f , sizeof g ); g [ lens + 1 ][ lent + 1 ] = 0 ; for ( int i = lens + 1 ; i >= 0 ; -- i ) { for ( int j = lent + 1 ; j >= 0 ; -- j ) { for ( int k = 0 ; k < 2 ; ++ k ) { chmin ( g [ i ][ j ], g [ h_s [ i ][ k ]][ h_t [ j ][ k ]] + 1 ); } } } string res = \"\" ; int i = 0 , j = 0 ; for ( int o = 1 ; o <= g [ 0 ][ 0 ]; ++ o ) { for ( int x = 0 ; x < 2 ; ++ x ) { int _i = h_s [ i ][ x ]; int _j = h_t [ j ][ x ]; if ( g [ i ][ j ] == g [ _i ][ _j ] + 1 ) { i = _i ; j = _j ; res += x + '0' ; break ; } } } cout << res << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem E. Fair Chocolate-Cutting Upsolved By -. \u9898\u610f \u601d\u8def Problem F. What Goes Up Must Come Down Upsolved By Dup4. \u9898\u610f \u7ed9\u51fa n n \u4e2a\u6570 a_i a_i \uff0c\u73b0\u5728\u6bcf\u6b21\u53ea\u80fd\u4ea4\u6362\u76f8\u90bb\u4e24\u4e2a\u6570\uff0c\u95ee\u5c06\u8fd9\u4e2a\u6570\u5217\u8c03\u6574\u6210\u53ea\u6709\u4e00\u4e2a\u5c71\u5cf0\u7684\u5f62\u72b6\u6700\u5c11\u9700\u8981\u591a\u5c11\u6b21\uff1f \u601d\u8def \u5bf9\u4e8e\u4e00\u4e2a\u6570\u6765\u8bf4\uff0c\u6700\u7ec8\u8981\u4e48\u662f\u5b83\u5de6\u8fb9\u7684\u6570\u5168\u90fd\u5c0f\u4e8e\u7b49\u4e8e\u5b83\uff0c\u8981\u4e48\u662f\u5b83\u53f3\u8fb9\u7684\u6570\u5168\u90fd\u5c0f\u4e8e\u7b49\u4e8e\u5b83\u3002 \u90a3\u4e48\u5c31\u662f\u5b83\u5de6\u8fb9\u6bd4\u5b83\u5927\u7684\u6570\u5168\u90fd\u8981\u8de8\u8fc7\u5b83\u5230\u53f3\u8fb9\uff0c\u6216\u8005\u53f3\u8fb9\u6bd4\u5b83\u5927\u7684\u6570\u5168\u90fd\u8981\u8de8\u8fc7\u5b83\u5230\u5de6\u8fb9\uff0c\u6211\u4eec\u53d6 Min \u5373\u53ef\u3002 Problem G. Ranks Upsolved By -. \u9898\u610f \u601d\u8def Problem H. Colorful Tree Solved By Dup4. 04:57(+10) \u9898\u610f \u7ed9\u51fa\u4e00\u68f5\u6811\uff0c\u6bcf\u4e2a\u70b9\u6709\u4e00\u4e2a\u521d\u59cb\u989c\u8272 c_i c_i \uff0c\u6709\u4e24\u79cd\u64cd\u4f5c\uff1a U x y \uff0c\u5c06\u70b9 u u \u7684\u989c\u8272\u6539\u6210 y y \u3002 Q y , \u8be2\u95ee\u6240\u6709\u989c\u8272\u4e3a y y \u7684\u70b9\u7ec4\u6210\u7684\u865a\u6570\u7684\u5468\u957f\u3002 \u601d\u8def \u7528 set \u7ef4\u62a4\u6bcf\u79cd\u989c\u8272\u865a\u6811\u5468\u957f\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 2e5 + 10 ; int n , q , c [ N ]; ll sum [ N ]; vector < vector < int >> G ; set < int > se [ N ]; int fa [ N ], deep [ N ], dis [ N ], sze [ N ], son [ N ], top [ N ], in [ N ], fin [ N ]; void dfs ( int u ) { sze [ u ] = 1 ; son [ u ] = 0 ; for ( auto & v : G [ u ]) { if ( v == fa [ u ]) continue ; fa [ v ] = u ; deep [ v ] = deep [ u ] + 1 ; dis [ v ] = dis [ u ] + 1 ; dfs ( v ); sze [ u ] += sze [ v ]; if ( ! son [ u ] || sze [ v ] > sze [ son [ u ]]) son [ u ] = v ; } } void gettop ( int u , int tp ) { in [ u ] = ++* in ; fin [ * in ] = u ; top [ u ] = tp ; if ( son [ u ]) gettop ( son [ u ], tp ); for ( auto & v : G [ u ]) { if ( v == fa [ u ] || v == son [ u ]) continue ; gettop ( v , v ); } } int querylca ( int u , int v ) { while ( top [ u ] != top [ v ]) { if ( deep [ top [ u ]] < deep [ top [ v ]]) { swap ( u , v ); } u = fa [ top [ u ]]; } if ( deep [ u ] > deep [ v ]) swap ( u , v ); return u ; } int querydis ( int u , int v ) { return dis [ u ] + dis [ v ] - 2 * dis [ querylca ( u , v )]; } void add ( int col , int x ) { if ( SZ ( se [ col ]) == 1 ) { auto pos = se [ col ]. begin (); sum [ col ] += querydis ( x , fin [ * pos ]) * 2 ; } else if ( SZ ( se [ col ]) > 1 ) { auto nx = se [ col ]. upper_bound ( in [ x ]); if ( nx == se [ col ]. end ()) nx = se [ col ]. begin (); auto pre = prev ( nx ); if ( nx == se [ col ]. begin ()) pre = prev ( se [ col ]. end ()); sum [ col ] -= querydis ( fin [ * nx ], fin [ * pre ]); sum [ col ] += querydis ( x , fin [ * nx ]); sum [ col ] += querydis ( x , fin [ * pre ]); } se [ col ]. insert ( in [ x ]); } void del ( int col , int x ) { if ( SZ ( se [ col ]) <= 2 ) { sum [ col ] = 0 ; } else { auto pos = se [ col ]. lower_bound ( in [ x ]); auto nx = next ( pos ); auto pre = prev ( pos ); if ( pos == se [ col ]. begin ()) pre = prev ( se [ col ]. end ()); if ( nx == se [ col ]. end ()) nx = se [ col ]. begin (); sum [ col ] -= querydis ( x , fin [ * nx ]); sum [ col ] -= querydis ( x , fin [ * pre ]); sum [ col ] += querydis ( fin [ * nx ], fin [ * pre ]); } se [ col ]. erase ( in [ x ]); } void run () { rd ( n ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v ; i < n ; ++ i ) { rd ( u , v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } * in = 0 ; deep [ 1 ] = dis [ 1 ] = 0 ; fa [ 1 ] = 1 ; dfs ( 1 ); gettop ( 1 , 1 ); memset ( sum , 0 , sizeof sum ); for ( int i = 1 ; i <= n ; ++ i ) { rd ( c [ i ]); add ( c [ i ], i ); } rd ( q ); char op [ 5 ]; for ( int i = 1 , x , y ; i <= q ; ++ i ) { cin >> op ; if ( op [ 0 ] == 'U' ) { rd ( x , y ); if ( c [ x ] == y ) continue ; del ( c [ x ], x ); c [ x ] = y ; add ( c [ x ], x ); } else { rd ( y ); if ( se [ y ]. empty ()) pt ( -1 ); else pt ( sum [ y ] / 2 ); } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem I. Sixth Sense Upsolved By -. \u9898\u610f \u601d\u8def Problem J. Jokewithpermutation Solved By Dup4 & groggy_. 01:14(+) \u9898\u610f \u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u4e2a\u5b57\u7b26\u4e32\u662f\u4e00\u4e2a\u5168\u6392\u5217\u4e2d\u6bcf\u4e2a\u6570\u5b57\u8fde\u63a5\u8d77\u6765\u7684\u3002 \u73b0\u5728\u8981\u6c42\u5c06\u6570\u5b57\u5206\u5f00\uff0c\u8fd8\u539f\u6210\u5168\u6392\u5217\u5e8f\u5217\u3002 \u601d\u8def \u53ef\u4ee5\u6839\u636e\u957f\u5ea6\u5f97\u5230 n n \uff0c\u7136\u540e\u66b4\u529b\u641c\u7d22\u5c31\u884c\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m , ok , use [ 110 ]; char s [ N ]; vector < int > res ; int toInt ( char ch ) { return ch - '0' ; } void dfs ( vector < int > vec , int cur ) { if ( ok ) return ; if ( cur == n + 1 ) { res = vec ; ok = 1 ; return ; } if ( ok ) return ; int x = toInt ( s [ cur ]); if ( x >= 1 && x <= m && use [ x ] == 0 ) { use [ x ] = 1 ; vec . push_back ( x ); dfs ( vec , cur + 1 ); vec . pop_back (); use [ x ] = 0 ; } if ( ok ) return ; if ( cur < n && x >= 1 ) { x = x * 10 + toInt ( s [ cur + 1 ]); if ( x <= m && use [ x ] == 0 ) { use [ x ] = 1 ; vec . push_back ( x ); dfs ( vec , cur + 2 ); vec . pop_back (); use [ x ] = 0 ; } } } void run () { cin >> ( s + 1 ); // cout << (s + 1) << endl; n = strlen ( s + 1 ); if ( n <= 9 ) m = 9 ; else { m = 9 + ( n - 9 ) / 2 ; } // dbg(m); ok = 0 ; memset ( use , 0 , sizeof use ); dfs ( vector < int > (), 1 ); // dbg(ok); pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day4"},{"location":"2020/nowcoder-national-day-training-party/day4/#contest-info","text":"Practice Link Solved A B C D E F G H I J 7/10 O O O \u00d8 - \u00d8 - O - O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"2020/nowcoder-national-day-training-party/day4/#solutions","text":"","title":"Solutions"},{"location":"2020/nowcoder-national-day-training-party/day4/#problem-a-digits-are-not-just-characters","text":"Solved By Dup4. 00:38(+)","title":"Problem A. Digits Are Not Just Characters"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u9898\u610f","text":"\u7ed9\u51fa\u4e24\u4e2a\u5b57\u7b26\u4e32\uff0c\u6309\u7279\u5b9a\u89c4\u5219\u6bd4\u8f83\u5927\u5c0f\u3002 \u89c4\u5219\u5c31\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\uff0c\u5355\u4e2a\u5b57\u7b26\u89c6\u4e3a letter item \uff0c\u8fde\u7eed\u7684\u6570\u5b57\u89c6\u4e3a digit item \u3002 digit item \u6392\u5728 letter item \u524d\u9762\u3002 letter item \u4e4b\u95f4\u6309\u7167\u5b57\u5178\u5e8f\u6392\u5e8f\u3002 digit item \u6309\u7167\u5b9e\u9645\u7684\u503c\u6392\u5e8f\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u601d\u8def","text":"\u66b4\u529b\u6a21\u62df\u5373\u53ef\u3002 \u4f46\u662f\u6211\u7684\u4ee3\u7801\u4e5f\u592a\u957f\u4e86\u3002 \u5b66\u4e60\u4e86\u4e00\u6bb5\u4ee3\u7801\uff0c\u53d1\u73b0\u76f4\u63a5\u5904\u7406\u540e\uff0c\u7528 vector \u53bb\u6bd4\u8f83\u5c31\u884c\u4e86\uff0c\u5bf9\u4e8e\u5b57\u7b26\u7684\u5904\u7406\u8981\u5c06\u5b83\u5904\u7406\u6210\u4e00\u4e2a\u8f83\u5927\u7684\u6570\u5b57\u3002 \u7136\u540e\u53d1\u73b0\u9898\u610f\u4e2d\u5bf9\u4e8e\u300c\u6392\u5e8f\u300d\u7684\u5b9a\u4e49\uff0c\u5176\u5b9e\u5c31\u662f PHP \u4e2d\u7684 strnatcmp \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; vector < string > _get ( string s ) { vector < string > res ; string t = \"\" ; for ( auto & ch : s ) { if ( isdigit ( ch )) t += ch ; else { if ( ! t . empty ()) res . push_back ( t ); t . clear (); string _t = \"\" ; _t += ch ; res . push_back ( _t ); } } if ( ! t . empty ()) res . push_back ( t ); // for (auto &it : res) assert(SZ(it) > 0); return res ; } int toInt ( char ch ) { return ch - '0' ; } char gao ( string s , string t ) { if ( s == t ) return '+' ; vector < string > _s ( _get ( s )), _t ( _get ( t )); // pt(_s, _t); // return '+'; for ( int i = 0 ; i < min ( SZ ( _s ), SZ ( _t )); ++ i ) { string __s = _s [ i ]; string __t = _t [ i ]; // dbg(__s, __t); int d_s = isdigit ( __s [ 0 ]); int d_t = isdigit ( __t [ 0 ]); if ( d_s != d_t ) { if ( d_t ) return '-' ; return '+' ; } if ( __s != __t ) { if ( ! d_s ) { if ( __s < __t ) return '+' ; else return '-' ; } else { if ( SZ ( __s ) != SZ ( __t )) { if ( SZ ( __s ) < SZ ( __t )) return '+' ; else return '-' ; } for ( int j = 0 ; j < SZ ( __s ); ++ j ) { int n_s = toInt ( __s [ j ]); int n_t = toInt ( __t [ j ]); if ( n_s != n_t ) { if ( n_s < n_t ) return '+' ; else return '-' ; } } } } } if ( SZ ( s ) > SZ ( t )) return '-' ; else return '+' ; } void run () { rd ( n ); string s ; rd ( s ); for ( int i = 1 ; i <= n ; ++ i ) { string t ; rd ( t ); // cout << t << endl; pt ( gao ( s , t )); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Code #include <cctype> #include <iostream> #include <string> #include <vector> using namespace std ; const int N = 1010 ; vector < long long > v [ N ]; int main () { int n ; cin >> n ; string s ; for ( int k = 0 ; k <= n ; k ++ ) { cin >> s ; long long x = 0 ; for ( int i = 0 ; i < s . length (); i ++ ) { if ( isdigit ( s [ i ])) { x = x * 10 + ( s [ i ] ^ 0x30 ); } else { if ( x ) v [ k ]. push_back ( x ), x = 0 ; v [ k ]. push_back ( s [ i ] ^ ( 1l l << 32 )); } } if ( x ) v [ k ]. push_back ( x ); } for ( int i = 1 ; i <= n ; i ++ ) { cout << ( v [ i ] < v [ 0 ] ? '-' : '+' ) << endl ; } return 0 ; } Code <?php $n = intval ( fgets ( STDIN )); $s0 = trim ( fgets ( STDIN )); for ( $i = 0 ; $i < $n ; $i ++ ) { $s = trim ( fgets ( STDIN )); if ( strnatcmp ( $s0 , $s ) > 0 ) { $result = '-' ; } else { $result = '+' ; } echo \" $result\\n \" ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day4/#problem-b-arithmetic-progressions","text":"Solved By Dup4. 00:45(+)","title":"Problem B. Arithmetic Progressions"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u9898\u610f_1","text":"\u7ed9\u51fa n n \u4e2a\u6570 a_i a_i \uff0c\u627e\u4e00\u4e2a\u5b50\u5e8f\u5217\uff0c\u4f7f\u5f97\u8fd9\u4e2a\u5b50\u5e8f\u5217\u6392\u5e8f\u540e\u662f\u4e00\u4e2a\u300c\u7b49\u5dee\u6570\u5217\u300d\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u601d\u8def_1","text":"\u5148\u6392\u5e8f\u3002 f_{i, j} f_{i, j} \u8868\u793a\u7b49\u5dee\u6570\u5217\u7684\u6700\u540e\u4e00\u9879\u4e3a a_j a_j , \u5012\u6570\u7b2c\u4e8c\u9879\u4e3a a_i a_i \u7684\u6700\u5927\u957f\u5ea6\u662f\u591a\u5c11\u3002 \u56e0\u4e3a\u5012\u6570\u4e24\u4e2a\u6570\u786e\u5b9a\u4e86\uff0c\u5dee\u5c31\u786e\u5b9a\u4e86\uff0c\u7136\u540e\u679a\u4e3e i, j i, j \u627e\u524d\u9a71\u7684\u4e00\u4e2a k k \u8fdb\u884c\u8f6c\u79fb\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 5e3 + 10 ; int n , a [ N ], f [ N ][ N ]; unordered_map < int , int > mp ; void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]); sort ( a + 1 , a + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) mp [ a [ i ]] = i ; int res = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= i ; ++ j ) { if ( i == j ) f [ j ][ i ] = 1 ; else { f [ j ][ i ] = 2 ; int pre = a [ j ] - ( a [ i ] - a [ j ]); if ( mp . count ( pre )) { chmax ( f [ j ][ i ], f [ mp [ pre ]][ j ] + 1 ); } } } } for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) chmax ( res , f [ i ][ j ]); pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day4/#problem-c-emergency-evacuation","text":"Solved By groggy_. 01:40(+)","title":"Problem C. Emergency Evacuation"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u9898\u610f_2","text":"\u6709\u4e00\u8f86\u516c\u4ea4\u8f66\uff0c\u6709 n n \u884c\uff0c m m \u5217\uff0c\u5e76\u4e14\u4e24\u8fb9\u662f\u5bf9\u79f0\u7684\u3002 \u6bcf\u4e2a\u4f4d\u7f6e\u4e0a\u7684\u4eba\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\u9700\u8981\u4e00\u4e2a\u5355\u4f4d\u7684\u65f6\u95f4\uff0c\u95ee\u6240\u6709\u4eba\u5230\u8fbe\u51fa\u53e3\u9700\u8981\u591a\u5c11\u65f6\u95f4\uff1f","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u601d\u8def_2","text":"\u56e0\u4e3a\u6b63\u7740\u505a\u4f1a\u53d1\u751f\u963b\u585e\uff0c\u6211\u4eec\u5c06\u8fd9\u4e2a\u8fc7\u7a0b\u53cd\u8fc7\u6765\uff0c\u5373\u521a\u5f00\u59cb\u5927\u5bb6\u90fd\u7b49\u5728\u51fa\u53e3\uff0c\u7136\u540e\u9700\u8981\u5230\u8fbe\u81ea\u5df1\u7684\u4f4d\u7f6e\u3002 \u6211\u4eec\u8ba9\u8def\u7a0b\u65f6\u95f4\u6700\u957f\u7684\u5148\u8d70\uff0c\u56e0\u4e3a\u8def\u7a0b\u65f6\u95f4\u957f\u7684\u4e0d\u4f1a\u963b\u585e\u8def\u7a0b\u65f6\u95f4\u77ed\u7684\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; void run () {} int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day4/#problem-d-shortest-common-non-subsequence","text":"Upsolved By Dup4.","title":"Problem D. Shortest Common Non-Subsequence"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u9898\u610f_3","text":"\u7ed9\u51fa\u4e24\u4e2a 01 \u4e32 s s \u548c t t \uff0c\u73b0\u5728\u8981\u6784\u9020\u4e00\u4e2a\u6700\u77ed\u7684 01 \u4e32\uff0c\u4f7f\u5f97\u8fd9\u4e2a 01 \u4e32\u65e2\u4e0d\u662f s s \u7684\u5b50\u5e8f\u5217\u4e5f\u4e0d\u662f t t \u7684\u5b50\u5e8f\u5217\u3002 \u8981\u6c42\u8f93\u51fa\u957f\u5ea6\u6700\u5c0f\u3001\u5176\u6b21\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u7b54\u6848\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u601d\u8def_3","text":"\u5047\u8bbe\u7b54\u6848\u4e3a n n \u4f4d\uff0c\u90a3\u4e48\u7b54\u6848\u7684\u524d n - 1 n - 1 \u4f4d\u6784\u6210\u7684 01 \u4e32\u80af\u5b9a\u662f s s \u548c\u5b50\u5e8f\u5217\u6216\u8005\u662f t t \u7684\u5b50\u5e8f\u5217\u3002 \u90a3\u4e48\u6211\u4eec\u5012\u7740 dp \uff0c f_{i, j} f_{i, j} \u8868\u793a s s \u4e32\u7684\u540e i i \u4f4d\uff0c t t \u4e32\u7684\u540e j j \u4f4d\u5931\u914d\u7684\u6700\u77ed\u957f\u5ea6\u3002 \u8981\u6c42\u5b57\u5178\u5e8f\u6700\u5c0f\uff0c\u6211\u4eec\u6b63\u7740\u8d2a\u5fc3\u5373\u53ef\u3002\u4f18\u5148\u653e 0 0 \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 4e3 + 10 ; constexpr int INF = 0x3f3f3f3f ; int n , lens , lent ; char s [ N ], t [ N ]; int h_s [ N ][ 2 ], h_t [ N ][ 2 ]; int g [ N ][ N ]; void gao1 ( char * s , int h [ N ][ 2 ]) { int len = strlen ( s + 1 ); int nx [ 2 ] = { len + 1 , len + 1 }; h [ len + 1 ][ 0 ] = h [ len + 1 ][ 1 ] = len + 1 ; for ( int i = len ; i >= 0 ; -- i ) { h [ i ][ 0 ] = nx [ 0 ]; h [ i ][ 1 ] = nx [ 1 ]; if ( i < 1 ) break ; nx [ s [ i ] - '0' ] = i ; } } void run () { cin >> ( s + 1 ) >> ( t + 1 ); lens = strlen ( s + 1 ); lent = strlen ( t + 1 ); gao1 ( s , h_s ); gao1 ( t , h_t ); memset ( g , 0x3f , sizeof g ); g [ lens + 1 ][ lent + 1 ] = 0 ; for ( int i = lens + 1 ; i >= 0 ; -- i ) { for ( int j = lent + 1 ; j >= 0 ; -- j ) { for ( int k = 0 ; k < 2 ; ++ k ) { chmin ( g [ i ][ j ], g [ h_s [ i ][ k ]][ h_t [ j ][ k ]] + 1 ); } } } string res = \"\" ; int i = 0 , j = 0 ; for ( int o = 1 ; o <= g [ 0 ][ 0 ]; ++ o ) { for ( int x = 0 ; x < 2 ; ++ x ) { int _i = h_s [ i ][ x ]; int _j = h_t [ j ][ x ]; if ( g [ i ][ j ] == g [ _i ][ _j ] + 1 ) { i = _i ; j = _j ; res += x + '0' ; break ; } } } cout << res << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day4/#problem-e-fair-chocolate-cutting","text":"Upsolved By -.","title":"Problem E. Fair Chocolate-Cutting"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u9898\u610f_4","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u601d\u8def_4","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day4/#problem-f-what-goes-up-must-come-down","text":"Upsolved By Dup4.","title":"Problem F. What Goes Up Must Come Down"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u9898\u610f_5","text":"\u7ed9\u51fa n n \u4e2a\u6570 a_i a_i \uff0c\u73b0\u5728\u6bcf\u6b21\u53ea\u80fd\u4ea4\u6362\u76f8\u90bb\u4e24\u4e2a\u6570\uff0c\u95ee\u5c06\u8fd9\u4e2a\u6570\u5217\u8c03\u6574\u6210\u53ea\u6709\u4e00\u4e2a\u5c71\u5cf0\u7684\u5f62\u72b6\u6700\u5c11\u9700\u8981\u591a\u5c11\u6b21\uff1f","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u601d\u8def_5","text":"\u5bf9\u4e8e\u4e00\u4e2a\u6570\u6765\u8bf4\uff0c\u6700\u7ec8\u8981\u4e48\u662f\u5b83\u5de6\u8fb9\u7684\u6570\u5168\u90fd\u5c0f\u4e8e\u7b49\u4e8e\u5b83\uff0c\u8981\u4e48\u662f\u5b83\u53f3\u8fb9\u7684\u6570\u5168\u90fd\u5c0f\u4e8e\u7b49\u4e8e\u5b83\u3002 \u90a3\u4e48\u5c31\u662f\u5b83\u5de6\u8fb9\u6bd4\u5b83\u5927\u7684\u6570\u5168\u90fd\u8981\u8de8\u8fc7\u5b83\u5230\u53f3\u8fb9\uff0c\u6216\u8005\u53f3\u8fb9\u6bd4\u5b83\u5927\u7684\u6570\u5168\u90fd\u8981\u8de8\u8fc7\u5b83\u5230\u5de6\u8fb9\uff0c\u6211\u4eec\u53d6 Min \u5373\u53ef\u3002","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day4/#problem-g-ranks","text":"Upsolved By -.","title":"Problem G. Ranks"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u9898\u610f_6","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u601d\u8def_6","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day4/#problem-h-colorful-tree","text":"Solved By Dup4. 04:57(+10)","title":"Problem H. Colorful Tree"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u9898\u610f_7","text":"\u7ed9\u51fa\u4e00\u68f5\u6811\uff0c\u6bcf\u4e2a\u70b9\u6709\u4e00\u4e2a\u521d\u59cb\u989c\u8272 c_i c_i \uff0c\u6709\u4e24\u79cd\u64cd\u4f5c\uff1a U x y \uff0c\u5c06\u70b9 u u \u7684\u989c\u8272\u6539\u6210 y y \u3002 Q y , \u8be2\u95ee\u6240\u6709\u989c\u8272\u4e3a y y \u7684\u70b9\u7ec4\u6210\u7684\u865a\u6570\u7684\u5468\u957f\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u601d\u8def_7","text":"\u7528 set \u7ef4\u62a4\u6bcf\u79cd\u989c\u8272\u865a\u6811\u5468\u957f\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 2e5 + 10 ; int n , q , c [ N ]; ll sum [ N ]; vector < vector < int >> G ; set < int > se [ N ]; int fa [ N ], deep [ N ], dis [ N ], sze [ N ], son [ N ], top [ N ], in [ N ], fin [ N ]; void dfs ( int u ) { sze [ u ] = 1 ; son [ u ] = 0 ; for ( auto & v : G [ u ]) { if ( v == fa [ u ]) continue ; fa [ v ] = u ; deep [ v ] = deep [ u ] + 1 ; dis [ v ] = dis [ u ] + 1 ; dfs ( v ); sze [ u ] += sze [ v ]; if ( ! son [ u ] || sze [ v ] > sze [ son [ u ]]) son [ u ] = v ; } } void gettop ( int u , int tp ) { in [ u ] = ++* in ; fin [ * in ] = u ; top [ u ] = tp ; if ( son [ u ]) gettop ( son [ u ], tp ); for ( auto & v : G [ u ]) { if ( v == fa [ u ] || v == son [ u ]) continue ; gettop ( v , v ); } } int querylca ( int u , int v ) { while ( top [ u ] != top [ v ]) { if ( deep [ top [ u ]] < deep [ top [ v ]]) { swap ( u , v ); } u = fa [ top [ u ]]; } if ( deep [ u ] > deep [ v ]) swap ( u , v ); return u ; } int querydis ( int u , int v ) { return dis [ u ] + dis [ v ] - 2 * dis [ querylca ( u , v )]; } void add ( int col , int x ) { if ( SZ ( se [ col ]) == 1 ) { auto pos = se [ col ]. begin (); sum [ col ] += querydis ( x , fin [ * pos ]) * 2 ; } else if ( SZ ( se [ col ]) > 1 ) { auto nx = se [ col ]. upper_bound ( in [ x ]); if ( nx == se [ col ]. end ()) nx = se [ col ]. begin (); auto pre = prev ( nx ); if ( nx == se [ col ]. begin ()) pre = prev ( se [ col ]. end ()); sum [ col ] -= querydis ( fin [ * nx ], fin [ * pre ]); sum [ col ] += querydis ( x , fin [ * nx ]); sum [ col ] += querydis ( x , fin [ * pre ]); } se [ col ]. insert ( in [ x ]); } void del ( int col , int x ) { if ( SZ ( se [ col ]) <= 2 ) { sum [ col ] = 0 ; } else { auto pos = se [ col ]. lower_bound ( in [ x ]); auto nx = next ( pos ); auto pre = prev ( pos ); if ( pos == se [ col ]. begin ()) pre = prev ( se [ col ]. end ()); if ( nx == se [ col ]. end ()) nx = se [ col ]. begin (); sum [ col ] -= querydis ( x , fin [ * nx ]); sum [ col ] -= querydis ( x , fin [ * pre ]); sum [ col ] += querydis ( fin [ * nx ], fin [ * pre ]); } se [ col ]. erase ( in [ x ]); } void run () { rd ( n ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v ; i < n ; ++ i ) { rd ( u , v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } * in = 0 ; deep [ 1 ] = dis [ 1 ] = 0 ; fa [ 1 ] = 1 ; dfs ( 1 ); gettop ( 1 , 1 ); memset ( sum , 0 , sizeof sum ); for ( int i = 1 ; i <= n ; ++ i ) { rd ( c [ i ]); add ( c [ i ], i ); } rd ( q ); char op [ 5 ]; for ( int i = 1 , x , y ; i <= q ; ++ i ) { cin >> op ; if ( op [ 0 ] == 'U' ) { rd ( x , y ); if ( c [ x ] == y ) continue ; del ( c [ x ], x ); c [ x ] = y ; add ( c [ x ], x ); } else { rd ( y ); if ( se [ y ]. empty ()) pt ( -1 ); else pt ( sum [ y ] / 2 ); } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day4/#problem-i-sixth-sense","text":"Upsolved By -.","title":"Problem I. Sixth Sense"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u9898\u610f_8","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u601d\u8def_8","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day4/#problem-j-jokewithpermutation","text":"Solved By Dup4 & groggy_. 01:14(+)","title":"Problem J. Jokewithpermutation"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u9898\u610f_9","text":"\u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u4e2a\u5b57\u7b26\u4e32\u662f\u4e00\u4e2a\u5168\u6392\u5217\u4e2d\u6bcf\u4e2a\u6570\u5b57\u8fde\u63a5\u8d77\u6765\u7684\u3002 \u73b0\u5728\u8981\u6c42\u5c06\u6570\u5b57\u5206\u5f00\uff0c\u8fd8\u539f\u6210\u5168\u6392\u5217\u5e8f\u5217\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day4/#\u601d\u8def_9","text":"\u53ef\u4ee5\u6839\u636e\u957f\u5ea6\u5f97\u5230 n n \uff0c\u7136\u540e\u66b4\u529b\u641c\u7d22\u5c31\u884c\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m , ok , use [ 110 ]; char s [ N ]; vector < int > res ; int toInt ( char ch ) { return ch - '0' ; } void dfs ( vector < int > vec , int cur ) { if ( ok ) return ; if ( cur == n + 1 ) { res = vec ; ok = 1 ; return ; } if ( ok ) return ; int x = toInt ( s [ cur ]); if ( x >= 1 && x <= m && use [ x ] == 0 ) { use [ x ] = 1 ; vec . push_back ( x ); dfs ( vec , cur + 1 ); vec . pop_back (); use [ x ] = 0 ; } if ( ok ) return ; if ( cur < n && x >= 1 ) { x = x * 10 + toInt ( s [ cur + 1 ]); if ( x <= m && use [ x ] == 0 ) { use [ x ] = 1 ; vec . push_back ( x ); dfs ( vec , cur + 2 ); vec . pop_back (); use [ x ] = 0 ; } } } void run () { cin >> ( s + 1 ); // cout << (s + 1) << endl; n = strlen ( s + 1 ); if ( n <= 9 ) m = 9 ; else { m = 9 + ( n - 9 ) / 2 ; } // dbg(m); ok = 0 ; memset ( use , 0 , sizeof use ); dfs ( vector < int > (), 1 ); // dbg(ok); pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day5/","text":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day5 Contents Contest Info Solutions Problem A. Kingdom Reunion \u9898\u610f \u601d\u8def Problem B. Hyperdrome \u9898\u610f \u601d\u8def Problem C. Great Deceiver \u9898\u610f \u601d\u8def Problem D. Exact Measurement \u9898\u610f \u601d\u8def Problem E. Caravan Robbers \u9898\u610f \u601d\u8def Problem F. Kabaleo Lite \u9898\u610f \u601d\u8def Problem G. Hack Protection \u9898\u610f \u601d\u8def Problem H. Fraud Busters \u9898\u610f \u601d\u8def Problem I. Cactus Automorphisms \u9898\u610f \u601d\u8def Problem J. Bonus Cards \u9898\u610f \u601d\u8def Problem K. Knockout Racing \u9898\u610f \u601d\u8def Contest Info Practice Link Solved A B C D E F G H I J K 6/11 - O O O \u00d8 - - O - - O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions Problem A. Kingdom Reunion Upsolved By -. \u9898\u610f \u601d\u8def Problem B. Hyperdrome Solved By Dup4. 01:51(+1) \u9898\u610f \u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u627e\u51fa\u6709\u591a\u5c11\u4e2a\u5b50\u4e32\u6ee1\u8db3\u91cd\u65b0\u6392\u5217\u540e\u662f\u4e00\u4e2a\u56de\u6587\u4e32\u3002 \u601d\u8def \u9898\u610f\u7684\u8981\u6c42\u5c31\u662f\u627e\u6709\u591a\u5c11\u4e2a\u5b50\u4e32\uff0c\u4f7f\u5f97\u6700\u591a\u53ea\u6709\u4e00\u79cd\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\u3002 \u6211\u4eec\u8003\u8651\u7ef4\u62a4\u4e00\u4e2a\u524d\u7f00\u5b57\u7b26\u51fa\u73b0\u4fe1\u606f f_i f_i \uff0c 0 0 \u8868\u793a\u51fa\u73b0\u5076\u6570\u6b21\uff0c 1 1 \u8868\u793a\u51fa\u73b0\u5947\u6570\u6b21\uff0c\u90a3\u4e48\u4efb\u610f\u4e00\u4e2a\u5b50\u4e32 [l_i, r_i] [l_i, r_i] \uff0c\u53ea\u8981\u6ee1\u8db3 f_r \\oplus f_{l - 1} f_r \\oplus f_{l - 1} \u4e2d\u6700\u591a\u53ea\u6709\u4e00\u4f4d\u4e3a 1 1 \u5c31\u53ef\u4ee5\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 3e5 + 10 ; constexpr int M = 52 ; int n ; char s [ N ]; ll f [ N ]; unordered_map < ll , int > mp ; void run () { rd ( n ); cin >> ( s + 1 ); memset ( f , 0 , sizeof f ); for ( int i = 1 ; i <= n ; ++ i ) { f [ i ] = f [ i - 1 ]; int c = s [ i ]; if ( c >= 'a' && c <= 'z' ) c -= 'a' ; else c = c - 'A' + 26 ; f [ i ] = f [ i ] ^ ( 1l l << c ); } mp . clear (); mp [ 0 ] = 1 ; ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { res += mp [ f [ i ]]; for ( int j = 0 ; j < 52 ; ++ j ) { ll x = f [ i ] ^ ( 1l l << j ); if ( mp . count ( x )) res += mp [ x ]; } ++ mp [ f [ i ]]; } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem C. Great Deceiver Solved By Dup4. 02:21(+) \u9898\u610f \u7ed9\u51fa\u4e00\u4e2a n n \u548c k k \uff0c\u8981\u6c42\u5341\u8fdb\u5236\u4e2d\u5c0f\u4e8e\u7b49\u4e8e n n \u7684\u6570\u4e2d\uff0c\u5728 +k +k \u8fdb\u5236\u548c -k -k \u8fdb\u5236\u4e0b\u76f8\u7b49\u7684\u6570\u6709\u591a\u5c11\u4e2a\u3002 \u601d\u8def \u5728 +k +k \u8fdb\u5236\u4e0b \u548c -k -k \u8fdb\u5236\u4e0b\u76f8\u7b49\uff0c\u5373\u8868\u660e\u5947\u6570\u6b21\u5e42\u4e0a\u7684\u503c\u5168\u90fd\u4e3a 0 0 \u5373\u53ef\u3002 \u90a3\u4e48\u6211\u4eec\u53bb\u6389\u5947\u6570\u6b21\u5e42\uff0c\u8d2a\u5fc3\u51fa\u6700\u5927\u503c\uff0c\u5373\u4e3a\u6700\u591a\u7684\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; ll n ; int K ; ll getMax ( ll n , int K ) { ll base = 1 ; int cnt = 0 ; while ( base * K <= n && base * K * K <= n ) { base *= K ; base *= K ; ++ cnt ; } // dbg(base); // vector <int> vec(cnt + 1); ll act = 0 ; ll res = 0 ; for ( int i = cnt ; i >= 0 ; -- i ) { ll now = ( n - act ) / base ; now = min ( now , 1l l * K - 1 ); act += now * base ; // dbg(i, now, base); base /= K ; base /= K ; res = res * K + now ; } return res + 1 ; } void run () { rd ( n , K ); ll Max = getMax ( n , K ); pt ( Max ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem D. Exact Measurement Solved By Dup4 & groggy_. 04:35(+1) \u9898\u610f \u7ed9\u51fa n n \u4e2a\u7bb1\u5b50\uff0c\u6bcf\u4e2a\u7bb1\u5b50\u6709 10^{k_i} 10^{k_i} \u7684\u781d\u7801\u6709 q_i q_i \u4e2a\uff0c\u73b0\u5728\u8981\u53d6\u6700\u5c11\u7684\u7bb1\u5b50\uff0c\u4f7f\u5f97\u6709\u4e00\u79cd\u65b9\u6848\u53d6\u51fa\u8fd9\u4e9b\u7bb1\u5b50\u4e2d\u7684\u781d\u7801\u4f7f\u5f97\u91cd\u91cf\u548c\u7b49\u4e8e x x \u3002 \u5373\u7bb1\u5b50\u4e2d\u7684\u781d\u7801\u53ef\u4ee5\u4e0d\u5168\u53d6\u51fa\u6765\u3002 \u601d\u8def \u4f4e\u4f4d\u7684\u781d\u7801\u4e0d\u80fd\u6ee1\u8db3\u66f4\u4f4e\u4f4d\u7684\u9700\u6c42\uff0c\u4f46\u662f\u80fd\u591f\u6ee1\u8db3\u9ad8\u4f4d\u7684\u9700\u6c42\u3002 \u90a3\u4e48\u6211\u4eec\u4ece\u5730\u4f4d\u5230\u9ad8\u4f4d\u8d2a\u5fc3\uff0c\u6bcf\u6b21\u904d\u5386\u5230\u4e00\u4f4d\uff0c\u90fd\u4f1a\u89e3\u9501\u82e5\u5e72\u7bb1\u5b50\uff0c\u7136\u540e\u4e22\u8fdb\u6700\u5927\u5806\uff0c\u6bcf\u6b21\u53d6\u76d2\u5b50\u781d\u7801\u603b\u91cd\u91cf\u5927\u7684\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; using pLI = pair < ll , int > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; ll x , ten [ 20 ]; void run () { rd ( x , n ); vector < pLI > vec [ 20 ]; int k ; ll q ; for ( int i = 1 ; i <= n ; ++ i ) { rd ( k , q ); vec [ k ]. push_back ( pLI ( q * ten [ k ], i )); } priority_queue < pLI > pq ; ll sum = 0 ; ll need = 0 ; ll base = 1 ; vector < int > res ; for ( int i = 0 ; i <= 18 ; ++ i ) { for ( auto & it : vec [ i ]) { pq . push ( it ); } need += base * ( x % 10 ); base *= 10 ; x /= 10 ; while ( sum < need ) { if ( pq . empty ()) return pt ( -1 ); sum += pq . top (). fi ; res . push_back ( pq . top (). se ); pq . pop (); } } sort ( all ( res )); pt ( SZ ( res )); pt ( res ); } int main () { ten [ 0 ] = 1 ; for ( int i = 1 ; i <= 18 ; ++ i ) ten [ i ] = ten [ i - 1 ] * 10 ; ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem E. Caravan Robbers Upsolved By Dup4. \u9898\u610f \u7ed9\u51fa n n \u4e2a\u7ebf\u6bb5 [a_i, b_i] [a_i, b_i] \uff0c\u6ee1\u8db3 i \\leq j i \\leq j , \u6709 a_i \\leq a_j, b_i \\leq b_j a_i \\leq a_j, b_i \\leq b_j , \u73b0\u5728\u8981\u627e\u51fa\u6700\u957f\u7684\u957f\u5ea6 len len \uff0c\u6ee1\u8db3\u6bcf\u6761\u7ebf\u6bb5\u90fd\u80fd\u53d6\u51fa\u90a3\u4e48\u957f\u7684\u5b50\u6bb5\uff0c\u5e76\u4e14 n n \u6761\u7ebf\u6bb5\u4e0d\u76f8\u4ea4\u3002 \u601d\u8def \u5982\u679c\u6709\u4e24\u4e2a\u91cd\u53e0\u7684\u7ebf\u6bb5\uff0c\u90a3\u4e48\u53ef\u4ee5\u53d6\u5e73\u5747\u503c\u3002\u4f46\u662f\u8981\u8ddf\u5404\u81ea\u7684\u672c\u8eab\u7684\u7ebf\u6bb5\u957f\u5ea6\u53d6 Min \u3002 \u90a3\u4e48\u5bf9\u4e8e x x \u4e2a\u91cd\u53e0\u7684\u7ebf\u6bb5\uff0c\u7b54\u6848\u5e94\u8be5\u662f\u4efb\u610f\u8fde\u7eed\u4e2a\u7ebf\u6bb5\u7684\u5e73\u5747\u503c\u7684\u6700\u5c0f\u503c\u3002 \u4f46\u662f\u8fd9\u4e48\u505a\u590d\u6742\u5ea6\u662f \\mathcal{O}(n^2) \\mathcal{O}(n^2) \u3002 \u90a3\u4e48\u6211\u4eec\u8003\u8651\u4e8c\u5206\uff0c\u7136\u540e\u8d2a\u5fc3\u5224\u65ad\u3002 \u4f46\u662f\u7b54\u6848\u8981\u5206\u6570\uff0c\u6211\u4eec\u8003\u8651\u5c0f\u6570\u5982\u4f55\u5316\u5206\u6570\u3002 \u8003\u8651\u5206\u6570 \\displaystyle \\frac{p}{q} = d \\displaystyle \\frac{p}{q} = d , \u6709 \\displaystyle p = qd \\displaystyle p = qd \u3002 \u6240\u4ee5\u6211\u4eec\u679a\u4e3e\u5206\u6bcd q q \uff0c\u6b64\u5904\u6839\u636e\u524d\u9762\u7684\u5206\u6790\uff0c\u663e\u7136\u5f53\u6240\u6709\u7ebf\u6bb5\u6324\u5728\u4e00\u8d77\u7684\u65f6\u5019\uff0c\u5206\u6570\u6700\u5927\u4e3a n n \u3002 \u901a\u8fc7\u63a7\u5236\u8bef\u5dee\u53bb\u5f97\u5230\u66f4\u7cbe\u786e\u7684\u503c\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = long double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; constexpr db eps = 1e-11 ; int n ; pII a [ N ]; int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; return x < 0 ? -1 : 1 ; } bool ok ( db x ) { db st = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { st = max ( st , ( db ) 1.0 * a [ i ]. fi ); db ed = st + x ; if ( sgn ( ed - a [ i ]. se ) > 0 ) return false ; st = ed ; } return true ; } void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) { rd ( a [ i ]. fi , a [ i ]. se ); } sort ( a + 1 , a + 1 + n , [ & ]( pII a , pII b ) { if ( a . fi == b . fi ) return a . se < b . se ; return a . fi < b . fi ; }); db l = 0 , r = a [ n ]. se ; while ( r - l > eps ) { db mid = ( l + r ) / 2 ; if ( ok ( mid )) { l = mid ; } else { r = mid ; } } db Min = 0x3f3f3f3f ; int p , q ; for ( int i = 1 ; i <= N ; ++ i ) { for ( auto & j : { floor ( l * i ), ceil ( l * i )}) { if ( fabs ( j * 1.0 / i - l ) < Min ) { p = j ; q = i ; Min = fabs ( j * 1.0 / i - l ); } } } cout << p << \"/\" << q << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem F. Kabaleo Lite Upsolved By -. \u9898\u610f \u601d\u8def Problem G. Hack Protection Upsolved By -. \u9898\u610f \u601d\u8def Problem H. Fraud Busters Solved By groggy_. 00:34(+) \u9898\u610f \u914d\u51fa\u5b57\u7b26\u4e32\uff0c\u6c42\u6709\u591a\u5c11\u4e2a\u5339\u914d \u601d\u8def \u66b4\u529b\u5339\u914d Code #include <iostream> #include <vector> #define maxn 1005 using namespace std ; string s , t ; vector < string > v ; void solve ( string a , string b ) { int flag = 0 ; for ( int i = 0 ; i < a . size (); i ++ ) { if ( a [ i ] != b [ i ] && a [ i ] != '*' ) { flag = 1 ; break ; } } if ( ! flag ) v . push_back ( b ); } int main () { cin >> s ; int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> t ; solve ( s , t ); } cout << v . size () << endl ; for ( int i = 0 ; i < v . size (); i ++ ) cout << v [ i ] << endl ; } Problem I. Cactus Automorphisms Upsolved By -. \u9898\u610f \u601d\u8def Problem J. Bonus Cards Upsolved By -. \u9898\u610f \u601d\u8def Problem K. Knockout Racing Solved By groggy_. 00:25(+1) \u9898\u610f \u6bcf\u8f86\u8f66\u5728 a a \u548c b b \u4e4b\u95f4\u6765\u56de\u79fb\u52a8\u3002 \u6c42 t t \u65f6\u523b\uff0c x x \u548c y y \u533a\u95f4\u5185\u6709\u591a\u5c11\u8f86\u8f66\u3002 \u601d\u8def \u8ba1\u7b97\u67e5\u8be2\u65f6\u523b\u7684\u6bcf\u4e2a\u8f66\u4f4d\u7f6e Code #include <iostream> #define maxn 1005 using namespace std ; int n , m ; int a [ maxn ], b [ maxn ]; int calc ( int index , int t ) { t %= 2 * ( b [ index ] - a [ index ]); if ( t <= b [ index ] - a [ index ]) return a [ index ] + t ; else return 2 * b [ index ] - a [ index ] - t ; } void solve ( int x , int y , int t ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dis = calc ( i , t ); // cout<<dis<<endl; if ( dis >= x && dis <= y ) cnt ++ ; } printf ( \"%d \\n \" , cnt ); } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d%d\" , & a [ i ], & b [ i ]); } int x , y , t ; for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d%d\" , & x , & y , & t ); solve ( x , y , t ); } }","title":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day5"},{"location":"2020/nowcoder-national-day-training-party/day5/#contest-info","text":"Practice Link Solved A B C D E F G H I J K 6/11 - O O O \u00d8 - - O - - O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"2020/nowcoder-national-day-training-party/day5/#solutions","text":"","title":"Solutions"},{"location":"2020/nowcoder-national-day-training-party/day5/#problem-a-kingdom-reunion","text":"Upsolved By -.","title":"Problem A. Kingdom Reunion"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u9898\u610f","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u601d\u8def","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day5/#problem-b-hyperdrome","text":"Solved By Dup4. 01:51(+1)","title":"Problem B. Hyperdrome"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u9898\u610f_1","text":"\u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u627e\u51fa\u6709\u591a\u5c11\u4e2a\u5b50\u4e32\u6ee1\u8db3\u91cd\u65b0\u6392\u5217\u540e\u662f\u4e00\u4e2a\u56de\u6587\u4e32\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u601d\u8def_1","text":"\u9898\u610f\u7684\u8981\u6c42\u5c31\u662f\u627e\u6709\u591a\u5c11\u4e2a\u5b50\u4e32\uff0c\u4f7f\u5f97\u6700\u591a\u53ea\u6709\u4e00\u79cd\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\u3002 \u6211\u4eec\u8003\u8651\u7ef4\u62a4\u4e00\u4e2a\u524d\u7f00\u5b57\u7b26\u51fa\u73b0\u4fe1\u606f f_i f_i \uff0c 0 0 \u8868\u793a\u51fa\u73b0\u5076\u6570\u6b21\uff0c 1 1 \u8868\u793a\u51fa\u73b0\u5947\u6570\u6b21\uff0c\u90a3\u4e48\u4efb\u610f\u4e00\u4e2a\u5b50\u4e32 [l_i, r_i] [l_i, r_i] \uff0c\u53ea\u8981\u6ee1\u8db3 f_r \\oplus f_{l - 1} f_r \\oplus f_{l - 1} \u4e2d\u6700\u591a\u53ea\u6709\u4e00\u4f4d\u4e3a 1 1 \u5c31\u53ef\u4ee5\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 3e5 + 10 ; constexpr int M = 52 ; int n ; char s [ N ]; ll f [ N ]; unordered_map < ll , int > mp ; void run () { rd ( n ); cin >> ( s + 1 ); memset ( f , 0 , sizeof f ); for ( int i = 1 ; i <= n ; ++ i ) { f [ i ] = f [ i - 1 ]; int c = s [ i ]; if ( c >= 'a' && c <= 'z' ) c -= 'a' ; else c = c - 'A' + 26 ; f [ i ] = f [ i ] ^ ( 1l l << c ); } mp . clear (); mp [ 0 ] = 1 ; ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { res += mp [ f [ i ]]; for ( int j = 0 ; j < 52 ; ++ j ) { ll x = f [ i ] ^ ( 1l l << j ); if ( mp . count ( x )) res += mp [ x ]; } ++ mp [ f [ i ]]; } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day5/#problem-c-great-deceiver","text":"Solved By Dup4. 02:21(+)","title":"Problem C. Great Deceiver"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u9898\u610f_2","text":"\u7ed9\u51fa\u4e00\u4e2a n n \u548c k k \uff0c\u8981\u6c42\u5341\u8fdb\u5236\u4e2d\u5c0f\u4e8e\u7b49\u4e8e n n \u7684\u6570\u4e2d\uff0c\u5728 +k +k \u8fdb\u5236\u548c -k -k \u8fdb\u5236\u4e0b\u76f8\u7b49\u7684\u6570\u6709\u591a\u5c11\u4e2a\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u601d\u8def_2","text":"\u5728 +k +k \u8fdb\u5236\u4e0b \u548c -k -k \u8fdb\u5236\u4e0b\u76f8\u7b49\uff0c\u5373\u8868\u660e\u5947\u6570\u6b21\u5e42\u4e0a\u7684\u503c\u5168\u90fd\u4e3a 0 0 \u5373\u53ef\u3002 \u90a3\u4e48\u6211\u4eec\u53bb\u6389\u5947\u6570\u6b21\u5e42\uff0c\u8d2a\u5fc3\u51fa\u6700\u5927\u503c\uff0c\u5373\u4e3a\u6700\u591a\u7684\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; ll n ; int K ; ll getMax ( ll n , int K ) { ll base = 1 ; int cnt = 0 ; while ( base * K <= n && base * K * K <= n ) { base *= K ; base *= K ; ++ cnt ; } // dbg(base); // vector <int> vec(cnt + 1); ll act = 0 ; ll res = 0 ; for ( int i = cnt ; i >= 0 ; -- i ) { ll now = ( n - act ) / base ; now = min ( now , 1l l * K - 1 ); act += now * base ; // dbg(i, now, base); base /= K ; base /= K ; res = res * K + now ; } return res + 1 ; } void run () { rd ( n , K ); ll Max = getMax ( n , K ); pt ( Max ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day5/#problem-d-exact-measurement","text":"Solved By Dup4 & groggy_. 04:35(+1)","title":"Problem D. Exact Measurement"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u9898\u610f_3","text":"\u7ed9\u51fa n n \u4e2a\u7bb1\u5b50\uff0c\u6bcf\u4e2a\u7bb1\u5b50\u6709 10^{k_i} 10^{k_i} \u7684\u781d\u7801\u6709 q_i q_i \u4e2a\uff0c\u73b0\u5728\u8981\u53d6\u6700\u5c11\u7684\u7bb1\u5b50\uff0c\u4f7f\u5f97\u6709\u4e00\u79cd\u65b9\u6848\u53d6\u51fa\u8fd9\u4e9b\u7bb1\u5b50\u4e2d\u7684\u781d\u7801\u4f7f\u5f97\u91cd\u91cf\u548c\u7b49\u4e8e x x \u3002 \u5373\u7bb1\u5b50\u4e2d\u7684\u781d\u7801\u53ef\u4ee5\u4e0d\u5168\u53d6\u51fa\u6765\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u601d\u8def_3","text":"\u4f4e\u4f4d\u7684\u781d\u7801\u4e0d\u80fd\u6ee1\u8db3\u66f4\u4f4e\u4f4d\u7684\u9700\u6c42\uff0c\u4f46\u662f\u80fd\u591f\u6ee1\u8db3\u9ad8\u4f4d\u7684\u9700\u6c42\u3002 \u90a3\u4e48\u6211\u4eec\u4ece\u5730\u4f4d\u5230\u9ad8\u4f4d\u8d2a\u5fc3\uff0c\u6bcf\u6b21\u904d\u5386\u5230\u4e00\u4f4d\uff0c\u90fd\u4f1a\u89e3\u9501\u82e5\u5e72\u7bb1\u5b50\uff0c\u7136\u540e\u4e22\u8fdb\u6700\u5927\u5806\uff0c\u6bcf\u6b21\u53d6\u76d2\u5b50\u781d\u7801\u603b\u91cd\u91cf\u5927\u7684\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; using pLI = pair < ll , int > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; ll x , ten [ 20 ]; void run () { rd ( x , n ); vector < pLI > vec [ 20 ]; int k ; ll q ; for ( int i = 1 ; i <= n ; ++ i ) { rd ( k , q ); vec [ k ]. push_back ( pLI ( q * ten [ k ], i )); } priority_queue < pLI > pq ; ll sum = 0 ; ll need = 0 ; ll base = 1 ; vector < int > res ; for ( int i = 0 ; i <= 18 ; ++ i ) { for ( auto & it : vec [ i ]) { pq . push ( it ); } need += base * ( x % 10 ); base *= 10 ; x /= 10 ; while ( sum < need ) { if ( pq . empty ()) return pt ( -1 ); sum += pq . top (). fi ; res . push_back ( pq . top (). se ); pq . pop (); } } sort ( all ( res )); pt ( SZ ( res )); pt ( res ); } int main () { ten [ 0 ] = 1 ; for ( int i = 1 ; i <= 18 ; ++ i ) ten [ i ] = ten [ i - 1 ] * 10 ; ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day5/#problem-e-caravan-robbers","text":"Upsolved By Dup4.","title":"Problem E. Caravan Robbers"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u9898\u610f_4","text":"\u7ed9\u51fa n n \u4e2a\u7ebf\u6bb5 [a_i, b_i] [a_i, b_i] \uff0c\u6ee1\u8db3 i \\leq j i \\leq j , \u6709 a_i \\leq a_j, b_i \\leq b_j a_i \\leq a_j, b_i \\leq b_j , \u73b0\u5728\u8981\u627e\u51fa\u6700\u957f\u7684\u957f\u5ea6 len len \uff0c\u6ee1\u8db3\u6bcf\u6761\u7ebf\u6bb5\u90fd\u80fd\u53d6\u51fa\u90a3\u4e48\u957f\u7684\u5b50\u6bb5\uff0c\u5e76\u4e14 n n \u6761\u7ebf\u6bb5\u4e0d\u76f8\u4ea4\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u601d\u8def_4","text":"\u5982\u679c\u6709\u4e24\u4e2a\u91cd\u53e0\u7684\u7ebf\u6bb5\uff0c\u90a3\u4e48\u53ef\u4ee5\u53d6\u5e73\u5747\u503c\u3002\u4f46\u662f\u8981\u8ddf\u5404\u81ea\u7684\u672c\u8eab\u7684\u7ebf\u6bb5\u957f\u5ea6\u53d6 Min \u3002 \u90a3\u4e48\u5bf9\u4e8e x x \u4e2a\u91cd\u53e0\u7684\u7ebf\u6bb5\uff0c\u7b54\u6848\u5e94\u8be5\u662f\u4efb\u610f\u8fde\u7eed\u4e2a\u7ebf\u6bb5\u7684\u5e73\u5747\u503c\u7684\u6700\u5c0f\u503c\u3002 \u4f46\u662f\u8fd9\u4e48\u505a\u590d\u6742\u5ea6\u662f \\mathcal{O}(n^2) \\mathcal{O}(n^2) \u3002 \u90a3\u4e48\u6211\u4eec\u8003\u8651\u4e8c\u5206\uff0c\u7136\u540e\u8d2a\u5fc3\u5224\u65ad\u3002 \u4f46\u662f\u7b54\u6848\u8981\u5206\u6570\uff0c\u6211\u4eec\u8003\u8651\u5c0f\u6570\u5982\u4f55\u5316\u5206\u6570\u3002 \u8003\u8651\u5206\u6570 \\displaystyle \\frac{p}{q} = d \\displaystyle \\frac{p}{q} = d , \u6709 \\displaystyle p = qd \\displaystyle p = qd \u3002 \u6240\u4ee5\u6211\u4eec\u679a\u4e3e\u5206\u6bcd q q \uff0c\u6b64\u5904\u6839\u636e\u524d\u9762\u7684\u5206\u6790\uff0c\u663e\u7136\u5f53\u6240\u6709\u7ebf\u6bb5\u6324\u5728\u4e00\u8d77\u7684\u65f6\u5019\uff0c\u5206\u6570\u6700\u5927\u4e3a n n \u3002 \u901a\u8fc7\u63a7\u5236\u8bef\u5dee\u53bb\u5f97\u5230\u66f4\u7cbe\u786e\u7684\u503c\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = long double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; constexpr db eps = 1e-11 ; int n ; pII a [ N ]; int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; return x < 0 ? -1 : 1 ; } bool ok ( db x ) { db st = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { st = max ( st , ( db ) 1.0 * a [ i ]. fi ); db ed = st + x ; if ( sgn ( ed - a [ i ]. se ) > 0 ) return false ; st = ed ; } return true ; } void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) { rd ( a [ i ]. fi , a [ i ]. se ); } sort ( a + 1 , a + 1 + n , [ & ]( pII a , pII b ) { if ( a . fi == b . fi ) return a . se < b . se ; return a . fi < b . fi ; }); db l = 0 , r = a [ n ]. se ; while ( r - l > eps ) { db mid = ( l + r ) / 2 ; if ( ok ( mid )) { l = mid ; } else { r = mid ; } } db Min = 0x3f3f3f3f ; int p , q ; for ( int i = 1 ; i <= N ; ++ i ) { for ( auto & j : { floor ( l * i ), ceil ( l * i )}) { if ( fabs ( j * 1.0 / i - l ) < Min ) { p = j ; q = i ; Min = fabs ( j * 1.0 / i - l ); } } } cout << p << \"/\" << q << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day5/#problem-f-kabaleo-lite","text":"Upsolved By -.","title":"Problem F. Kabaleo Lite"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u9898\u610f_5","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u601d\u8def_5","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day5/#problem-g-hack-protection","text":"Upsolved By -.","title":"Problem G. Hack Protection"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u9898\u610f_6","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u601d\u8def_6","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day5/#problem-h-fraud-busters","text":"Solved By groggy_. 00:34(+)","title":"Problem H. Fraud Busters"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u9898\u610f_7","text":"\u914d\u51fa\u5b57\u7b26\u4e32\uff0c\u6c42\u6709\u591a\u5c11\u4e2a\u5339\u914d","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u601d\u8def_7","text":"\u66b4\u529b\u5339\u914d Code #include <iostream> #include <vector> #define maxn 1005 using namespace std ; string s , t ; vector < string > v ; void solve ( string a , string b ) { int flag = 0 ; for ( int i = 0 ; i < a . size (); i ++ ) { if ( a [ i ] != b [ i ] && a [ i ] != '*' ) { flag = 1 ; break ; } } if ( ! flag ) v . push_back ( b ); } int main () { cin >> s ; int n ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { cin >> t ; solve ( s , t ); } cout << v . size () << endl ; for ( int i = 0 ; i < v . size (); i ++ ) cout << v [ i ] << endl ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day5/#problem-i-cactus-automorphisms","text":"Upsolved By -.","title":"Problem I. Cactus Automorphisms"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u9898\u610f_8","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u601d\u8def_8","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day5/#problem-j-bonus-cards","text":"Upsolved By -.","title":"Problem J. Bonus Cards"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u9898\u610f_9","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u601d\u8def_9","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day5/#problem-k-knockout-racing","text":"Solved By groggy_. 00:25(+1)","title":"Problem K. Knockout Racing"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u9898\u610f_10","text":"\u6bcf\u8f86\u8f66\u5728 a a \u548c b b \u4e4b\u95f4\u6765\u56de\u79fb\u52a8\u3002 \u6c42 t t \u65f6\u523b\uff0c x x \u548c y y \u533a\u95f4\u5185\u6709\u591a\u5c11\u8f86\u8f66\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day5/#\u601d\u8def_10","text":"\u8ba1\u7b97\u67e5\u8be2\u65f6\u523b\u7684\u6bcf\u4e2a\u8f66\u4f4d\u7f6e Code #include <iostream> #define maxn 1005 using namespace std ; int n , m ; int a [ maxn ], b [ maxn ]; int calc ( int index , int t ) { t %= 2 * ( b [ index ] - a [ index ]); if ( t <= b [ index ] - a [ index ]) return a [ index ] + t ; else return 2 * b [ index ] - a [ index ] - t ; } void solve ( int x , int y , int t ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dis = calc ( i , t ); // cout<<dis<<endl; if ( dis >= x && dis <= y ) cnt ++ ; } printf ( \"%d \\n \" , cnt ); } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d%d\" , & a [ i ], & b [ i ]); } int x , y , t ; for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d%d\" , & x , & y , & t ); solve ( x , y , t ); } }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day6/","text":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day6 Contents Contest Info Solutions Problem A. Fractions \u9898\u610f \u601d\u8def Problem B. Guest Student \u9898\u610f \u601d\u8def Problem C. Harder Satisfiability \u9898\u610f \u601d\u8def Problem D. Interval-Free Permutations \u9898\u610f \u601d\u8def Problem E. King Kog's Reception \u9898\u610f \u601d\u8def Problem F. Lazyland \u9898\u610f \u601d\u8def Problem G. Minegraphed \u9898\u610f \u601d\u8def Problem H. Archery Tournament \u9898\u610f \u601d\u8def Problem I. Box \u9898\u610f \u601d\u8def Problem J. Connections \u9898\u610f \u601d\u8def Problem K. The Final Level \u9898\u610f \u601d\u8def Contest Info Practice Link Solved A B C D E F G H I J K 6/11 O O - - O O - - O \u00d8 - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions Problem A. Fractions Solved By Dup4 & lts. 01:38(+) \u9898\u610f \u7ed9\u51fa n n \uff0c\u8981\u6c42\u627e\u51fa k(1 \\leq k \\leq 10^5) k(1 \\leq k \\leq 10^5) \u5bf9\u5206\u6570 \\displaystyle \\frac{a_i}{b_i} \\displaystyle \\frac{a_i}{b_i} \uff0c\u6ee1\u8db3\uff1a b_i \\;|\\; n b_i \\;|\\; n , \u5e76\u4e14\u6709 1 \\lt b_i \\lt n 1 \\lt b_i \\lt n \u3002 1 \\leq a_i \\lt b_i 1 \\leq a_i \\lt b_i \u3002 \\displaystyle \\sum\\limits_{i = 1}^k \\frac{a_i}{b_i} = 1 - \\frac{1}{n} \\displaystyle \\sum\\limits_{i = 1}^k \\frac{a_i}{b_i} = 1 - \\frac{1}{n} \u3002 \u601d\u8def \u5927\u529b\u731c\u6d4b\u4e24\u4e2a\u5206\u6570\u5c31\u591f\u4e86\u3002 \u7136\u540e\u679a\u4e3e\u51fa\u4e24\u4e2a\u5206\u6bcd\uff0c\u505a exgcd \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; ll ex_gcd ( ll a , ll b , ll & x , ll & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll d = ex_gcd ( b , a % b , x , y ); ll temp = x ; x = y ; y = temp - a / b * y ; return d ; } bool liEu ( ll a , ll b , ll c , ll & x , ll & y ) { ll d = ex_gcd ( a , b , x , y ); if ( c % d != 0 ) return 0 ; ll k = c / d ; x *= k ; y *= k ; return 1 ; } void run () { rd ( n ); vector < int > fac ; for ( int i = 1 ; 1l l * i * i <= n ; ++ i ) { if ( n % i == 0 ) { if ( i != 1 && i != n ) fac . push_back ( i ); if ( n / i != 1 && n / i != n ) fac . push_back ( n / i ); } } sort ( all ( fac )); fac . erase ( unique ( all ( fac )), fac . end ()); int m = SZ ( fac ); for ( int i = 0 ; i < m ; ++ i ) { if (( n - 1 ) % ( n / fac [ i ]) == 0 ) { cout << \"YES \\n \" ; pt ( 1 ); pt (( n - 1 ) / ( n / fac [ i ]), fac [ i ]); return ; } for ( int j = i + 1 ; j < m ; ++ j ) { ll a = n / fac [ i ]; ll b = n / fac [ j ]; ll c = n - 1 ; ll x , y ; ll g = __gcd ( a , b ); ll t ; if ( liEu ( a , b , c , x , y )) { // if (x < 1) { t = b / g ; x = ( x % t + t ) % t ; // } // if (y < 1) { t = a / g ; y = ( y % t + t ) % t ; // } cout << \"YES \\n \" ; pt ( 2 ); pt ( x , fac [ i ]); pt ( y , fac [ j ]); return ; } } } cout << \"NO \\n \" ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem B. Guest Student Solved By Dup4. 00:31(+1) \u9898\u610f \u7ed9\u51fa\u4e00\u5468\u4e03\u5929\uff0c\u54ea\u4e9b\u5929\u6709\u8bfe\uff0c\u7136\u540e\u7ed9\u51fa n n \uff0c\u95ee\u4e0a n n \u5929\u8bfe\u9700\u8981\u7684\u5468\u671f\u662f\u591a\u957f\u3002 \u601d\u8def \u679a\u4e3e\u7b2c\u4e00\u5468\u548c\u6700\u540e\u4e00\u5468\u7684\u5f00\u59cb\u4f4d\u7f6e\u548c\u7ed3\u675f\u4f4d\u7f6e\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , a [ 10 ], f [ 10 ]; int ceil ( int x , int y ) { return ( x + y - 1 ) / y ; } void run () { rd ( n ); f [ 0 ] = 0 ; for ( int i = 1 ; i <= 7 ; ++ i ) rd ( a [ i ]), f [ i ] = f [ i - 1 ] + a [ i ]; int sum = f [ 7 ]; int res = 7 * n ; if ( n <= sum ) { for ( int i = 1 ; i <= 7 ; ++ i ) { for ( int j = i ; j <= 7 ; ++ j ) { if ( f [ j ] - f [ i - 1 ] >= n ) { chmin ( res , j - i + 1 ); } } } } for ( int i = 1 ; i <= 7 ; ++ i ) { for ( int j = 1 ; j <= 7 ; ++ j ) { int need = n - f [ j ] - ( sum - f [ i - 1 ]); int now = 7 - i + 1 + j ; now += ceil ( need , sum ) * 7 ; // dbg(i, j, need, now); chmin ( res , now ); } } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem C. Harder Satisfiability Upsolved By -. \u9898\u610f \u601d\u8def Problem D. Interval-Free Permutations Upsolved By -. \u9898\u610f \u601d\u8def Problem E. King Kog's Reception Solved By Dup4. 03:20(+) \u9898\u610f \u7ed9\u51fa q q \u4e2a\u4e8b\u4ef6\uff0c\u4e8b\u4ef6\u7c7b\u578b\u6709\u5982\u4e0b\u4e09\u79cd\uff1a + t d , \u8868\u793a\u5728\u7b2c t t \u65f6\u523b\u6709\u4e2a\u9a91\u58eb\u9700\u8981\u53c2\u89c1\u56fd\u738b\uff0c\u53c2\u89c1\u6240\u9700\u4e8b\u4ef6\u4e3a d d \u3002 - i \uff0c\u8868\u793a\u53d6\u6d88\u7b2c i i \u4e2a\u4e8b\u4ef6\u3002 ? t \uff0c\u8868\u793a\u8be2\u95ee\u516c\u4e3b\u5982\u679c\u5728\u7b2c t t \u65f6\u523b\u6765\u89c1\u56fd\u738b\uff0c\u9700\u8981\u7b49\u591a\u4e45\u3002\u5982\u679c\u540c\u4e00\u65f6\u523b\uff0c\u4e5f\u6709\u9a91\u58eb\u5728\u7b49\uff0c\u90a3\u4e48\u9a91\u58eb\u4f18\u5148\u3002 \u601d\u8def \u6211\u4eec\u7528 f_i f_i \u8868\u793a\u524d i i \u4e2a\u65f6\u523b\u6240\u6709\u53c2\u89c1\u4e8b\u4ef6\u5168\u90fd\u7ed3\u675f\u9700\u8981\u7684\u65f6\u95f4\uff0c\u90a3\u4e48\u6709\uff1a \\begin{eqnarray*} f_i = \\max(f_{i - 1}, i) + d_i \\end{eqnarray*} \\begin{eqnarray*} f_i = \\max(f_{i - 1}, i) + d_i \\end{eqnarray*} \u7136\u540e\u53d1\u73b0\u8fd9\u4e2a\u4e1c\u897f\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e6 + 10 ; int q , t [ N ], d [ N ]; struct SEG { struct node { ll sum , Max ; node () { sum = Max = 0 ; } node ( ll sum , ll Max ) : sum ( sum ), Max ( Max ) {} node operator + ( const node & other ) const { node res = node (); res . sum = sum + other . sum ; res . Max = max ( other . Max , Max + other . sum ); return res ; } } t [ N << 2 ], res ; void build ( int id , int l , int r ) { if ( l == r ) { t [ id ] = node ( 0 , l ); return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } void update ( int id , int l , int r , int pos , ll v ) { if ( l == r ) { t [ id ]. sum += v ; t [ id ]. Max += v ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , v ); else update ( id << 1 | 1 , mid + 1 , r , pos , v ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } void query ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) { res = res + t [ id ]; return ; } int mid = ( l + r ) >> 1 ; if ( ql <= mid ) query ( id << 1 , l , mid , ql , qr ); if ( qr > mid ) query ( id << 1 | 1 , mid + 1 , r , ql , qr ); } } seg ; void run () { rd ( q ); char op [ 5 ]; int m = 1e6 ; seg . build ( 1 , 1 , m ); for ( int i = 1 , _t , x ; i <= q ; ++ i ) { cin >> op ; if ( * op == '+' ) { rd ( t [ i ], d [ i ]); seg . update ( 1 , 1 , m , t [ i ], d [ i ]); } else if ( * op == '-' ) { rd ( x ); seg . update ( 1 , 1 , m , t [ x ], - d [ x ]); } else { rd ( _t ); seg . res = SEG :: node (); seg . query ( 1 , 1 , m , 1 , _t ); pt ( seg . res . Max - _t ); } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem F. Lazyland Solved By Dup4. 00:38(+) \u9898\u610f \u7ed9\u51fa n n \u4e2a\u4eba\u4ee5\u53ca m m \u4e2a\u4efb\u52a1\uff0c\u5e76\u4e14\u7b2c i i \u4e2a\u4eba\u60f3\u8981\u505a\u7b2c a_i a_i \u4e2a\u4efb\u52a1\uff0c\u8981\u60f3\u529d\u8bf4\u7b2c i i \u4e2a\u4eba\u6539\u53d8\u4ed6\u7684\u610f\u5fd7\u9700\u8981\u82b1\u8d39 b_i b_i \u7684\u4ee3\u4ef7\uff0c\u73b0\u5728\u8981\u6c42\u6bcf\u4e2a\u4efb\u52a1\u81f3\u5c11\u6709\u4e00\u4e2a\u4eba\u9700\u8981\u505a\uff0c\u6700\u5c11\u9700\u8981\u82b1\u8d39\u591a\u5c11\u4ee3\u4ef7\u3002 \u601d\u8def \u5c06\u6bcf\u4e2a\u4efb\u52a1\u4e0d\u7528\u529d\u8bf4\u7684\u4eba\u4e2d\uff0c\u9664\u4e86\u4ee3\u4ef7\u6700\u9ad8\u7684\u90a3\u4e2a\u4eba\uff0c\u5176\u4ed6\u4eba\u5168\u90fd\u4e22\u8fdb\u6700\u5c0f\u5806\u4e2d\uff0c\u7136\u540e\u8d2a\u5fc3\u53d6\u51fa\u6765\u53bb\u505a\u5176\u4ed6\u4efb\u52a1\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , k , a [ N ], b [ N ], c [ N ]; void run () { rd ( n , k ); for ( auto & arr : { a , b }) { for ( int i = 1 ; i <= n ; ++ i ) { rd ( arr [ i ]); } } memset ( c , 0 , sizeof c ); vector < pII > vec ; for ( int i = 1 ; i <= n ; ++ i ) { ++ c [ a [ i ]]; vec . push_back ( pII ( b [ i ], a [ i ])); } ll sum = 0 ; int need = 0 ; for ( int i = 1 ; i <= k ; ++ i ) need += c [ i ] == 0 ; sort ( all ( vec ), [ & ]( pII a , pII b ) { return a . fi > b . fi ; }); while ( need ) { pII back = vec . back (); vec . pop_back (); if ( c [ back . se ] == 1 ) continue ; else { -- need ; -- c [ back . se ]; sum += back . fi ; } } pt ( sum ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem G. Minegraphed Upsolved By -. \u9898\u610f \u601d\u8def Problem H. Archery Tournament Upsolved By -. \u9898\u610f \u601d\u8def Problem I. Box Solved By groggy_. 01:09(+1) \u9898\u610f \u5bf9\u4e8e\u7ed9\u51fa\u5bbd\u4e3a w w \uff0c\u9ad8\u4e3a h h \u7684\u7eb8\uff0c\u9700\u8981\u526a\u51fa a \\cdot b \\cdot c a \\cdot b \\cdot c \u7684\u957f\u65b9\u4f53\uff0c\u95ee\u80fd\u5426\u88c1\u51fa \u601d\u8def \u957f\u65b9\u4f53\u7684\u6784\u6210\u65b9\u5f0f\u53ef\u4ee5\u770b\u4f5c\u4e24\u79cd\uff0c\u7528\u4e0d\u540c\u8fb9\u957f\u5c1d\u8bd5\u51fa\u5404\u79cd\u5bbd\u4e0e\u9ad8\u7684\u53ef\u80fd\u6027\uff0c\u5224\u65ad\u5373\u53ef Code #include <algorithm> #include <iostream> #include <vector> #define maxn 100005 using namespace std ; int w , h ; bool solve ( int W , int H ) { return W <= w && H <= h ; } int main () { int a , b , c ; scanf ( \"%d%d%d\" , & a , & b , & c ); scanf ( \"%d%d\" , & w , & h ); int flag = 0 ; flag = flag | solve (( a + b ) * 2 , c + 2 * min ( a , b )); flag = flag | solve (( a + c ) * 2 , b + 2 * min ( a , c )); flag = flag | solve (( b + c ) * 2 , a + 2 * min ( b , c )); flag = flag | solve ( 3 * b + a + c , c + a ); flag = flag | solve ( 3 * a + b + c , b + c ); flag = flag | solve ( 3 * c + a + b , a + b ); flag = flag | solve ( c + 2 * min ( a , b ), ( a + b ) * 2 ); flag = flag | solve ( b + 2 * min ( a , c ), ( a + c ) * 2 ); flag = flag | solve ( a + 2 * min ( b , c ), ( b + c ) * 2 ); flag = flag | solve ( c + a , 3 * b + a + c ); flag = flag | solve ( b + c , 3 * a + b + c ); flag = flag | solve ( a + b , 3 * c + a + b ); if ( flag ) cout << \"Yes\" << endl ; else cout << \"No\" << endl ; } Problem J. Connections Upsolved By Dup4. \u9898\u610f \u7ed9\u51fa n n \u4e2a\u70b9 m \\gt 2 \\cdot n m \\gt 2 \\cdot n \u6761\u8fb9\u7684\u6709\u5411\u5f3a\u8fde\u901a\u56fe\uff0c\u73b0\u5728\u8981\u6c42\u53ea\u4fdd\u7559 2n 2n \u6761\u8fb9\uff0c\u4f7f\u5f97\u56fe\u4ecd\u7136\u662f\u5f3a\u8fde\u901a\u7684\u3002 \u601d\u8def \u968f\u4fbf\u627e\u4e2a\u70b9\u4f5c\u4e3a\u6839\uff0c\u8dd1\u51fa\u4e00\u4e2a dfs \u6811\uff0c\u7136\u540e\u5728\u53cd\u56fe\u4e0a\uff0c\u8fd8\u662f\u4ee5\u8fd9\u4e2a\u70b9\u4e3a\u6839\uff0c\u8dd1\u51fa\u4e00\u4e2a dfs \u6811\u5373\u53ef\u3002 \u663e\u7136\uff0c\u8fd9\u4e24\u68f5\u6811\u6240\u7528\u7684\u8fb9\u4e0d\u4f1a\u8d85\u8fc7 2(n - 1) 2(n - 1) \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m , vis [ N ], f [ N ]; pII e [ N ]; vector < vector < pII >> G , T ; void dfs ( int u ) { for ( auto & it : G [ u ]) { int v = it . fi , id = it . se ; if ( ! vis [ v ]) { f [ id ] = 1 ; vis [ v ] = 1 ; dfs ( v ); } } } void run () { rd ( n , m ); G . clear (); G . resize ( n + 1 ); T . clear (); T . resize ( n + 1 ); for ( int i = 1 , u , v ; i <= m ; ++ i ) { rd ( u , v ); e [ i ] = pII ( u , v ); G [ u ]. push_back ( pII ( v , i )); T [ v ]. push_back ( pII ( u , i )); f [ i ] = 0 ; } memset ( vis , 0 , sizeof ( vis [ 0 ]) * ( n + 5 )); dfs ( 1 ); memset ( vis , 0 , sizeof ( vis [ 0 ]) * ( n + 5 )); G = T ; dfs ( 1 ); int tot = m - n * 2 ; for ( int i = 1 ; i <= m ; ++ i ) { if ( f [ i ] == 0 && tot ) { -- tot ; pt ( e [ i ]. fi , e [ i ]. se ); } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem K. The Final Level Upsolved By -. \u9898\u610f \u601d\u8def","title":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day6"},{"location":"2020/nowcoder-national-day-training-party/day6/#contest-info","text":"Practice Link Solved A B C D E F G H I J K 6/11 O O - - O O - - O \u00d8 - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"2020/nowcoder-national-day-training-party/day6/#solutions","text":"","title":"Solutions"},{"location":"2020/nowcoder-national-day-training-party/day6/#problem-a-fractions","text":"Solved By Dup4 & lts. 01:38(+)","title":"Problem A. Fractions"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u9898\u610f","text":"\u7ed9\u51fa n n \uff0c\u8981\u6c42\u627e\u51fa k(1 \\leq k \\leq 10^5) k(1 \\leq k \\leq 10^5) \u5bf9\u5206\u6570 \\displaystyle \\frac{a_i}{b_i} \\displaystyle \\frac{a_i}{b_i} \uff0c\u6ee1\u8db3\uff1a b_i \\;|\\; n b_i \\;|\\; n , \u5e76\u4e14\u6709 1 \\lt b_i \\lt n 1 \\lt b_i \\lt n \u3002 1 \\leq a_i \\lt b_i 1 \\leq a_i \\lt b_i \u3002 \\displaystyle \\sum\\limits_{i = 1}^k \\frac{a_i}{b_i} = 1 - \\frac{1}{n} \\displaystyle \\sum\\limits_{i = 1}^k \\frac{a_i}{b_i} = 1 - \\frac{1}{n} \u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u601d\u8def","text":"\u5927\u529b\u731c\u6d4b\u4e24\u4e2a\u5206\u6570\u5c31\u591f\u4e86\u3002 \u7136\u540e\u679a\u4e3e\u51fa\u4e24\u4e2a\u5206\u6bcd\uff0c\u505a exgcd \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; ll ex_gcd ( ll a , ll b , ll & x , ll & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } ll d = ex_gcd ( b , a % b , x , y ); ll temp = x ; x = y ; y = temp - a / b * y ; return d ; } bool liEu ( ll a , ll b , ll c , ll & x , ll & y ) { ll d = ex_gcd ( a , b , x , y ); if ( c % d != 0 ) return 0 ; ll k = c / d ; x *= k ; y *= k ; return 1 ; } void run () { rd ( n ); vector < int > fac ; for ( int i = 1 ; 1l l * i * i <= n ; ++ i ) { if ( n % i == 0 ) { if ( i != 1 && i != n ) fac . push_back ( i ); if ( n / i != 1 && n / i != n ) fac . push_back ( n / i ); } } sort ( all ( fac )); fac . erase ( unique ( all ( fac )), fac . end ()); int m = SZ ( fac ); for ( int i = 0 ; i < m ; ++ i ) { if (( n - 1 ) % ( n / fac [ i ]) == 0 ) { cout << \"YES \\n \" ; pt ( 1 ); pt (( n - 1 ) / ( n / fac [ i ]), fac [ i ]); return ; } for ( int j = i + 1 ; j < m ; ++ j ) { ll a = n / fac [ i ]; ll b = n / fac [ j ]; ll c = n - 1 ; ll x , y ; ll g = __gcd ( a , b ); ll t ; if ( liEu ( a , b , c , x , y )) { // if (x < 1) { t = b / g ; x = ( x % t + t ) % t ; // } // if (y < 1) { t = a / g ; y = ( y % t + t ) % t ; // } cout << \"YES \\n \" ; pt ( 2 ); pt ( x , fac [ i ]); pt ( y , fac [ j ]); return ; } } } cout << \"NO \\n \" ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day6/#problem-b-guest-student","text":"Solved By Dup4. 00:31(+1)","title":"Problem B. Guest Student"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u9898\u610f_1","text":"\u7ed9\u51fa\u4e00\u5468\u4e03\u5929\uff0c\u54ea\u4e9b\u5929\u6709\u8bfe\uff0c\u7136\u540e\u7ed9\u51fa n n \uff0c\u95ee\u4e0a n n \u5929\u8bfe\u9700\u8981\u7684\u5468\u671f\u662f\u591a\u957f\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u601d\u8def_1","text":"\u679a\u4e3e\u7b2c\u4e00\u5468\u548c\u6700\u540e\u4e00\u5468\u7684\u5f00\u59cb\u4f4d\u7f6e\u548c\u7ed3\u675f\u4f4d\u7f6e\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , a [ 10 ], f [ 10 ]; int ceil ( int x , int y ) { return ( x + y - 1 ) / y ; } void run () { rd ( n ); f [ 0 ] = 0 ; for ( int i = 1 ; i <= 7 ; ++ i ) rd ( a [ i ]), f [ i ] = f [ i - 1 ] + a [ i ]; int sum = f [ 7 ]; int res = 7 * n ; if ( n <= sum ) { for ( int i = 1 ; i <= 7 ; ++ i ) { for ( int j = i ; j <= 7 ; ++ j ) { if ( f [ j ] - f [ i - 1 ] >= n ) { chmin ( res , j - i + 1 ); } } } } for ( int i = 1 ; i <= 7 ; ++ i ) { for ( int j = 1 ; j <= 7 ; ++ j ) { int need = n - f [ j ] - ( sum - f [ i - 1 ]); int now = 7 - i + 1 + j ; now += ceil ( need , sum ) * 7 ; // dbg(i, j, need, now); chmin ( res , now ); } } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day6/#problem-c-harder-satisfiability","text":"Upsolved By -.","title":"Problem C. Harder Satisfiability"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u9898\u610f_2","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u601d\u8def_2","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day6/#problem-d-interval-free-permutations","text":"Upsolved By -.","title":"Problem D. Interval-Free Permutations"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u9898\u610f_3","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u601d\u8def_3","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day6/#problem-e-king-kogs-reception","text":"Solved By Dup4. 03:20(+)","title":"Problem E. King Kog's Reception"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u9898\u610f_4","text":"\u7ed9\u51fa q q \u4e2a\u4e8b\u4ef6\uff0c\u4e8b\u4ef6\u7c7b\u578b\u6709\u5982\u4e0b\u4e09\u79cd\uff1a + t d , \u8868\u793a\u5728\u7b2c t t \u65f6\u523b\u6709\u4e2a\u9a91\u58eb\u9700\u8981\u53c2\u89c1\u56fd\u738b\uff0c\u53c2\u89c1\u6240\u9700\u4e8b\u4ef6\u4e3a d d \u3002 - i \uff0c\u8868\u793a\u53d6\u6d88\u7b2c i i \u4e2a\u4e8b\u4ef6\u3002 ? t \uff0c\u8868\u793a\u8be2\u95ee\u516c\u4e3b\u5982\u679c\u5728\u7b2c t t \u65f6\u523b\u6765\u89c1\u56fd\u738b\uff0c\u9700\u8981\u7b49\u591a\u4e45\u3002\u5982\u679c\u540c\u4e00\u65f6\u523b\uff0c\u4e5f\u6709\u9a91\u58eb\u5728\u7b49\uff0c\u90a3\u4e48\u9a91\u58eb\u4f18\u5148\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u601d\u8def_4","text":"\u6211\u4eec\u7528 f_i f_i \u8868\u793a\u524d i i \u4e2a\u65f6\u523b\u6240\u6709\u53c2\u89c1\u4e8b\u4ef6\u5168\u90fd\u7ed3\u675f\u9700\u8981\u7684\u65f6\u95f4\uff0c\u90a3\u4e48\u6709\uff1a \\begin{eqnarray*} f_i = \\max(f_{i - 1}, i) + d_i \\end{eqnarray*} \\begin{eqnarray*} f_i = \\max(f_{i - 1}, i) + d_i \\end{eqnarray*} \u7136\u540e\u53d1\u73b0\u8fd9\u4e2a\u4e1c\u897f\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e6 + 10 ; int q , t [ N ], d [ N ]; struct SEG { struct node { ll sum , Max ; node () { sum = Max = 0 ; } node ( ll sum , ll Max ) : sum ( sum ), Max ( Max ) {} node operator + ( const node & other ) const { node res = node (); res . sum = sum + other . sum ; res . Max = max ( other . Max , Max + other . sum ); return res ; } } t [ N << 2 ], res ; void build ( int id , int l , int r ) { if ( l == r ) { t [ id ] = node ( 0 , l ); return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } void update ( int id , int l , int r , int pos , ll v ) { if ( l == r ) { t [ id ]. sum += v ; t [ id ]. Max += v ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , v ); else update ( id << 1 | 1 , mid + 1 , r , pos , v ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } void query ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) { res = res + t [ id ]; return ; } int mid = ( l + r ) >> 1 ; if ( ql <= mid ) query ( id << 1 , l , mid , ql , qr ); if ( qr > mid ) query ( id << 1 | 1 , mid + 1 , r , ql , qr ); } } seg ; void run () { rd ( q ); char op [ 5 ]; int m = 1e6 ; seg . build ( 1 , 1 , m ); for ( int i = 1 , _t , x ; i <= q ; ++ i ) { cin >> op ; if ( * op == '+' ) { rd ( t [ i ], d [ i ]); seg . update ( 1 , 1 , m , t [ i ], d [ i ]); } else if ( * op == '-' ) { rd ( x ); seg . update ( 1 , 1 , m , t [ x ], - d [ x ]); } else { rd ( _t ); seg . res = SEG :: node (); seg . query ( 1 , 1 , m , 1 , _t ); pt ( seg . res . Max - _t ); } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day6/#problem-f-lazyland","text":"Solved By Dup4. 00:38(+)","title":"Problem F. Lazyland"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u9898\u610f_5","text":"\u7ed9\u51fa n n \u4e2a\u4eba\u4ee5\u53ca m m \u4e2a\u4efb\u52a1\uff0c\u5e76\u4e14\u7b2c i i \u4e2a\u4eba\u60f3\u8981\u505a\u7b2c a_i a_i \u4e2a\u4efb\u52a1\uff0c\u8981\u60f3\u529d\u8bf4\u7b2c i i \u4e2a\u4eba\u6539\u53d8\u4ed6\u7684\u610f\u5fd7\u9700\u8981\u82b1\u8d39 b_i b_i \u7684\u4ee3\u4ef7\uff0c\u73b0\u5728\u8981\u6c42\u6bcf\u4e2a\u4efb\u52a1\u81f3\u5c11\u6709\u4e00\u4e2a\u4eba\u9700\u8981\u505a\uff0c\u6700\u5c11\u9700\u8981\u82b1\u8d39\u591a\u5c11\u4ee3\u4ef7\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u601d\u8def_5","text":"\u5c06\u6bcf\u4e2a\u4efb\u52a1\u4e0d\u7528\u529d\u8bf4\u7684\u4eba\u4e2d\uff0c\u9664\u4e86\u4ee3\u4ef7\u6700\u9ad8\u7684\u90a3\u4e2a\u4eba\uff0c\u5176\u4ed6\u4eba\u5168\u90fd\u4e22\u8fdb\u6700\u5c0f\u5806\u4e2d\uff0c\u7136\u540e\u8d2a\u5fc3\u53d6\u51fa\u6765\u53bb\u505a\u5176\u4ed6\u4efb\u52a1\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , k , a [ N ], b [ N ], c [ N ]; void run () { rd ( n , k ); for ( auto & arr : { a , b }) { for ( int i = 1 ; i <= n ; ++ i ) { rd ( arr [ i ]); } } memset ( c , 0 , sizeof c ); vector < pII > vec ; for ( int i = 1 ; i <= n ; ++ i ) { ++ c [ a [ i ]]; vec . push_back ( pII ( b [ i ], a [ i ])); } ll sum = 0 ; int need = 0 ; for ( int i = 1 ; i <= k ; ++ i ) need += c [ i ] == 0 ; sort ( all ( vec ), [ & ]( pII a , pII b ) { return a . fi > b . fi ; }); while ( need ) { pII back = vec . back (); vec . pop_back (); if ( c [ back . se ] == 1 ) continue ; else { -- need ; -- c [ back . se ]; sum += back . fi ; } } pt ( sum ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day6/#problem-g-minegraphed","text":"Upsolved By -.","title":"Problem G. Minegraphed"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u9898\u610f_6","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u601d\u8def_6","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day6/#problem-h-archery-tournament","text":"Upsolved By -.","title":"Problem H. Archery Tournament"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u9898\u610f_7","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u601d\u8def_7","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day6/#problem-i-box","text":"Solved By groggy_. 01:09(+1)","title":"Problem I. Box"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u9898\u610f_8","text":"\u5bf9\u4e8e\u7ed9\u51fa\u5bbd\u4e3a w w \uff0c\u9ad8\u4e3a h h \u7684\u7eb8\uff0c\u9700\u8981\u526a\u51fa a \\cdot b \\cdot c a \\cdot b \\cdot c \u7684\u957f\u65b9\u4f53\uff0c\u95ee\u80fd\u5426\u88c1\u51fa","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u601d\u8def_8","text":"\u957f\u65b9\u4f53\u7684\u6784\u6210\u65b9\u5f0f\u53ef\u4ee5\u770b\u4f5c\u4e24\u79cd\uff0c\u7528\u4e0d\u540c\u8fb9\u957f\u5c1d\u8bd5\u51fa\u5404\u79cd\u5bbd\u4e0e\u9ad8\u7684\u53ef\u80fd\u6027\uff0c\u5224\u65ad\u5373\u53ef Code #include <algorithm> #include <iostream> #include <vector> #define maxn 100005 using namespace std ; int w , h ; bool solve ( int W , int H ) { return W <= w && H <= h ; } int main () { int a , b , c ; scanf ( \"%d%d%d\" , & a , & b , & c ); scanf ( \"%d%d\" , & w , & h ); int flag = 0 ; flag = flag | solve (( a + b ) * 2 , c + 2 * min ( a , b )); flag = flag | solve (( a + c ) * 2 , b + 2 * min ( a , c )); flag = flag | solve (( b + c ) * 2 , a + 2 * min ( b , c )); flag = flag | solve ( 3 * b + a + c , c + a ); flag = flag | solve ( 3 * a + b + c , b + c ); flag = flag | solve ( 3 * c + a + b , a + b ); flag = flag | solve ( c + 2 * min ( a , b ), ( a + b ) * 2 ); flag = flag | solve ( b + 2 * min ( a , c ), ( a + c ) * 2 ); flag = flag | solve ( a + 2 * min ( b , c ), ( b + c ) * 2 ); flag = flag | solve ( c + a , 3 * b + a + c ); flag = flag | solve ( b + c , 3 * a + b + c ); flag = flag | solve ( a + b , 3 * c + a + b ); if ( flag ) cout << \"Yes\" << endl ; else cout << \"No\" << endl ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day6/#problem-j-connections","text":"Upsolved By Dup4.","title":"Problem J. Connections"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u9898\u610f_9","text":"\u7ed9\u51fa n n \u4e2a\u70b9 m \\gt 2 \\cdot n m \\gt 2 \\cdot n \u6761\u8fb9\u7684\u6709\u5411\u5f3a\u8fde\u901a\u56fe\uff0c\u73b0\u5728\u8981\u6c42\u53ea\u4fdd\u7559 2n 2n \u6761\u8fb9\uff0c\u4f7f\u5f97\u56fe\u4ecd\u7136\u662f\u5f3a\u8fde\u901a\u7684\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u601d\u8def_9","text":"\u968f\u4fbf\u627e\u4e2a\u70b9\u4f5c\u4e3a\u6839\uff0c\u8dd1\u51fa\u4e00\u4e2a dfs \u6811\uff0c\u7136\u540e\u5728\u53cd\u56fe\u4e0a\uff0c\u8fd8\u662f\u4ee5\u8fd9\u4e2a\u70b9\u4e3a\u6839\uff0c\u8dd1\u51fa\u4e00\u4e2a dfs \u6811\u5373\u53ef\u3002 \u663e\u7136\uff0c\u8fd9\u4e24\u68f5\u6811\u6240\u7528\u7684\u8fb9\u4e0d\u4f1a\u8d85\u8fc7 2(n - 1) 2(n - 1) \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m , vis [ N ], f [ N ]; pII e [ N ]; vector < vector < pII >> G , T ; void dfs ( int u ) { for ( auto & it : G [ u ]) { int v = it . fi , id = it . se ; if ( ! vis [ v ]) { f [ id ] = 1 ; vis [ v ] = 1 ; dfs ( v ); } } } void run () { rd ( n , m ); G . clear (); G . resize ( n + 1 ); T . clear (); T . resize ( n + 1 ); for ( int i = 1 , u , v ; i <= m ; ++ i ) { rd ( u , v ); e [ i ] = pII ( u , v ); G [ u ]. push_back ( pII ( v , i )); T [ v ]. push_back ( pII ( u , i )); f [ i ] = 0 ; } memset ( vis , 0 , sizeof ( vis [ 0 ]) * ( n + 5 )); dfs ( 1 ); memset ( vis , 0 , sizeof ( vis [ 0 ]) * ( n + 5 )); G = T ; dfs ( 1 ); int tot = m - n * 2 ; for ( int i = 1 ; i <= m ; ++ i ) { if ( f [ i ] == 0 && tot ) { -- tot ; pt ( e [ i ]. fi , e [ i ]. se ); } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day6/#problem-k-the-final-level","text":"Upsolved By -.","title":"Problem K. The Final Level"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u9898\u610f_10","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day6/#\u601d\u8def_10","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day7/","text":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day7 Contents Contest Info Solutions Problem A. Laminar Family \u9898\u610f \u601d\u8def Problem B. Abbreviation \u9898\u610f \u601d\u8def Problem C. Expect to Wait \u9898\u610f \u601d\u8def Problem D. Foreign Postcards \u9898\u610f \u601d\u8def Problem E. Game on Graph \u9898\u610f \u601d\u8def Problem F. Jenga Boom \u9898\u610f \u601d\u8def Problem G. List of Primes \u9898\u610f \u601d\u8def Problem H. Mole Tunnels \u9898\u610f \u601d\u8def Problem I. Bowlstack \u9898\u610f \u601d\u8def Problem J. Adjustment Office \u9898\u610f \u601d\u8def Problem K. Binary vs Decimal \u9898\u610f \u601d\u8def Contest Info Practice Link Solved A B C D E F G H I J K 5/11 O O O O - - - - - O - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions Problem A. Laminar Family Solved By Dup4. 04:28(+1) \u9898\u610f \u7ed9\u51fa\u4e00\u68f5 n n \u4e2a\u70b9\u7684\u6811\uff0c\u4ee5\u53ca m m \u6761\u7b80\u5355\u8def\u5f84 (a_i, b_i) (a_i, b_i) \uff0c\u95ee\u8fd9 m m \u6761\u7b80\u5355\u8def\u5f84\u662f\u5426\u4e24\u4e24\u4e0d\u76f8\u4ea4\u6216\u8005\u5904\u4e8e\u5305\u542b\u5173\u7cfb\u3002 \u601d\u8def \u6309\u8def\u5f84\u957f\u5ea6\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\u3002 \u5bf9\u4e8e\u7b2c i i \u6bb5\u7b80\u5355\u8def\u5f84\uff0c\u6211\u4eec\u5728\u7ebf\u6bb5\u6811\u4e0a\u5c06\u8fd9\u8fd9\u6bb5\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u6743\u503c\u8d4b\u6210 i i \u3002 \u7136\u540e\u5bf9\u4e8e\u5f53\u524d\u8def\u5f84 (a_i, b_i) (a_i, b_i) \uff0c\u6211\u4eec\u5728\u7ebf\u6bb5\u6811\u4e0a\u67e5\u8be2\u8fd9\u6bb5\u8def\u5f84\u7684\u70b9\u6743\u548c\uff0c\u5047\u8bbe\u4e3a y y \uff0c\u8be5\u8def\u5f84\u4e0a\u7684\u70b9\u6570\u4e3a x x \uff0c\u90a3\u4e48\u6211\u4eec\u77e5\u9053\u5982\u679c\u8fd9\u6bb5\u7b80\u5355\u8def\u5f84\u5c5e\u4e8e\u4e4b\u524d\u7684\u67d0\u6bb5\u8def\u5f84\uff0c\u800c\u4e0d\u662f\u62fc\u51d1\u6210\u7684\uff0c\u90a3\u4e48\u80af\u5b9a\u5c5e\u4e8e\u7b2c \\displaystyle \\frac{y}{x} \\displaystyle \\frac{y}{x} \u6761\u8def\u5f84\u3002 \u53ef\u4ee5\u989d\u5916\u5224\u65ad\u7b2c \\displaystyle \\frac{y}{x} \\displaystyle \\frac{y}{x} \u6761\u8def\u5f84\u662f\u5426\u5305\u542b \u7b2c i i \u6761\u8def\u5f84\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m ; vector < vector < int >> G ; struct BIT_2D { struct BIT { ll a [ N ]; void init () { memset ( a , 0 , sizeof a ); } void add ( int x , ll v ) { for (; x < N ; a [ x ] += v , x += x & - x ) ; } ll ask ( int x ) { ll res = 0 ; for (; x > 0 ; res += a [ x ], x -= x & - x ) ; return res ; } } bit1 , bit2 ; void init () { bit1 . init (); bit2 . init (); } ll ask ( int x ) { return ( x + 1 ) * bit1 . ask ( x ) - bit2 . ask ( x ); } void add ( int x , ll v ) { bit1 . add ( x , v ); bit2 . add ( x , x * v ); } ll ask ( int l , int r ) { return ask ( r ) - ask ( l - 1 ); } void add ( int l , int r , ll v ) { add ( l , v ); add ( r + 1 , - v ); } } bit ; struct HLD { int fa [ N ], deep [ N ], dis [ N ], sze [ N ], son [ N ], top [ N ], in [ N ], fin [ N ], out [ N ]; void dfs ( int u ) { sze [ u ] = 1 ; son [ u ] = 0 ; for ( auto & v : G [ u ]) { if ( v == fa [ u ]) continue ; fa [ v ] = u ; deep [ v ] = deep [ u ] + 1 ; dis [ v ] = dis [ u ] + 1 ; dfs ( v ); sze [ u ] += sze [ v ]; if ( ! son [ u ] || sze [ v ] > sze [ son [ u ]]) son [ u ] = v ; } } void gettop ( int u , int tp ) { in [ u ] = ++* in ; fin [ * in ] = u ; top [ u ] = tp ; if ( son [ u ]) gettop ( son [ u ], tp ); for ( auto & v : G [ u ]) { if ( v == son [ u ] || v == fa [ u ]) continue ; gettop ( v , v ); } out [ u ] = * in ; } void init ( int rt ) { fa [ rt ] = rt ; dis [ rt ] = 0 ; * in = 0 ; dfs ( rt ); gettop ( rt , rt ); } int querylca ( int u , int v ) { while ( top [ u ] != top [ v ]) { if ( deep [ top [ u ]] < deep [ top [ v ]]) { swap ( u , v ); } u = fa [ top [ u ]]; } if ( deep [ u ] > deep [ v ]) swap ( u , v ); return u ; } int querydis ( int u , int v ) { return dis [ u ] + dis [ v ] - 2 * dis [ querylca ( u , v )]; } void updatePath ( int u , int v , ll x ) { while ( top [ u ] != top [ v ]) { if ( deep [ top [ u ]] < deep [ top [ v ]]) swap ( u , v ); bit . add ( in [ top [ u ]], in [ u ], x ); u = fa [ top [ u ]]; } if ( deep [ u ] > deep [ v ]) swap ( u , v ); bit . add ( in [ u ], in [ v ], x ); } ll queryPath ( int u , int v ) { ll res = 0 ; while ( top [ u ] != top [ v ]) { if ( deep [ top [ u ]] < deep [ top [ v ]]) swap ( u , v ); res += bit . ask ( in [ top [ u ]], in [ u ]); u = fa [ top [ u ]]; } if ( deep [ u ] > deep [ v ]) swap ( u , v ); res += bit . ask ( in [ u ], in [ v ]); return res ; } bool inSubTree ( int u , int v ) { return in [ v ] >= in [ u ] && in [ v ] <= out [ u ]; } } hld ; struct E { int u , v , dis ; E () {} } e [ N ]; bool ok ( int a1 , int b1 , int a2 , int b2 ) { int t [] = { hld . querylca ( a1 , a2 ), hld . querylca ( a1 , b2 ), hld . querylca ( b1 , a2 ), hld . querylca ( b1 , b2 )}; sort ( t , t + 4 , [ & ]( int a , int b ) { return hld . deep [ a ] < hld . deep [ b ]; }); int d [] = { hld . querylca ( a1 , b1 ), hld . querylca ( a2 , b2 )}; sort ( d , d + 2 , [ & ]( int a , int b ) { return hld . deep [ a ] < hld . deep [ b ]; }); if ( hld . deep [ t [ 3 ]] >= hld . deep [ t [ 2 ]] && hld . deep [ t [ 2 ]] >= hld . deep [ d [ 1 ]]) { int _a = t [ 2 ], _b = t [ 3 ]; if ( _a > _b ) swap ( _a , _b ); if ( a2 > b2 ) swap ( a2 , b2 ); // dbg(_a, _b); return _a == a2 && _b == b2 ; } else { return false ; } } void run () { rd ( n , m ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v ; i < n ; ++ i ) { rd ( u , v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } bit . init (); hld . init ( 1 ); // ok(1, 4, 2, 3); // dbg(\"vv\"); // return; for ( int i = 1 ; i <= m ; ++ i ) { rd ( e [ i ]. u , e [ i ]. v ); e [ i ]. dis = hld . querydis ( e [ i ]. u , e [ i ]. v ) + 1 ; // dbg(e[i].u, e[i].v, e[i].dis); } sort ( e + 1 , e + 1 + m , [ & ]( E a , E b ) { return a . dis > b . dis ; }); // return; int _ok = 1 ; for ( int i = 1 ; i <= m ; ++ i ) { // dbg(i); int u = e [ i ]. u , v = e [ i ]. v , dis = e [ i ]. dis ; ll x = hld . queryPath ( u , v ); // dbg(u, v, x, dis); if ( x == 0 ) { hld . updatePath ( u , v , i ); } else { if ( x % dis == 0 ) { ll y = x / dis ; if ( ! ok ( e [ y ]. u , e [ y ]. v , u , v )) { _ok = 0 ; break ; } else { hld . updatePath ( u , v , - y ); hld . updatePath ( u , v , i ); } } else { _ok = 0 ; break ; } } } pt ( _ok ? \"Yes\" : \"No\" ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem B. Abbreviation Solved By Dup4. 00:49(+) \u9898\u610f \u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u7ed9\u8fde\u7eed\u7684\u53ea\u88ab\u4e00\u4e2a\u7a7a\u683c\u95f4\u9694\u7684\u5e76\u4e14\u9996\u5b57\u6bcd\u5927\u5199\u7684\u5355\u8bcd\u8fde\u6210\u7684\u77ed\u8bed\u52a0\u4e0a\u7f29\u5199\u3002 \u601d\u8def \u6a21\u62df\u5c31\u5b8c\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; using pSI = pair < string , int > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head string s ; bool valid ( string s ) { if ( SZ ( s ) < 2 ) return false ; if ( ! isupper ( s [ 0 ])) return false ; for ( int i = 1 ; i < SZ ( s ); ++ i ) { if ( ! islower ( s [ i ])) return false ; } return true ; } int charType ( char ch ) { if ( isalpha ( ch )) return 1 ; return 0 ; } string work ( string s ) { string tmp = \"\" ; for ( auto & ch : s ) { if ( isupper ( ch )) tmp += ch ; } if ( SZ ( tmp ) < 2 ) return s ; string res = tmp ; tmp += \" (\" ; tmp += s ; tmp += \")\" ; return tmp ; } void run () { vector < string > vec ; string t = \"\" ; for ( auto & ch : s ) { if ( t . empty ()) t += ch ; else { if ( charType ( ch ) == charType ( t . back ())) t += ch ; else { vec . push_back ( t ); t . clear (); t += ch ; } } } if ( ! t . empty ()) vec . push_back ( t ); vector < pSI > _vec ; for ( int i = 0 ; i < SZ ( vec ); ++ i ) { string ss = vec [ i ]; if ( _vec . empty ()) _vec . push_back ( pSI ( ss , valid ( ss ))); else { if ( _vec . back (). se == 1 && SZ ( ss ) == 1 && ss [ 0 ] == ' ' && i + 1 < SZ ( vec ) && valid ( vec [ i + 1 ])) { _vec . back (). fi += ss ; _vec . back (). fi += vec [ i + 1 ]; i += 1 ; } else { _vec . push_back ( pSI ( ss , valid ( ss ))); } } } string res = \"\" ; for ( auto & it : _vec ) { if ( it . se == 0 ) res += it . fi ; else res += work ( it . fi ); } cout << res << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); while ( getline ( cin , s )) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem C. Expect to Wait Solved By Dup4. 02:03(+1) \u9898\u610f \u7ed9\u51fa n n \u79cd\u64cd\u4f5c\uff1a + t k , \u8868\u793a\u5728\u7b2c t t \u65f6\u523b\u52a0\u5165 k k \u8f86\u8f66\u3002 - t k , \u8868\u793a\u5728\u7b2c t t \u65f6\u523b\u6709 K K \u4e2a\u7528\u8f66\u9700\u6c42\u3002 \u6709 q q \u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee\u8868\u793a\u5047\u5982\u52a0\u5165\u64cd\u4f5c + 0 a , \u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e2a\u7528\u8f66\u9700\u6c42\u603b\u5171\u7684\u7b49\u5f85\u65f6\u95f4\u662f\u591a\u5c11\uff1f \u601d\u8def \u5c06\u65f6\u95f4\u62c6\u6210 n n \u6bb5\uff0c\u7b2c i i \u6bb5\u4e3a t_i - t_{i - 1} t_i - t_{i - 1} \u3002 \u90a3\u4e48\u8003\u8651\u5728\u7b2c i i \u4e2a\u64cd\u4f5c\u79cd\u52a0\u5165\u4e00\u8f86\u8f66\uff0c\u5176\u5b9e\u5c31\u662f\u5728\u7b2c [i + 1, n] [i + 1, n] \u7684\u65f6\u95f4\u6bb5\u91cc\u51cf\u4e00\u3002 \u5728\u7b2c i i \u4e2a\u64cd\u4f5c\u4e2d\u6709\u4e00\u4e2a\u7528\u8f66\u9700\u6c42\uff0c\u5c31\u662f\u5728\u7b2c [i + 1, n] [i + 1, n] \u7684\u65f6\u95f4\u6bb5\u91cc\u52a0\u4e00\u3002 \u5bf9\u4e8e q q \u6b21\u8be2\u95ee\uff0c\u5c06\u8be2\u95ee\u6309 a_i a_i \u6392\u5e8f\uff0c\u6bcf\u6b21\u5254\u9664\u65f6\u95f4\u6bb5\u5185\u6743\u503c\u5c0f\u4e8e\u7b49\u4e8e 0 0 \u7684\u90a3\u4e9b\u6bb5\u5373\u53ef\uff0c\u5269\u4e0b\u7684\u6ca1\u88ab\u5254\u9664\u7684\u603b\u548c\u5c31\u662f\u7b54\u6848\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , q , t [ N ], k [ N ]; pII qnode [ N ]; ll ans [ N ]; struct BIT { ll a [ N ]; void init () { memset ( a , 0 , sizeof a ); } void update ( int x , ll v ) { for (; x < N ; x += x & - x ) a [ x ] += v ; } ll query ( int x ) { ll res = 0 ; for (; x > 0 ; x -= x & - x ) res += a [ x ]; return res ; } void update ( int l , int r , ll v ) { if ( l > r ) return ; update ( l , v ); update ( r + 1 , - v ); } } bit ; void run () { rd ( n , q ); t [ 0 ] = 0 ; int tot = 0 ; int has = 0 ; char op [ 5 ]; for ( int i = 1 ; i <= n ; ++ i ) { cin >> op ; rd ( t [ i ], k [ i ]); if ( * op == '-' ) bit . update ( i + 1 , n , k [ i ]), tot += k [ i ]; else bit . update ( i + 1 , n , - k [ i ]), has += k [ i ]; } for ( int i = 1 ; i <= q ; ++ i ) { rd ( qnode [ i ]. fi ); qnode [ i ]. se = i ; } priority_queue < pLL , vector < pLL > , greater < pLL >> pq ; ll res = 0 ; ll base = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { ll _x = bit . query ( i ); ll _t = t [ i ] - t [ i - 1 ]; res += _x * _t ; base += _t ; pq . push ( pLL ( _x , _t )); } sort ( qnode + 1 , qnode + 1 + q ); int now = 0 ; for ( int i = 1 ; i <= q ; ++ i ) { now = qnode [ i ]. fi ; int id = qnode [ i ]. se ; if ( has + now < tot ) ans [ id ] = -1 ; else { while ( ! pq . empty () && pq . top (). fi <= now ) { pLL top = pq . top (); pq . pop (); base -= top . se ; res -= top . fi * top . se ; } ans [ id ] = res - base * now ; } } for ( int i = 1 ; i <= q ; ++ i ) { if ( ans [ i ] == -1 ) pt ( \"INFINITY\" ); else pt ( ans [ i ]); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem D. Foreign Postcards Solved By Dup4. 03:31(+) \u9898\u610f \u7ed9\u51fa n n \u5f20\u6251\u514b\u724c\uff0c C \u8868\u793a\u7b2c i i \u5f20\u6251\u514b\u724c\u6b63\u9762\u671d\u4e0a\uff0c W \u8868\u793a\u53cd\u9762\u671d\u4e0a\u3002\u73b0\u5728\u5c06 n n \u5f20\u724c\u5165\u6808\uff0c\u5e76\u6267\u884c\u4ee5\u4e0b\u6d41\u7a0b\uff1a \u4ee4\u5f53\u524d\u6808\u7684\u5927\u5c0f\u4e3a n n \uff0c\u9996\u5148\u5728 [1, n] [1, n] \u4e2d\u968f\u673a\u4e00\u4e2a\u6570 k k \u3002 \u7136\u540e\u4ece\u6808\u4e2d\u53d6\u51fa k k \u5f20\u724c\uff0c\u5982\u679c\u53d6\u51fa\u7684\u7b2c\u4e00\u5f20\u724c\u662f W \uff0c\u90a3\u4e48\u5c06\u53d6\u51fa\u7684\u6240\u6709\u724c\u90fd\u7ffb\u4e00\u4e2a\u9762\u3002 \u5faa\u73af\u4e0a\u8ff0\u6d41\u7a0b\uff0c\u76f4\u5230\u6808\u7a7a\u3002 \u95ee\u6d41\u7a0b\u7ed3\u675f\u540e\uff0c\u53cd\u9762\u671d\u4e0a\u7684\u724c\u7684\u4e2a\u6570\u7684\u671f\u671b\u662f\u591a\u5c11\uff1f \u601d\u8def \u4ee4 f_i f_i \u8868\u793a\u6808\u5e95\u5f80\u4e0a i i \u5f20\u724c\u7684\u671f\u671b\u662f\u591a\u5c11\u3002 \u7136\u540e\u5bf9\u4e8e\u5f53\u524d i i \uff0c\u6211\u4eec\u90fd\u8981\u4ece f_j(j \\leq i) f_j(j \\leq i) \u8f6c\u79fb\u8fc7\u6765\u3002\u5e76\u4e14\u6839\u636e\u5f53\u524d\u7b2c i i \u5f20\u724c\u7684\u72b6\u6001\u51b3\u5b9a\u52a0\u4e0a\u7684\u8d21\u732e\u662f\u533a\u95f4\u5185 W \u7684\u724c\u8fd8\u662f C \u7684\u724c\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = long double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e6 + 10 ; db f [ N ], _f [ N ]; char s [ N ]; int n , c [ N ], w [ N ]; void run () { cin >> ( s + 1 ); n = strlen ( s + 1 ); _f [ 0 ] = 0 ; c [ 0 ] = w [ 0 ] = 0 ; ll _c = 0 , _w = 0 ; reverse ( s + 1 , s + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) { c [ i ] = c [ i - 1 ] + ( s [ i ] == 'C' ); w [ i ] = w [ i - 1 ] + ( s [ i ] == 'W' ); _c += c [ i - 1 ]; _w += w [ i - 1 ]; if ( s [ i ] == 'C' ) { f [ i ] = ( 1l l * w [ i ] * i - _w + _f [ i - 1 ]) * 1.0 / i ; } else { f [ i ] = ( 1l l * c [ i ] * i - _c + _f [ i - 1 ]) * 1.0 / i ; } // f[i] = (1ll * c[i] * num_c + 1ll * w[i] * num_w - _c - _w + _f[i - 1]) * 1.0 / i; _f [ i ] = _f [ i - 1 ] + f [ i ]; } pt ( f [ n ]); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem E. Game on Graph Upsolved By -. \u9898\u610f \u601d\u8def Problem F. Jenga Boom Upsolved By -. \u9898\u610f \u601d\u8def Problem G. List of Primes Upsolved By -. \u9898\u610f \u601d\u8def Problem H. Mole Tunnels Upsolved By -. \u9898\u610f \u601d\u8def Problem I. Bowlstack Upsolved By -. \u9898\u610f \u601d\u8def Problem J. Adjustment Office Solved By Dup4. 00:11(+) \u9898\u610f \u7ed9\u51fa\u4e00\u4e2a n \\cdot n n \\cdot n \u7684\u77e9\u9635\uff0c\u5176\u4e2d a_{i, j} = i + j a_{i, j} = i + j \uff0c\u6709\u4e24\u79cd\u64cd\u4f5c\uff1a R r \uff0c\u8868\u793a\u8f93\u51fa\u77e9\u9635\u4e2d\u7b2c r r \u884c\u7684\u6570\u7684\u548c\uff0c\u5e76\u4e14\u5c06\u8fd9\u884c\u6570\u90fd\u53d8\u6210 0 0 \u3002 C c , \u8868\u793a\u8f93\u51fa\u77e9\u9635\u4e2d\u7b2c c c \u5217\u7684\u6570\u7684\u548c\uff0c\u5e76\u4e14\u5c06\u8fd9\u5217\u6570\u90fd\u53d8\u6210 0 0 \u3002 \u601d\u8def \u4ee5\u884c\u4e3a\u4f8b\uff0c\u5bf9\u4e8e\u5f53\u524d\u884c\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053\u8fd9\u4e00\u884c\u6709\u591a\u5c11\u5217\u6ca1\u88ab\u6e05 0 0 \uff0c\u4ee5\u53ca\u6ca1\u88ab\u6e05 0 0 \u7684\u884c\u7684\u6570\u7684\u548c\u5373\u53ef\u3002 \u7528\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u884c\u4fe1\u606f\u4ee5\u53ca\u5217\u4fe1\u606f\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e6 + 10 ; int n , q , f [ 2 ][ N ]; struct BIT { ll a [ N ]; void init () { memset ( a , 0 , sizeof a ); } void update ( int x , ll v ) { for (; x < N ; x += x & - x ) { a [ x ] += v ; } } ll query ( int x ) { ll res = 0 ; for (; x > 0 ; x -= x & - x ) res += a [ x ]; return res ; } ll query ( int l , int r ) { if ( l > r ) return 0 ; return query ( r ) - query ( l - 1 ); } } g [ 2 ], h [ 2 ]; void run () { rd ( n , q ); g [ 0 ]. init (); g [ 1 ]. init (); h [ 0 ]. init (); h [ 1 ]. init (); memset ( f , 0 , sizeof f ); for ( int i = 1 ; i <= n ; ++ i ) { g [ 0 ]. update ( i , 1 ); h [ 0 ]. update ( i , i ); g [ 1 ]. update ( i , 1 ); h [ 1 ]. update ( i , i ); } char op [ 5 ]; for ( int i = 1 , x ; i <= q ; ++ i ) { cin >> op ; rd ( x ); if ( * op == 'R' ) { if ( f [ 0 ][ x ]) pt ( 0 ); else { ll res = 1l l * x * g [ 1 ]. query ( 1 , n ) + h [ 1 ]. query ( 1 , n ); pt ( res ); g [ 0 ]. update ( x , -1 ); h [ 0 ]. update ( x , - x ); } f [ 0 ][ x ] = 1 ; } else { if ( f [ 1 ][ x ]) pt ( 0 ); else { ll res = 1l l * x * g [ 0 ]. query ( 1 , n ) + h [ 0 ]. query ( 1 , n ); pt ( res ); g [ 1 ]. update ( x , -1 ); h [ 1 ]. update ( x , - x ); } f [ 1 ][ x ] = 1 ; } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem K. Binary vs Decimal Upsolved By -. \u9898\u610f \u601d\u8def","title":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day7"},{"location":"2020/nowcoder-national-day-training-party/day7/#contest-info","text":"Practice Link Solved A B C D E F G H I J K 5/11 O O O O - - - - - O - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"2020/nowcoder-national-day-training-party/day7/#solutions","text":"","title":"Solutions"},{"location":"2020/nowcoder-national-day-training-party/day7/#problem-a-laminar-family","text":"Solved By Dup4. 04:28(+1)","title":"Problem A. Laminar Family"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u9898\u610f","text":"\u7ed9\u51fa\u4e00\u68f5 n n \u4e2a\u70b9\u7684\u6811\uff0c\u4ee5\u53ca m m \u6761\u7b80\u5355\u8def\u5f84 (a_i, b_i) (a_i, b_i) \uff0c\u95ee\u8fd9 m m \u6761\u7b80\u5355\u8def\u5f84\u662f\u5426\u4e24\u4e24\u4e0d\u76f8\u4ea4\u6216\u8005\u5904\u4e8e\u5305\u542b\u5173\u7cfb\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u601d\u8def","text":"\u6309\u8def\u5f84\u957f\u5ea6\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\u3002 \u5bf9\u4e8e\u7b2c i i \u6bb5\u7b80\u5355\u8def\u5f84\uff0c\u6211\u4eec\u5728\u7ebf\u6bb5\u6811\u4e0a\u5c06\u8fd9\u8fd9\u6bb5\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u6743\u503c\u8d4b\u6210 i i \u3002 \u7136\u540e\u5bf9\u4e8e\u5f53\u524d\u8def\u5f84 (a_i, b_i) (a_i, b_i) \uff0c\u6211\u4eec\u5728\u7ebf\u6bb5\u6811\u4e0a\u67e5\u8be2\u8fd9\u6bb5\u8def\u5f84\u7684\u70b9\u6743\u548c\uff0c\u5047\u8bbe\u4e3a y y \uff0c\u8be5\u8def\u5f84\u4e0a\u7684\u70b9\u6570\u4e3a x x \uff0c\u90a3\u4e48\u6211\u4eec\u77e5\u9053\u5982\u679c\u8fd9\u6bb5\u7b80\u5355\u8def\u5f84\u5c5e\u4e8e\u4e4b\u524d\u7684\u67d0\u6bb5\u8def\u5f84\uff0c\u800c\u4e0d\u662f\u62fc\u51d1\u6210\u7684\uff0c\u90a3\u4e48\u80af\u5b9a\u5c5e\u4e8e\u7b2c \\displaystyle \\frac{y}{x} \\displaystyle \\frac{y}{x} \u6761\u8def\u5f84\u3002 \u53ef\u4ee5\u989d\u5916\u5224\u65ad\u7b2c \\displaystyle \\frac{y}{x} \\displaystyle \\frac{y}{x} \u6761\u8def\u5f84\u662f\u5426\u5305\u542b \u7b2c i i \u6761\u8def\u5f84\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m ; vector < vector < int >> G ; struct BIT_2D { struct BIT { ll a [ N ]; void init () { memset ( a , 0 , sizeof a ); } void add ( int x , ll v ) { for (; x < N ; a [ x ] += v , x += x & - x ) ; } ll ask ( int x ) { ll res = 0 ; for (; x > 0 ; res += a [ x ], x -= x & - x ) ; return res ; } } bit1 , bit2 ; void init () { bit1 . init (); bit2 . init (); } ll ask ( int x ) { return ( x + 1 ) * bit1 . ask ( x ) - bit2 . ask ( x ); } void add ( int x , ll v ) { bit1 . add ( x , v ); bit2 . add ( x , x * v ); } ll ask ( int l , int r ) { return ask ( r ) - ask ( l - 1 ); } void add ( int l , int r , ll v ) { add ( l , v ); add ( r + 1 , - v ); } } bit ; struct HLD { int fa [ N ], deep [ N ], dis [ N ], sze [ N ], son [ N ], top [ N ], in [ N ], fin [ N ], out [ N ]; void dfs ( int u ) { sze [ u ] = 1 ; son [ u ] = 0 ; for ( auto & v : G [ u ]) { if ( v == fa [ u ]) continue ; fa [ v ] = u ; deep [ v ] = deep [ u ] + 1 ; dis [ v ] = dis [ u ] + 1 ; dfs ( v ); sze [ u ] += sze [ v ]; if ( ! son [ u ] || sze [ v ] > sze [ son [ u ]]) son [ u ] = v ; } } void gettop ( int u , int tp ) { in [ u ] = ++* in ; fin [ * in ] = u ; top [ u ] = tp ; if ( son [ u ]) gettop ( son [ u ], tp ); for ( auto & v : G [ u ]) { if ( v == son [ u ] || v == fa [ u ]) continue ; gettop ( v , v ); } out [ u ] = * in ; } void init ( int rt ) { fa [ rt ] = rt ; dis [ rt ] = 0 ; * in = 0 ; dfs ( rt ); gettop ( rt , rt ); } int querylca ( int u , int v ) { while ( top [ u ] != top [ v ]) { if ( deep [ top [ u ]] < deep [ top [ v ]]) { swap ( u , v ); } u = fa [ top [ u ]]; } if ( deep [ u ] > deep [ v ]) swap ( u , v ); return u ; } int querydis ( int u , int v ) { return dis [ u ] + dis [ v ] - 2 * dis [ querylca ( u , v )]; } void updatePath ( int u , int v , ll x ) { while ( top [ u ] != top [ v ]) { if ( deep [ top [ u ]] < deep [ top [ v ]]) swap ( u , v ); bit . add ( in [ top [ u ]], in [ u ], x ); u = fa [ top [ u ]]; } if ( deep [ u ] > deep [ v ]) swap ( u , v ); bit . add ( in [ u ], in [ v ], x ); } ll queryPath ( int u , int v ) { ll res = 0 ; while ( top [ u ] != top [ v ]) { if ( deep [ top [ u ]] < deep [ top [ v ]]) swap ( u , v ); res += bit . ask ( in [ top [ u ]], in [ u ]); u = fa [ top [ u ]]; } if ( deep [ u ] > deep [ v ]) swap ( u , v ); res += bit . ask ( in [ u ], in [ v ]); return res ; } bool inSubTree ( int u , int v ) { return in [ v ] >= in [ u ] && in [ v ] <= out [ u ]; } } hld ; struct E { int u , v , dis ; E () {} } e [ N ]; bool ok ( int a1 , int b1 , int a2 , int b2 ) { int t [] = { hld . querylca ( a1 , a2 ), hld . querylca ( a1 , b2 ), hld . querylca ( b1 , a2 ), hld . querylca ( b1 , b2 )}; sort ( t , t + 4 , [ & ]( int a , int b ) { return hld . deep [ a ] < hld . deep [ b ]; }); int d [] = { hld . querylca ( a1 , b1 ), hld . querylca ( a2 , b2 )}; sort ( d , d + 2 , [ & ]( int a , int b ) { return hld . deep [ a ] < hld . deep [ b ]; }); if ( hld . deep [ t [ 3 ]] >= hld . deep [ t [ 2 ]] && hld . deep [ t [ 2 ]] >= hld . deep [ d [ 1 ]]) { int _a = t [ 2 ], _b = t [ 3 ]; if ( _a > _b ) swap ( _a , _b ); if ( a2 > b2 ) swap ( a2 , b2 ); // dbg(_a, _b); return _a == a2 && _b == b2 ; } else { return false ; } } void run () { rd ( n , m ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v ; i < n ; ++ i ) { rd ( u , v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } bit . init (); hld . init ( 1 ); // ok(1, 4, 2, 3); // dbg(\"vv\"); // return; for ( int i = 1 ; i <= m ; ++ i ) { rd ( e [ i ]. u , e [ i ]. v ); e [ i ]. dis = hld . querydis ( e [ i ]. u , e [ i ]. v ) + 1 ; // dbg(e[i].u, e[i].v, e[i].dis); } sort ( e + 1 , e + 1 + m , [ & ]( E a , E b ) { return a . dis > b . dis ; }); // return; int _ok = 1 ; for ( int i = 1 ; i <= m ; ++ i ) { // dbg(i); int u = e [ i ]. u , v = e [ i ]. v , dis = e [ i ]. dis ; ll x = hld . queryPath ( u , v ); // dbg(u, v, x, dis); if ( x == 0 ) { hld . updatePath ( u , v , i ); } else { if ( x % dis == 0 ) { ll y = x / dis ; if ( ! ok ( e [ y ]. u , e [ y ]. v , u , v )) { _ok = 0 ; break ; } else { hld . updatePath ( u , v , - y ); hld . updatePath ( u , v , i ); } } else { _ok = 0 ; break ; } } } pt ( _ok ? \"Yes\" : \"No\" ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day7/#problem-b-abbreviation","text":"Solved By Dup4. 00:49(+)","title":"Problem B. Abbreviation"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u9898\u610f_1","text":"\u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u7ed9\u8fde\u7eed\u7684\u53ea\u88ab\u4e00\u4e2a\u7a7a\u683c\u95f4\u9694\u7684\u5e76\u4e14\u9996\u5b57\u6bcd\u5927\u5199\u7684\u5355\u8bcd\u8fde\u6210\u7684\u77ed\u8bed\u52a0\u4e0a\u7f29\u5199\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u601d\u8def_1","text":"\u6a21\u62df\u5c31\u5b8c\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; using pSI = pair < string , int > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head string s ; bool valid ( string s ) { if ( SZ ( s ) < 2 ) return false ; if ( ! isupper ( s [ 0 ])) return false ; for ( int i = 1 ; i < SZ ( s ); ++ i ) { if ( ! islower ( s [ i ])) return false ; } return true ; } int charType ( char ch ) { if ( isalpha ( ch )) return 1 ; return 0 ; } string work ( string s ) { string tmp = \"\" ; for ( auto & ch : s ) { if ( isupper ( ch )) tmp += ch ; } if ( SZ ( tmp ) < 2 ) return s ; string res = tmp ; tmp += \" (\" ; tmp += s ; tmp += \")\" ; return tmp ; } void run () { vector < string > vec ; string t = \"\" ; for ( auto & ch : s ) { if ( t . empty ()) t += ch ; else { if ( charType ( ch ) == charType ( t . back ())) t += ch ; else { vec . push_back ( t ); t . clear (); t += ch ; } } } if ( ! t . empty ()) vec . push_back ( t ); vector < pSI > _vec ; for ( int i = 0 ; i < SZ ( vec ); ++ i ) { string ss = vec [ i ]; if ( _vec . empty ()) _vec . push_back ( pSI ( ss , valid ( ss ))); else { if ( _vec . back (). se == 1 && SZ ( ss ) == 1 && ss [ 0 ] == ' ' && i + 1 < SZ ( vec ) && valid ( vec [ i + 1 ])) { _vec . back (). fi += ss ; _vec . back (). fi += vec [ i + 1 ]; i += 1 ; } else { _vec . push_back ( pSI ( ss , valid ( ss ))); } } } string res = \"\" ; for ( auto & it : _vec ) { if ( it . se == 0 ) res += it . fi ; else res += work ( it . fi ); } cout << res << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); while ( getline ( cin , s )) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day7/#problem-c-expect-to-wait","text":"Solved By Dup4. 02:03(+1)","title":"Problem C. Expect to Wait"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u9898\u610f_2","text":"\u7ed9\u51fa n n \u79cd\u64cd\u4f5c\uff1a + t k , \u8868\u793a\u5728\u7b2c t t \u65f6\u523b\u52a0\u5165 k k \u8f86\u8f66\u3002 - t k , \u8868\u793a\u5728\u7b2c t t \u65f6\u523b\u6709 K K \u4e2a\u7528\u8f66\u9700\u6c42\u3002 \u6709 q q \u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee\u8868\u793a\u5047\u5982\u52a0\u5165\u64cd\u4f5c + 0 a , \u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e2a\u7528\u8f66\u9700\u6c42\u603b\u5171\u7684\u7b49\u5f85\u65f6\u95f4\u662f\u591a\u5c11\uff1f","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u601d\u8def_2","text":"\u5c06\u65f6\u95f4\u62c6\u6210 n n \u6bb5\uff0c\u7b2c i i \u6bb5\u4e3a t_i - t_{i - 1} t_i - t_{i - 1} \u3002 \u90a3\u4e48\u8003\u8651\u5728\u7b2c i i \u4e2a\u64cd\u4f5c\u79cd\u52a0\u5165\u4e00\u8f86\u8f66\uff0c\u5176\u5b9e\u5c31\u662f\u5728\u7b2c [i + 1, n] [i + 1, n] \u7684\u65f6\u95f4\u6bb5\u91cc\u51cf\u4e00\u3002 \u5728\u7b2c i i \u4e2a\u64cd\u4f5c\u4e2d\u6709\u4e00\u4e2a\u7528\u8f66\u9700\u6c42\uff0c\u5c31\u662f\u5728\u7b2c [i + 1, n] [i + 1, n] \u7684\u65f6\u95f4\u6bb5\u91cc\u52a0\u4e00\u3002 \u5bf9\u4e8e q q \u6b21\u8be2\u95ee\uff0c\u5c06\u8be2\u95ee\u6309 a_i a_i \u6392\u5e8f\uff0c\u6bcf\u6b21\u5254\u9664\u65f6\u95f4\u6bb5\u5185\u6743\u503c\u5c0f\u4e8e\u7b49\u4e8e 0 0 \u7684\u90a3\u4e9b\u6bb5\u5373\u53ef\uff0c\u5269\u4e0b\u7684\u6ca1\u88ab\u5254\u9664\u7684\u603b\u548c\u5c31\u662f\u7b54\u6848\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , q , t [ N ], k [ N ]; pII qnode [ N ]; ll ans [ N ]; struct BIT { ll a [ N ]; void init () { memset ( a , 0 , sizeof a ); } void update ( int x , ll v ) { for (; x < N ; x += x & - x ) a [ x ] += v ; } ll query ( int x ) { ll res = 0 ; for (; x > 0 ; x -= x & - x ) res += a [ x ]; return res ; } void update ( int l , int r , ll v ) { if ( l > r ) return ; update ( l , v ); update ( r + 1 , - v ); } } bit ; void run () { rd ( n , q ); t [ 0 ] = 0 ; int tot = 0 ; int has = 0 ; char op [ 5 ]; for ( int i = 1 ; i <= n ; ++ i ) { cin >> op ; rd ( t [ i ], k [ i ]); if ( * op == '-' ) bit . update ( i + 1 , n , k [ i ]), tot += k [ i ]; else bit . update ( i + 1 , n , - k [ i ]), has += k [ i ]; } for ( int i = 1 ; i <= q ; ++ i ) { rd ( qnode [ i ]. fi ); qnode [ i ]. se = i ; } priority_queue < pLL , vector < pLL > , greater < pLL >> pq ; ll res = 0 ; ll base = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { ll _x = bit . query ( i ); ll _t = t [ i ] - t [ i - 1 ]; res += _x * _t ; base += _t ; pq . push ( pLL ( _x , _t )); } sort ( qnode + 1 , qnode + 1 + q ); int now = 0 ; for ( int i = 1 ; i <= q ; ++ i ) { now = qnode [ i ]. fi ; int id = qnode [ i ]. se ; if ( has + now < tot ) ans [ id ] = -1 ; else { while ( ! pq . empty () && pq . top (). fi <= now ) { pLL top = pq . top (); pq . pop (); base -= top . se ; res -= top . fi * top . se ; } ans [ id ] = res - base * now ; } } for ( int i = 1 ; i <= q ; ++ i ) { if ( ans [ i ] == -1 ) pt ( \"INFINITY\" ); else pt ( ans [ i ]); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day7/#problem-d-foreign-postcards","text":"Solved By Dup4. 03:31(+)","title":"Problem D. Foreign Postcards"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u9898\u610f_3","text":"\u7ed9\u51fa n n \u5f20\u6251\u514b\u724c\uff0c C \u8868\u793a\u7b2c i i \u5f20\u6251\u514b\u724c\u6b63\u9762\u671d\u4e0a\uff0c W \u8868\u793a\u53cd\u9762\u671d\u4e0a\u3002\u73b0\u5728\u5c06 n n \u5f20\u724c\u5165\u6808\uff0c\u5e76\u6267\u884c\u4ee5\u4e0b\u6d41\u7a0b\uff1a \u4ee4\u5f53\u524d\u6808\u7684\u5927\u5c0f\u4e3a n n \uff0c\u9996\u5148\u5728 [1, n] [1, n] \u4e2d\u968f\u673a\u4e00\u4e2a\u6570 k k \u3002 \u7136\u540e\u4ece\u6808\u4e2d\u53d6\u51fa k k \u5f20\u724c\uff0c\u5982\u679c\u53d6\u51fa\u7684\u7b2c\u4e00\u5f20\u724c\u662f W \uff0c\u90a3\u4e48\u5c06\u53d6\u51fa\u7684\u6240\u6709\u724c\u90fd\u7ffb\u4e00\u4e2a\u9762\u3002 \u5faa\u73af\u4e0a\u8ff0\u6d41\u7a0b\uff0c\u76f4\u5230\u6808\u7a7a\u3002 \u95ee\u6d41\u7a0b\u7ed3\u675f\u540e\uff0c\u53cd\u9762\u671d\u4e0a\u7684\u724c\u7684\u4e2a\u6570\u7684\u671f\u671b\u662f\u591a\u5c11\uff1f","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u601d\u8def_3","text":"\u4ee4 f_i f_i \u8868\u793a\u6808\u5e95\u5f80\u4e0a i i \u5f20\u724c\u7684\u671f\u671b\u662f\u591a\u5c11\u3002 \u7136\u540e\u5bf9\u4e8e\u5f53\u524d i i \uff0c\u6211\u4eec\u90fd\u8981\u4ece f_j(j \\leq i) f_j(j \\leq i) \u8f6c\u79fb\u8fc7\u6765\u3002\u5e76\u4e14\u6839\u636e\u5f53\u524d\u7b2c i i \u5f20\u724c\u7684\u72b6\u6001\u51b3\u5b9a\u52a0\u4e0a\u7684\u8d21\u732e\u662f\u533a\u95f4\u5185 W \u7684\u724c\u8fd8\u662f C \u7684\u724c\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = long double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e6 + 10 ; db f [ N ], _f [ N ]; char s [ N ]; int n , c [ N ], w [ N ]; void run () { cin >> ( s + 1 ); n = strlen ( s + 1 ); _f [ 0 ] = 0 ; c [ 0 ] = w [ 0 ] = 0 ; ll _c = 0 , _w = 0 ; reverse ( s + 1 , s + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) { c [ i ] = c [ i - 1 ] + ( s [ i ] == 'C' ); w [ i ] = w [ i - 1 ] + ( s [ i ] == 'W' ); _c += c [ i - 1 ]; _w += w [ i - 1 ]; if ( s [ i ] == 'C' ) { f [ i ] = ( 1l l * w [ i ] * i - _w + _f [ i - 1 ]) * 1.0 / i ; } else { f [ i ] = ( 1l l * c [ i ] * i - _c + _f [ i - 1 ]) * 1.0 / i ; } // f[i] = (1ll * c[i] * num_c + 1ll * w[i] * num_w - _c - _w + _f[i - 1]) * 1.0 / i; _f [ i ] = _f [ i - 1 ] + f [ i ]; } pt ( f [ n ]); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day7/#problem-e-game-on-graph","text":"Upsolved By -.","title":"Problem E. Game on Graph"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u9898\u610f_4","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u601d\u8def_4","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day7/#problem-f-jenga-boom","text":"Upsolved By -.","title":"Problem F. Jenga Boom"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u9898\u610f_5","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u601d\u8def_5","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day7/#problem-g-list-of-primes","text":"Upsolved By -.","title":"Problem G. List of Primes"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u9898\u610f_6","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u601d\u8def_6","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day7/#problem-h-mole-tunnels","text":"Upsolved By -.","title":"Problem H. Mole Tunnels"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u9898\u610f_7","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u601d\u8def_7","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day7/#problem-i-bowlstack","text":"Upsolved By -.","title":"Problem I. Bowlstack"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u9898\u610f_8","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u601d\u8def_8","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day7/#problem-j-adjustment-office","text":"Solved By Dup4. 00:11(+)","title":"Problem J. Adjustment Office"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u9898\u610f_9","text":"\u7ed9\u51fa\u4e00\u4e2a n \\cdot n n \\cdot n \u7684\u77e9\u9635\uff0c\u5176\u4e2d a_{i, j} = i + j a_{i, j} = i + j \uff0c\u6709\u4e24\u79cd\u64cd\u4f5c\uff1a R r \uff0c\u8868\u793a\u8f93\u51fa\u77e9\u9635\u4e2d\u7b2c r r \u884c\u7684\u6570\u7684\u548c\uff0c\u5e76\u4e14\u5c06\u8fd9\u884c\u6570\u90fd\u53d8\u6210 0 0 \u3002 C c , \u8868\u793a\u8f93\u51fa\u77e9\u9635\u4e2d\u7b2c c c \u5217\u7684\u6570\u7684\u548c\uff0c\u5e76\u4e14\u5c06\u8fd9\u5217\u6570\u90fd\u53d8\u6210 0 0 \u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u601d\u8def_9","text":"\u4ee5\u884c\u4e3a\u4f8b\uff0c\u5bf9\u4e8e\u5f53\u524d\u884c\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053\u8fd9\u4e00\u884c\u6709\u591a\u5c11\u5217\u6ca1\u88ab\u6e05 0 0 \uff0c\u4ee5\u53ca\u6ca1\u88ab\u6e05 0 0 \u7684\u884c\u7684\u6570\u7684\u548c\u5373\u53ef\u3002 \u7528\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u884c\u4fe1\u606f\u4ee5\u53ca\u5217\u4fe1\u606f\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e6 + 10 ; int n , q , f [ 2 ][ N ]; struct BIT { ll a [ N ]; void init () { memset ( a , 0 , sizeof a ); } void update ( int x , ll v ) { for (; x < N ; x += x & - x ) { a [ x ] += v ; } } ll query ( int x ) { ll res = 0 ; for (; x > 0 ; x -= x & - x ) res += a [ x ]; return res ; } ll query ( int l , int r ) { if ( l > r ) return 0 ; return query ( r ) - query ( l - 1 ); } } g [ 2 ], h [ 2 ]; void run () { rd ( n , q ); g [ 0 ]. init (); g [ 1 ]. init (); h [ 0 ]. init (); h [ 1 ]. init (); memset ( f , 0 , sizeof f ); for ( int i = 1 ; i <= n ; ++ i ) { g [ 0 ]. update ( i , 1 ); h [ 0 ]. update ( i , i ); g [ 1 ]. update ( i , 1 ); h [ 1 ]. update ( i , i ); } char op [ 5 ]; for ( int i = 1 , x ; i <= q ; ++ i ) { cin >> op ; rd ( x ); if ( * op == 'R' ) { if ( f [ 0 ][ x ]) pt ( 0 ); else { ll res = 1l l * x * g [ 1 ]. query ( 1 , n ) + h [ 1 ]. query ( 1 , n ); pt ( res ); g [ 0 ]. update ( x , -1 ); h [ 0 ]. update ( x , - x ); } f [ 0 ][ x ] = 1 ; } else { if ( f [ 1 ][ x ]) pt ( 0 ); else { ll res = 1l l * x * g [ 0 ]. query ( 1 , n ) + h [ 0 ]. query ( 1 , n ); pt ( res ); g [ 1 ]. update ( x , -1 ); h [ 1 ]. update ( x , - x ); } f [ 1 ][ x ] = 1 ; } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day7/#problem-k-binary-vs-decimal","text":"Upsolved By -.","title":"Problem K. Binary vs Decimal"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u9898\u610f_10","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day7/#\u601d\u8def_10","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day8/","text":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day8 Contents Contest Info Solutions Problem A. Easy Chess \u9898\u610f \u601d\u8def Problem B. Cactus Jubilee \u9898\u610f \u601d\u8def Problem C. Distance on Triangulation \u9898\u610f \u601d\u8def Problem D. PACM Team \u9898\u610f \u601d\u8def Problem E. Easy Problemset \u9898\u610f \u601d\u8def Problem F. Landscape Improved \u9898\u610f \u601d\u8def Problem G. Shuffle Cards \u9898\u610f \u601d\u8def Problem H. Damage Assessment \u9898\u610f \u601d\u8def Problem I. Filter \u9898\u610f \u601d\u8def Problem J. Diff-prime Pairs \u9898\u610f \u601d\u8def Problem K. Improvements \u9898\u610f \u601d\u8def Contest Info Practice Link Solved A B C D E F G H I J K 6/11 O - - O O O O - - O - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions Problem A. Easy Chess Solved By Dup4. 02:36(+2) \u9898\u610f \u7ed9\u51fa\u4e00\u4e2a 8 \\cdot 8 8 \\cdot 8 \u7684\u68cb\u76d8\uff0c\u8981\u6c42\u7ed9\u51fa a_1 a_1 \u5230 h_8 h_8 \u7684\u957f\u5ea6\u4e3a n n \u7684\u8def\u5f84\u3002 \u601d\u8def \u5206\u7c7b\u8ba8\u8bba\u4e00\u4e0b\uff0c\u7136\u540e\u7ed5\u6765\u7ed5\u53bb\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; char f [ 10 ]; void run () { rd ( n ); for ( int i = 0 ; i < 8 ; ++ i ) f [ i + 1 ] = 'a' + i ; vector < pII > vec ; if ( n <= 50 ) { vec . push_back ( pII ( 1 , 1 )); int x = 1 , y = 1 ; for ( int i = 1 ; i <= n - 2 ; ++ i ) { if ( x & 1 ) { ++ y ; if ( y == 8 ) { ++ x ; -- y ; } } else { -- y ; if ( y == 0 ) { ++ x ; ++ y ; } } vec . push_back ( pII ( x , y )); } // if (x == 8) --x; vec . push_back ( pII ( x , 8 )); vec . push_back ( pII ( 8 , 8 )); } else { for ( int i = 1 ; i <= 6 ; ++ i ) { if ( i & 1 ) { for ( int j = 1 ; j <= 8 ; ++ j ) vec . push_back ( pII ( i , j )); } else { for ( int j = 8 ; j >= 1 ; -- j ) vec . push_back ( pII ( i , j )); } } if ( n == 51 ) { vec . push_back ( pII ( 8 , 1 )); vec . push_back ( pII ( 8 , 2 )); vec . push_back ( pII ( 8 , 3 )); vec . push_back ( pII ( 8 , 8 )); } else { n -= 49 ; vec . push_back ( pII ( 7 , 1 )); vec . push_back ( pII ( 7 , 8 )); if ( n - 2 >= 6 ) { n -= 6 ; for ( int i = 7 ; i >= 2 ; -- i ) { vec . push_back ( pII ( 7 , i )); } n -= 1 ; vec . push_back ( pII ( 8 , 2 )); if ( n > 1 ) { n -= 1 ; vec . push_back ( pII ( 8 , 1 )); } for ( int i = 1 , j = 3 ; i < n ; ++ i , ++ j ) vec . push_back ( pII ( 8 , j )); vec . push_back ( pII ( 8 , 8 )); } else { int i = 7 ; for ( int j = n - 2 ; j ; -- i , -- j ) { vec . push_back ( pII ( 7 , i )); } vec . push_back ( pII ( 8 , i + 1 )); vec . push_back ( pII ( 8 , 8 )); } } } // dbg(SZ(vec)); for ( int i = 0 ; i < SZ ( vec ); ++ i ) { cout << f [ vec [ i ]. fi ] << vec [ i ]. se << \" \\n \" [ i == SZ ( vec ) - 1 ]; } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem B. Cactus Jubilee Upsolved By -. \u9898\u610f \u601d\u8def Problem C. Distance on Triangulation Upsolved By -. \u9898\u610f \u601d\u8def Problem D. PACM Team Solved By Dup4. 01:37(+1) \u9898\u610f \u7ed9\u51fa n n \u4e2a\u961f\u4f0d\uff0c\u6bcf\u4e2a\u961f\u4f0d\u6709\u56db\u79cd\u5c5e\u6027 p_i, a_i, c_i, m_i p_i, a_i, c_i, m_i \uff0c\u9009\u53d6\u4e00\u652f\u961f\u4f0d\u80fd\u591f\u83b7\u5f97 g_i g_i \u70b9\u5229\u76ca\u3002 \u73b0\u5728\u9009\u51fa\u82e5\u5e72\u652f\u961f\u4f0d\uff0c\u5e76\u4e14\u8981\u6c42 \\sum p_i \\leq P, \\sum a_i \\leq A, \\sum c_i \\leq C, \\sum m_i \\leq M \\sum p_i \\leq P, \\sum a_i \\leq A, \\sum c_i \\leq C, \\sum m_i \\leq M , \u5e76\u4e14\u5229\u76ca\u6700\u5927\u3002 1 \\leq n, p_i, a_i, c_i, m_i, P, A, C, M \\leq 36 1 \\leq n, p_i, a_i, c_i, m_i, P, A, C, M \\leq 36 \u3002 \u601d\u8def \u5206\u6210\u4e24\u6bb5\u679a\u4e3e\uff0c\u6bcf\u6bb5 18 18 \u4e2a\uff0c\u7136\u540e\u62fc\u63a5\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e2 + 10 ; int n , P , A , C , M ; int f [ 2 ][ 40 ][ 40 ][ 40 ][ 40 ], g [ 2 ][ 40 ][ 40 ][ 40 ][ 40 ]; struct E { int p , a , c , m , g ; E () {} void scan () { rd ( p , a , c , m , g ); } } e [ N ]; void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) e [ i ]. scan (); rd ( P , A , C , M ); memset ( f , 0 , sizeof f ); memset ( g , 0 , sizeof g ); pII ran [ 2 ] = { pII ( 1 , min ( 18 , n )), pII ( 19 , n )}; for ( int o = 0 ; o < 2 ; ++ o ) { int l = ran [ o ]. fi , r = ran [ o ]. se ; if ( l > r ) continue ; for ( int S = 1 ; S < 1 << 18 ; ++ S ) { int _P = 0 , _A = 0 , _C = 0 , _M = 0 , _G = 0 ; for ( int i = 0 ; i < r - l + 1 ; ++ i ) { if (( S >> i ) & 1 ) { int _i = l + i ; _P += e [ _i ]. p ; _A += e [ _i ]. a ; _C += e [ _i ]. c ; _M += e [ _i ]. m ; _G += e [ _i ]. g ; } } if ( _P <= P && _A <= A && _C <= C && _M <= M ) { if ( _G > f [ o ][ _P ][ _A ][ _C ][ _M ]) { f [ o ][ _P ][ _A ][ _C ][ _M ] = _G ; g [ o ][ _P ][ _A ][ _C ][ _M ] = S ; } } } for ( int i = 0 ; i <= 36 ; ++ i ) { for ( int j = 0 ; j <= 36 ; ++ j ) { for ( int k = 0 ; k <= 36 ; ++ k ) { for ( int l = 0 ; l <= 36 ; ++ l ) { if ( i && f [ o ][ i - 1 ][ j ][ k ][ l ] > f [ o ][ i ][ j ][ k ][ l ]) { f [ o ][ i ][ j ][ k ][ l ] = f [ o ][ i - 1 ][ j ][ k ][ l ]; g [ o ][ i ][ j ][ k ][ l ] = g [ o ][ i - 1 ][ j ][ k ][ l ]; } if ( j && f [ o ][ i ][ j - 1 ][ k ][ l ] > f [ o ][ i ][ j ][ k ][ l ]) { f [ o ][ i ][ j ][ k ][ l ] = f [ o ][ i ][ j - 1 ][ k ][ l ]; g [ o ][ i ][ j ][ k ][ l ] = g [ o ][ i ][ j - 1 ][ k ][ l ]; } if ( k && f [ o ][ i ][ j ][ k - 1 ][ l ] > f [ o ][ i ][ j ][ k ][ l ]) { f [ o ][ i ][ j ][ k ][ l ] = f [ o ][ i ][ j ][ k - 1 ][ l ]; g [ o ][ i ][ j ][ k ][ l ] = g [ o ][ i ][ j ][ k - 1 ][ l ]; } if ( l && f [ o ][ i ][ j ][ k ][ l - 1 ] > f [ o ][ i ][ j ][ k ][ l ]) { f [ o ][ i ][ j ][ k ][ l ] = f [ o ][ i ][ j ][ k ][ l - 1 ]; g [ o ][ i ][ j ][ k ][ l ] = g [ o ][ i ][ j ][ k ][ l - 1 ]; } } } } } } int res = 0 ; int S [ 2 ] = { 0 , 0 }; for ( int i = 0 ; i <= 36 ; ++ i ) { for ( int j = 0 ; j <= 36 ; ++ j ) { for ( int k = 0 ; k <= 36 ; ++ k ) { for ( int o = 0 ; o <= 36 ; ++ o ) { int _i = P - i , _j = A - j , _k = C - k , _o = M - o ; if ( _i >= 0 && _j >= 0 && _k >= 0 && _o >= 0 && f [ 0 ][ i ][ j ][ k ][ o ] + f [ 1 ][ _i ][ _j ][ _k ][ _o ] > res ) { res = f [ 0 ][ i ][ j ][ k ][ o ] + f [ 1 ][ _i ][ _j ][ _k ][ _o ]; S [ 0 ] = g [ 0 ][ i ][ j ][ k ][ o ]; S [ 1 ] = g [ 1 ][ _i ][ _j ][ _k ][ _o ]; } } } } } vector < int > res_vec ; for ( int i = 0 ; i < 2 ; ++ i ) { for ( int j = 0 ; j < 18 ; ++ j ) { if (( S [ i ] >> j ) & 1 ) { res_vec . push_back ( j + ran [ i ]. fi - 1 ); } } } pt ( SZ ( res_vec )); pt ( res_vec ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem E. Easy Problemset Solved By Dup4. 00:55(+) \u9898\u610f \u7ed9\u51fa\u4e00\u4e9b\u7b56\u7565\uff0c\u7136\u540e\u9009\u51fa\u82e5\u5e72\u4e2a\u9898\u76ee\uff0c\u6c42\u603b\u7684 hardness \u3002 \u601d\u8def \u7b7e\u5230\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , need ; vector < vector < int >> vec ; void run () { rd ( n , need ); vec . resize ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { vec [ i ]. resize ( nextInt ()); for ( auto & it : vec [ i ]) rd ( it ); } int res = 0 , pos = 0 ; while ( need ) { for ( int i = 1 ; need && i <= n ; ++ i ) { int x = 0 ; if ( pos < SZ ( vec [ i ])) { x = vec [ i ][ pos ]; } else { x = 50 ; } if ( x >= res || x == 50 ) { -- need ; res += x ; } } ++ pos ; } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem F. Landscape Improved Solved By Dup4. 03:21(+) \u9898\u610f \u7ed9\u51fa n n \u4e2a\u77e9\u5f62\uff0c\u5bbd\u5ea6\u4e3a\u4e00\u4e2a\u5355\u4f4d\u5bbd\u5ea6\uff0c\u9ad8\u5ea6\u4e3a h_i h_i \uff0c\u73b0\u5728\u80fd\u591f\u589e\u52a0\u67d0\u4e2a\u77e9\u5f62\u7684\u9ad8\u5ea6\uff0c\u80fd\u589e\u52a0\u7b2c i i \u4e2a\u77e9\u5f62\u7684\u9ad8\u5ea6\u81f3 x x \uff0c\u5f53\u4e14\u4ec5\u5f53\u7b2c i - 1 i - 1 \u4e2a\u77e9\u5f62\u548c\u7b2c i + 1 i + 1 \u4e2a\u77e9\u5f62\u7684\u9ad8\u5ea6\u5927\u4e8e\u7b49\u4e8e x - 1 x - 1 \u3002 \u73b0\u5728\u7ed9\u51fa m m \u4e2a\u7816\u5757\uff0c\u95ee\u6700\u9ad8\u7684\u77e9\u5f62\u6700\u591a\u80fd\u589e\u52a0\u5230\u591a\u9ad8\uff1f \u601d\u8def \u4e8c\u5206\u7b54\u6848\u3002 \u8003\u8651\u5bf9\u4e8e\u5f53\u524d\u7b2c i i \u4e2a\u77e9\u5f62\uff0c\u5982\u679c\u60f3\u8ba9\u5b83\u6210\u4e3a\u6700\u5927\u9ad8\u5ea6\uff0c\u5047\u8bbe\u4e3a x x \uff0c\u90a3\u4e48\u7b2c i + 1 i + 1 \u4e2a\u77e9\u5f62\u9ad8\u5ea6\u5e94\u8be5\u5927\u4e8e\u7b49\u4e8e x - 1 x - 1 \uff0c\u7b2c i + 2 i + 2 \u4e2a\u77e9\u5f62\u9ad8\u5ea6\u5e94\u8be5\u5927\u4e8e\u7b49\u4e8e x - 2 x - 2 \u3002 \u5bf9\u4e8e\u7b2c i + 1 i + 1 \u4e2a\u77e9\u5f62\uff0c\u5982\u679c\u60f3\u8ba9\u5b83\u6210\u4e3a\u6700\u5927\u9ad8\u5ea6\uff0c\u5047\u8bbe\u4e3a x x \uff0c\u90a3\u4e48\u8981\u7b2c i + 2 i + 2 \u4e2a\u77e9\u5f62\u9ad8\u5ea6\u5e94\u8be5\u5927\u4e8e\u7b49\u4e8e x - 1 x - 1 \uff0c\u7b2c i + 3 i + 3 \u4e2a\u77e9\u5f62\u9ad8\u5ea6\u5e94\u8be5\u5927\u4e8e\u7b49\u4e8e x - 3 x - 3 \u3002 \u6211\u4eec\u53d1\u73b0\uff0c\u6700\u9ad8\u77e9\u5f62\u53f3\u79fb\u7684\u8fc7\u7a0b\u4e2d\uff0c\u53f3\u8fb9\u90a3\u90e8\u5206\u77e9\u5f62\u6240\u9700\u7684\u9ad8\u5ea6\u4e5f\u5728\u9012\u589e\uff0c\u53ef\u4ee5\u7ebf\u6027\u7ef4\u62a4\u3002 \u5bf9\u4e8e\u5de6\u8fb9\u7684\u77e9\u5f62\uff0c\u56e0\u4e3a\u662f\u9012\u51cf\u7684\uff0c\u597d\u50cf\u4e0d\u592a\u597d\u5904\u7406\uff0c\u6211\u4eec\u5c06\u6570\u7ec4\u53cd\u8f6c\uff0c\u5b83\u5c31\u53d8\u6210\u4e86\u53f3\u8fb9\uff0c\u5904\u7406\u4e24\u904d\uff0c\u7136\u540e\u5408\u5e76\u8ba1\u7b97\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; constexpr ll INFLL = 0x3f3f3f3f3f3f3f3f ; int n ; ll has , f [ N ], g [ N ], a [ N ]; bool ok ( ll x ) { memset ( f , 0 , sizeof f ); memset ( g , 0 , sizeof g ); ll use = 0 ; int r = 2 ; for ( int i = 2 ; i < n ; ++ i ) { use += r - i ; while ( r < n && a [ r + 1 ] < x - ( r + 1 - i )) { use += x - ( r + 1 - i ) - a [ r + 1 ]; ++ r ; } if ( r == n && a [ r ] < x - ( r - i )) f [ i ] = INFLL ; else { f [ i ] = use ; } use -= ( x - 1 ) - a [ i + 1 ]; } int l = n - 1 ; use = 0 ; for ( int i = n - 1 ; i > 1 ; -- i ) { use += i - l ; while ( l > 1 && a [ l - 1 ] < x - ( i - l + 1 )) { use += x - ( i - l + 1 ) - a [ l - 1 ]; -- l ; } if ( l == 1 && a [ l ] < x - ( i - l )) g [ i ] = INFLL ; else g [ i ] = use ; use -= ( x - 1 ) - a [ i - 1 ]; } // if (x == 5) { // for (int i = 2; i < n; ++i) // dbg(i, f[i], g[i]); // } for ( int i = 2 ; i < n ; ++ i ) { if ( x - a [ i ] + f [ i ] + g [ i ] <= has ) return true ; } return false ; } void run () { rd ( n , has ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]); ll l = * max_element ( a + 1 , a + 1 + n ) + 1 , r = 2e9 , res = l - 1 ; while ( r - l >= 0 ) { ll mid = ( l + r ) >> 1 ; // dbg(mid); if ( ok ( mid )) { l = mid + 1 ; res = mid ; } else { r = mid - 1 ; } } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem G. Shuffle Cards Solved By Dup4. 00:04(+) \u9898\u610f \u7ed9\u51fa\u4e00\u4e2a\u5168\u6392\u5217\uff0c\u7136\u540e m m \u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u5c06\u4e00\u6bb5\u533a\u95f4\u7684\u6570\u63d0\u53d6\u5230\u5f00\u5934\u3002 \u601d\u8def \u5176\u5b9e\u5c31\u662f\u6570\u7ec4\u7684\u526a\u5207\u4e0e\u5408\u5e76\uff0c\u7528\u4f20\u7edf\u7684 Treap \u80fd\u505a\uff0c\u4e5f\u80fd pb_ds \u641e\u4e00\u641e\u3002 Code #include <bits/stdc++.h> #include <ext/rope> using namespace std ; using namespace __gnu_cxx ; const int N = 1e5 + 10 ; rope < int > ro ; int n , q , a [ N ]; int main () { while ( scanf ( \"%d%d\" , & n , & q ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) a [ i ] = i ; ro . append ( a + 1 , n ); for ( int i = 1 , p , s ; i <= q ; ++ i ) { scanf ( \"%d%d\" , & p , & s ); ro = ro . substr ( p - 1 , s ) + ro . substr ( 0 , p - 1 ) + ro . substr ( p + s - 1 , n - p - s + 1 ); } for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , ro [ i ], \" \\n \" [ i == n - 1 ]); } return 0 ; } Problem H. Damage Assessment Upsolved By -. \u9898\u610f \u601d\u8def Problem I. Filter Upsolved By -. \u9898\u610f \u601d\u8def Problem J. Diff-prime Pairs Solved By Dup4. 00:13(+) \u9898\u610f \u7ed9\u51fa n n , \u6c42\u6709\u591a\u5c11\u5bf9 (i, j) (i, j) \u6ee1\u8db3 1 \\leq i, j \\leq n 1 \\leq i, j \\leq n \u5e76\u4e14 \\displaystyle \\frac{i}{\\gcd(i, j)} \\displaystyle \\frac{i}{\\gcd(i, j)} \u4e0e \\displaystyle \\frac{j}{\\gcd(i, j)} \\displaystyle \\frac{j}{\\gcd(i, j)} \u4e92\u8d28\u3002 \u601d\u8def \u7b54\u6848\u5c31\u662f\uff1a \\sum\\limits_{i = 1}^n \\sum\\limits_{j = 1}^{\\frac{n}{i}} [j \\; is \\; prime] \\sum\\limits_{i = 1}^n \\sum\\limits_{j = 1}^{\\frac{n}{i}} [j \\; is \\; prime] Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e7 + 10 ; int n , f [ N ]; int pri [ N ], check [ N ]; void sieve () { memset ( check , 0 , sizeof check ); * pri = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( ! check [ i ]) { pri [ ++* pri ] = i ; } for ( int j = 1 ; j <= * pri ; ++ j ) { if ( 1l l * i * pri [ j ] >= N ) break ; check [ i * pri [ j ]] = 1 ; if ( i % pri [ j ] == 0 ) break ; } } f [ 1 ] = 0 ; for ( int i = 2 ; i < N ; ++ i ) f [ i ] = f [ i - 1 ] + ( check [ i ] == 0 ); } ll calc ( int n ) { return 1l l * n * ( n - 1 ) / 2 ; } void run () { rd ( n ); ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { res += calc ( f [ n / i ]) * 2 ; } pt ( res ); } int main () { sieve (); ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem K. Improvements Upsolved By -. \u9898\u610f \u601d\u8def","title":"2020 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day8"},{"location":"2020/nowcoder-national-day-training-party/day8/#contest-info","text":"Practice Link Solved A B C D E F G H I J K 6/11 O - - O O O O - - O - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"2020/nowcoder-national-day-training-party/day8/#solutions","text":"","title":"Solutions"},{"location":"2020/nowcoder-national-day-training-party/day8/#problem-a-easy-chess","text":"Solved By Dup4. 02:36(+2)","title":"Problem A. Easy Chess"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u9898\u610f","text":"\u7ed9\u51fa\u4e00\u4e2a 8 \\cdot 8 8 \\cdot 8 \u7684\u68cb\u76d8\uff0c\u8981\u6c42\u7ed9\u51fa a_1 a_1 \u5230 h_8 h_8 \u7684\u957f\u5ea6\u4e3a n n \u7684\u8def\u5f84\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u601d\u8def","text":"\u5206\u7c7b\u8ba8\u8bba\u4e00\u4e0b\uff0c\u7136\u540e\u7ed5\u6765\u7ed5\u53bb\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; char f [ 10 ]; void run () { rd ( n ); for ( int i = 0 ; i < 8 ; ++ i ) f [ i + 1 ] = 'a' + i ; vector < pII > vec ; if ( n <= 50 ) { vec . push_back ( pII ( 1 , 1 )); int x = 1 , y = 1 ; for ( int i = 1 ; i <= n - 2 ; ++ i ) { if ( x & 1 ) { ++ y ; if ( y == 8 ) { ++ x ; -- y ; } } else { -- y ; if ( y == 0 ) { ++ x ; ++ y ; } } vec . push_back ( pII ( x , y )); } // if (x == 8) --x; vec . push_back ( pII ( x , 8 )); vec . push_back ( pII ( 8 , 8 )); } else { for ( int i = 1 ; i <= 6 ; ++ i ) { if ( i & 1 ) { for ( int j = 1 ; j <= 8 ; ++ j ) vec . push_back ( pII ( i , j )); } else { for ( int j = 8 ; j >= 1 ; -- j ) vec . push_back ( pII ( i , j )); } } if ( n == 51 ) { vec . push_back ( pII ( 8 , 1 )); vec . push_back ( pII ( 8 , 2 )); vec . push_back ( pII ( 8 , 3 )); vec . push_back ( pII ( 8 , 8 )); } else { n -= 49 ; vec . push_back ( pII ( 7 , 1 )); vec . push_back ( pII ( 7 , 8 )); if ( n - 2 >= 6 ) { n -= 6 ; for ( int i = 7 ; i >= 2 ; -- i ) { vec . push_back ( pII ( 7 , i )); } n -= 1 ; vec . push_back ( pII ( 8 , 2 )); if ( n > 1 ) { n -= 1 ; vec . push_back ( pII ( 8 , 1 )); } for ( int i = 1 , j = 3 ; i < n ; ++ i , ++ j ) vec . push_back ( pII ( 8 , j )); vec . push_back ( pII ( 8 , 8 )); } else { int i = 7 ; for ( int j = n - 2 ; j ; -- i , -- j ) { vec . push_back ( pII ( 7 , i )); } vec . push_back ( pII ( 8 , i + 1 )); vec . push_back ( pII ( 8 , 8 )); } } } // dbg(SZ(vec)); for ( int i = 0 ; i < SZ ( vec ); ++ i ) { cout << f [ vec [ i ]. fi ] << vec [ i ]. se << \" \\n \" [ i == SZ ( vec ) - 1 ]; } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day8/#problem-b-cactus-jubilee","text":"Upsolved By -.","title":"Problem B. Cactus Jubilee"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u9898\u610f_1","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u601d\u8def_1","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day8/#problem-c-distance-on-triangulation","text":"Upsolved By -.","title":"Problem C. Distance on Triangulation"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u9898\u610f_2","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u601d\u8def_2","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day8/#problem-d-pacm-team","text":"Solved By Dup4. 01:37(+1)","title":"Problem D. PACM Team"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u9898\u610f_3","text":"\u7ed9\u51fa n n \u4e2a\u961f\u4f0d\uff0c\u6bcf\u4e2a\u961f\u4f0d\u6709\u56db\u79cd\u5c5e\u6027 p_i, a_i, c_i, m_i p_i, a_i, c_i, m_i \uff0c\u9009\u53d6\u4e00\u652f\u961f\u4f0d\u80fd\u591f\u83b7\u5f97 g_i g_i \u70b9\u5229\u76ca\u3002 \u73b0\u5728\u9009\u51fa\u82e5\u5e72\u652f\u961f\u4f0d\uff0c\u5e76\u4e14\u8981\u6c42 \\sum p_i \\leq P, \\sum a_i \\leq A, \\sum c_i \\leq C, \\sum m_i \\leq M \\sum p_i \\leq P, \\sum a_i \\leq A, \\sum c_i \\leq C, \\sum m_i \\leq M , \u5e76\u4e14\u5229\u76ca\u6700\u5927\u3002 1 \\leq n, p_i, a_i, c_i, m_i, P, A, C, M \\leq 36 1 \\leq n, p_i, a_i, c_i, m_i, P, A, C, M \\leq 36 \u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u601d\u8def_3","text":"\u5206\u6210\u4e24\u6bb5\u679a\u4e3e\uff0c\u6bcf\u6bb5 18 18 \u4e2a\uff0c\u7136\u540e\u62fc\u63a5\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e2 + 10 ; int n , P , A , C , M ; int f [ 2 ][ 40 ][ 40 ][ 40 ][ 40 ], g [ 2 ][ 40 ][ 40 ][ 40 ][ 40 ]; struct E { int p , a , c , m , g ; E () {} void scan () { rd ( p , a , c , m , g ); } } e [ N ]; void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) e [ i ]. scan (); rd ( P , A , C , M ); memset ( f , 0 , sizeof f ); memset ( g , 0 , sizeof g ); pII ran [ 2 ] = { pII ( 1 , min ( 18 , n )), pII ( 19 , n )}; for ( int o = 0 ; o < 2 ; ++ o ) { int l = ran [ o ]. fi , r = ran [ o ]. se ; if ( l > r ) continue ; for ( int S = 1 ; S < 1 << 18 ; ++ S ) { int _P = 0 , _A = 0 , _C = 0 , _M = 0 , _G = 0 ; for ( int i = 0 ; i < r - l + 1 ; ++ i ) { if (( S >> i ) & 1 ) { int _i = l + i ; _P += e [ _i ]. p ; _A += e [ _i ]. a ; _C += e [ _i ]. c ; _M += e [ _i ]. m ; _G += e [ _i ]. g ; } } if ( _P <= P && _A <= A && _C <= C && _M <= M ) { if ( _G > f [ o ][ _P ][ _A ][ _C ][ _M ]) { f [ o ][ _P ][ _A ][ _C ][ _M ] = _G ; g [ o ][ _P ][ _A ][ _C ][ _M ] = S ; } } } for ( int i = 0 ; i <= 36 ; ++ i ) { for ( int j = 0 ; j <= 36 ; ++ j ) { for ( int k = 0 ; k <= 36 ; ++ k ) { for ( int l = 0 ; l <= 36 ; ++ l ) { if ( i && f [ o ][ i - 1 ][ j ][ k ][ l ] > f [ o ][ i ][ j ][ k ][ l ]) { f [ o ][ i ][ j ][ k ][ l ] = f [ o ][ i - 1 ][ j ][ k ][ l ]; g [ o ][ i ][ j ][ k ][ l ] = g [ o ][ i - 1 ][ j ][ k ][ l ]; } if ( j && f [ o ][ i ][ j - 1 ][ k ][ l ] > f [ o ][ i ][ j ][ k ][ l ]) { f [ o ][ i ][ j ][ k ][ l ] = f [ o ][ i ][ j - 1 ][ k ][ l ]; g [ o ][ i ][ j ][ k ][ l ] = g [ o ][ i ][ j - 1 ][ k ][ l ]; } if ( k && f [ o ][ i ][ j ][ k - 1 ][ l ] > f [ o ][ i ][ j ][ k ][ l ]) { f [ o ][ i ][ j ][ k ][ l ] = f [ o ][ i ][ j ][ k - 1 ][ l ]; g [ o ][ i ][ j ][ k ][ l ] = g [ o ][ i ][ j ][ k - 1 ][ l ]; } if ( l && f [ o ][ i ][ j ][ k ][ l - 1 ] > f [ o ][ i ][ j ][ k ][ l ]) { f [ o ][ i ][ j ][ k ][ l ] = f [ o ][ i ][ j ][ k ][ l - 1 ]; g [ o ][ i ][ j ][ k ][ l ] = g [ o ][ i ][ j ][ k ][ l - 1 ]; } } } } } } int res = 0 ; int S [ 2 ] = { 0 , 0 }; for ( int i = 0 ; i <= 36 ; ++ i ) { for ( int j = 0 ; j <= 36 ; ++ j ) { for ( int k = 0 ; k <= 36 ; ++ k ) { for ( int o = 0 ; o <= 36 ; ++ o ) { int _i = P - i , _j = A - j , _k = C - k , _o = M - o ; if ( _i >= 0 && _j >= 0 && _k >= 0 && _o >= 0 && f [ 0 ][ i ][ j ][ k ][ o ] + f [ 1 ][ _i ][ _j ][ _k ][ _o ] > res ) { res = f [ 0 ][ i ][ j ][ k ][ o ] + f [ 1 ][ _i ][ _j ][ _k ][ _o ]; S [ 0 ] = g [ 0 ][ i ][ j ][ k ][ o ]; S [ 1 ] = g [ 1 ][ _i ][ _j ][ _k ][ _o ]; } } } } } vector < int > res_vec ; for ( int i = 0 ; i < 2 ; ++ i ) { for ( int j = 0 ; j < 18 ; ++ j ) { if (( S [ i ] >> j ) & 1 ) { res_vec . push_back ( j + ran [ i ]. fi - 1 ); } } } pt ( SZ ( res_vec )); pt ( res_vec ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day8/#problem-e-easy-problemset","text":"Solved By Dup4. 00:55(+)","title":"Problem E. Easy Problemset"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u9898\u610f_4","text":"\u7ed9\u51fa\u4e00\u4e9b\u7b56\u7565\uff0c\u7136\u540e\u9009\u51fa\u82e5\u5e72\u4e2a\u9898\u76ee\uff0c\u6c42\u603b\u7684 hardness \u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u601d\u8def_4","text":"\u7b7e\u5230\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , need ; vector < vector < int >> vec ; void run () { rd ( n , need ); vec . resize ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { vec [ i ]. resize ( nextInt ()); for ( auto & it : vec [ i ]) rd ( it ); } int res = 0 , pos = 0 ; while ( need ) { for ( int i = 1 ; need && i <= n ; ++ i ) { int x = 0 ; if ( pos < SZ ( vec [ i ])) { x = vec [ i ][ pos ]; } else { x = 50 ; } if ( x >= res || x == 50 ) { -- need ; res += x ; } } ++ pos ; } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day8/#problem-f-landscape-improved","text":"Solved By Dup4. 03:21(+)","title":"Problem F. Landscape Improved"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u9898\u610f_5","text":"\u7ed9\u51fa n n \u4e2a\u77e9\u5f62\uff0c\u5bbd\u5ea6\u4e3a\u4e00\u4e2a\u5355\u4f4d\u5bbd\u5ea6\uff0c\u9ad8\u5ea6\u4e3a h_i h_i \uff0c\u73b0\u5728\u80fd\u591f\u589e\u52a0\u67d0\u4e2a\u77e9\u5f62\u7684\u9ad8\u5ea6\uff0c\u80fd\u589e\u52a0\u7b2c i i \u4e2a\u77e9\u5f62\u7684\u9ad8\u5ea6\u81f3 x x \uff0c\u5f53\u4e14\u4ec5\u5f53\u7b2c i - 1 i - 1 \u4e2a\u77e9\u5f62\u548c\u7b2c i + 1 i + 1 \u4e2a\u77e9\u5f62\u7684\u9ad8\u5ea6\u5927\u4e8e\u7b49\u4e8e x - 1 x - 1 \u3002 \u73b0\u5728\u7ed9\u51fa m m \u4e2a\u7816\u5757\uff0c\u95ee\u6700\u9ad8\u7684\u77e9\u5f62\u6700\u591a\u80fd\u589e\u52a0\u5230\u591a\u9ad8\uff1f","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u601d\u8def_5","text":"\u4e8c\u5206\u7b54\u6848\u3002 \u8003\u8651\u5bf9\u4e8e\u5f53\u524d\u7b2c i i \u4e2a\u77e9\u5f62\uff0c\u5982\u679c\u60f3\u8ba9\u5b83\u6210\u4e3a\u6700\u5927\u9ad8\u5ea6\uff0c\u5047\u8bbe\u4e3a x x \uff0c\u90a3\u4e48\u7b2c i + 1 i + 1 \u4e2a\u77e9\u5f62\u9ad8\u5ea6\u5e94\u8be5\u5927\u4e8e\u7b49\u4e8e x - 1 x - 1 \uff0c\u7b2c i + 2 i + 2 \u4e2a\u77e9\u5f62\u9ad8\u5ea6\u5e94\u8be5\u5927\u4e8e\u7b49\u4e8e x - 2 x - 2 \u3002 \u5bf9\u4e8e\u7b2c i + 1 i + 1 \u4e2a\u77e9\u5f62\uff0c\u5982\u679c\u60f3\u8ba9\u5b83\u6210\u4e3a\u6700\u5927\u9ad8\u5ea6\uff0c\u5047\u8bbe\u4e3a x x \uff0c\u90a3\u4e48\u8981\u7b2c i + 2 i + 2 \u4e2a\u77e9\u5f62\u9ad8\u5ea6\u5e94\u8be5\u5927\u4e8e\u7b49\u4e8e x - 1 x - 1 \uff0c\u7b2c i + 3 i + 3 \u4e2a\u77e9\u5f62\u9ad8\u5ea6\u5e94\u8be5\u5927\u4e8e\u7b49\u4e8e x - 3 x - 3 \u3002 \u6211\u4eec\u53d1\u73b0\uff0c\u6700\u9ad8\u77e9\u5f62\u53f3\u79fb\u7684\u8fc7\u7a0b\u4e2d\uff0c\u53f3\u8fb9\u90a3\u90e8\u5206\u77e9\u5f62\u6240\u9700\u7684\u9ad8\u5ea6\u4e5f\u5728\u9012\u589e\uff0c\u53ef\u4ee5\u7ebf\u6027\u7ef4\u62a4\u3002 \u5bf9\u4e8e\u5de6\u8fb9\u7684\u77e9\u5f62\uff0c\u56e0\u4e3a\u662f\u9012\u51cf\u7684\uff0c\u597d\u50cf\u4e0d\u592a\u597d\u5904\u7406\uff0c\u6211\u4eec\u5c06\u6570\u7ec4\u53cd\u8f6c\uff0c\u5b83\u5c31\u53d8\u6210\u4e86\u53f3\u8fb9\uff0c\u5904\u7406\u4e24\u904d\uff0c\u7136\u540e\u5408\u5e76\u8ba1\u7b97\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; constexpr ll INFLL = 0x3f3f3f3f3f3f3f3f ; int n ; ll has , f [ N ], g [ N ], a [ N ]; bool ok ( ll x ) { memset ( f , 0 , sizeof f ); memset ( g , 0 , sizeof g ); ll use = 0 ; int r = 2 ; for ( int i = 2 ; i < n ; ++ i ) { use += r - i ; while ( r < n && a [ r + 1 ] < x - ( r + 1 - i )) { use += x - ( r + 1 - i ) - a [ r + 1 ]; ++ r ; } if ( r == n && a [ r ] < x - ( r - i )) f [ i ] = INFLL ; else { f [ i ] = use ; } use -= ( x - 1 ) - a [ i + 1 ]; } int l = n - 1 ; use = 0 ; for ( int i = n - 1 ; i > 1 ; -- i ) { use += i - l ; while ( l > 1 && a [ l - 1 ] < x - ( i - l + 1 )) { use += x - ( i - l + 1 ) - a [ l - 1 ]; -- l ; } if ( l == 1 && a [ l ] < x - ( i - l )) g [ i ] = INFLL ; else g [ i ] = use ; use -= ( x - 1 ) - a [ i - 1 ]; } // if (x == 5) { // for (int i = 2; i < n; ++i) // dbg(i, f[i], g[i]); // } for ( int i = 2 ; i < n ; ++ i ) { if ( x - a [ i ] + f [ i ] + g [ i ] <= has ) return true ; } return false ; } void run () { rd ( n , has ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]); ll l = * max_element ( a + 1 , a + 1 + n ) + 1 , r = 2e9 , res = l - 1 ; while ( r - l >= 0 ) { ll mid = ( l + r ) >> 1 ; // dbg(mid); if ( ok ( mid )) { l = mid + 1 ; res = mid ; } else { r = mid - 1 ; } } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day8/#problem-g-shuffle-cards","text":"Solved By Dup4. 00:04(+)","title":"Problem G. Shuffle Cards"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u9898\u610f_6","text":"\u7ed9\u51fa\u4e00\u4e2a\u5168\u6392\u5217\uff0c\u7136\u540e m m \u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u5c06\u4e00\u6bb5\u533a\u95f4\u7684\u6570\u63d0\u53d6\u5230\u5f00\u5934\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u601d\u8def_6","text":"\u5176\u5b9e\u5c31\u662f\u6570\u7ec4\u7684\u526a\u5207\u4e0e\u5408\u5e76\uff0c\u7528\u4f20\u7edf\u7684 Treap \u80fd\u505a\uff0c\u4e5f\u80fd pb_ds \u641e\u4e00\u641e\u3002 Code #include <bits/stdc++.h> #include <ext/rope> using namespace std ; using namespace __gnu_cxx ; const int N = 1e5 + 10 ; rope < int > ro ; int n , q , a [ N ]; int main () { while ( scanf ( \"%d%d\" , & n , & q ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) a [ i ] = i ; ro . append ( a + 1 , n ); for ( int i = 1 , p , s ; i <= q ; ++ i ) { scanf ( \"%d%d\" , & p , & s ); ro = ro . substr ( p - 1 , s ) + ro . substr ( 0 , p - 1 ) + ro . substr ( p + s - 1 , n - p - s + 1 ); } for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , ro [ i ], \" \\n \" [ i == n - 1 ]); } return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day8/#problem-h-damage-assessment","text":"Upsolved By -.","title":"Problem H. Damage Assessment"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u9898\u610f_7","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u601d\u8def_7","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day8/#problem-i-filter","text":"Upsolved By -.","title":"Problem I. Filter"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u9898\u610f_8","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u601d\u8def_8","text":"","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day8/#problem-j-diff-prime-pairs","text":"Solved By Dup4. 00:13(+)","title":"Problem J. Diff-prime Pairs"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u9898\u610f_9","text":"\u7ed9\u51fa n n , \u6c42\u6709\u591a\u5c11\u5bf9 (i, j) (i, j) \u6ee1\u8db3 1 \\leq i, j \\leq n 1 \\leq i, j \\leq n \u5e76\u4e14 \\displaystyle \\frac{i}{\\gcd(i, j)} \\displaystyle \\frac{i}{\\gcd(i, j)} \u4e0e \\displaystyle \\frac{j}{\\gcd(i, j)} \\displaystyle \\frac{j}{\\gcd(i, j)} \u4e92\u8d28\u3002","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u601d\u8def_9","text":"\u7b54\u6848\u5c31\u662f\uff1a \\sum\\limits_{i = 1}^n \\sum\\limits_{j = 1}^{\\frac{n}{i}} [j \\; is \\; prime] \\sum\\limits_{i = 1}^n \\sum\\limits_{j = 1}^{\\frac{n}{i}} [j \\; is \\; prime] Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e7 + 10 ; int n , f [ N ]; int pri [ N ], check [ N ]; void sieve () { memset ( check , 0 , sizeof check ); * pri = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( ! check [ i ]) { pri [ ++* pri ] = i ; } for ( int j = 1 ; j <= * pri ; ++ j ) { if ( 1l l * i * pri [ j ] >= N ) break ; check [ i * pri [ j ]] = 1 ; if ( i % pri [ j ] == 0 ) break ; } } f [ 1 ] = 0 ; for ( int i = 2 ; i < N ; ++ i ) f [ i ] = f [ i - 1 ] + ( check [ i ] == 0 ); } ll calc ( int n ) { return 1l l * n * ( n - 1 ) / 2 ; } void run () { rd ( n ); ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { res += calc ( f [ n / i ]) * 2 ; } pt ( res ); } int main () { sieve (); ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/nowcoder-national-day-training-party/day8/#problem-k-improvements","text":"Upsolved By -.","title":"Problem K. Improvements"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u9898\u610f_10","text":"","title":"\u9898\u610f"},{"location":"2020/nowcoder-national-day-training-party/day8/#\u601d\u8def_10","text":"","title":"\u601d\u8def"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/","text":"\u7b2c\u516d\u5c4a CCPC \u79e6\u7687\u5c9b Contents Contest Info Solutions Problem A. A Greeting from Qinhuangdao \u9898\u610f \u601d\u8def Problem B. Bounding Wall \u9898\u610f \u601d\u8def Problem C. Cameraman \u9898\u610f \u601d\u8def Problem D. Defend City \u9898\u610f \u601d\u8def Problem E. Exam Results \u9898\u610f \u601d\u8def Problem F. Friendly Group \u9898\u610f \u601d\u8def Problem G. Good Number \u9898\u610f \u601d\u8def Problem H. Holy Sequence \u9898\u610f \u601d\u8def Problem I. Interstellar Hunter \u9898\u610f \u601d\u8def Problem J. Jewel Splitting \u9898\u610f \u601d\u8def Problem K. Kingdom\u2019s Power \u9898\u610f \u601d\u8def Problem L. Lost Temple \u9898\u610f \u601d\u8def Contest Info Practice Link Solved A B C D E F G H I J K L 5/12 O - O - O O O - - - - - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions Problem A. A Greeting from Qinhuangdao Solved By Dup4. 9(+) \u9898\u610f \u7ed9\u51fa r r \u548c\u7ea2\u7403\uff0c b b \u4e2a\u84dd\u7403\uff0c\u95ee\u53d6\u4e24\u4e2a\u7403\uff0c\u90fd\u662f\u7ea2\u7403\u7684\u6982\u7387\u662f\u591a\u5c11\uff1f \u601d\u8def \\displaystyle \\frac{r}{r + b} \\cdot \\frac{r - 1}{r + b - 1} \\displaystyle \\frac{r}{r + b} \\cdot \\frac{r - 1}{r + b - 1} Code #include <bits/stdc++.h> using namespace std ; int main () { int _T ; cin >> _T ; for ( int i = 1 ; i <= _T ; ++ i ) { printf ( \"Case #%d: \" , i ); int r , b ; scanf ( \"%d%d\" , & r , & b ); if ( r < 2 ) puts ( \"0/1\" ); else { int A = r * ( r - 1 ); int B = ( r + b ) * ( r + b - 1 ); int _g = __gcd ( A , B ); A /= _g ; B /= _g ; printf ( \"%d/%d \\n \" , A , B ); } } return 0 ; } Problem B. Bounding Wall Upsolved By -. \u9898\u610f \u601d\u8def Problem C. Cameraman Solved By Dup4 & groggy_. - \u9898\u610f \u7ed9\u51fa\u4e00\u4e2a\u77e9\u5f62\uff0c\u5de6\u4e0b\u89d2\u662f (0, 0) (0, 0) , \u53f3\u4e0a\u89d2\u662f (w, h) (w, h) , \u5e76\u4e14\u7ed9\u51fa\u4e00\u4e2a\u70b9 (x, y)(1 \\leq x \\leq w - 1, 1 \\leq y \\leq h - 1) (x, y)(1 \\leq x \\leq w - 1, 1 \\leq y \\leq h - 1) \u3002 \u5728\u77e9\u5f62\u5185\u90e8\u6709 n n \u4e2a\u70b9\uff0c\u73b0\u5728\u8981\u627e\u4e2a\u70b9\u5c04\u51fa\u53bb\u4e24\u6761\u7ebf\uff0c\u4f7f\u5f97\u5c04\u7ebf\u4ee5\u53ca\u77e9\u5f62\u56f4\u6210\u7684\u95ed\u5408\u533a\u57df\u53ea\u6709 (x, y) (x, y) \u8fd9\u4e2a\u70b9\u3002 \u73b0\u5728\u8981\u6c42\u4e24\u6761\u5c04\u7ebf\u4e0e\u77e9\u5f62\u56f4\u6210\u7684\u95ed\u5408\u533a\u57df\u4e2d\uff0c\u77e9\u5f62\u90a3\u90e8\u5206\u7684\u53d8\u957f\u548c\u6700\u957f\u3002 \u601d\u8def \u5927\u529b\u731c\u6d4b\u8981\u627e\u7684\u90a3\u4e2a\u70b9\u5c31\u53ef\u4ee5\u662f (x, y) (x, y) \u3002 \u7136\u540e\u4ece (x, y) (x, y) \u5411\u5176\u5b83\u70b9\u8fde\u5c04\u7ebf\uff0c\u4ea4\u77e9\u5f62\u4e00\u4e2a\u70b9\u3002 \u5bf9\u6c42\u51fa\u7684\u70b9\u505a\u76f4\u89d2\u6392\u5e8f\u3002 \u6211\u4eec\u76f4\u63a5\u76f4\u89d2\u6392\u5e8f\u53d1\u73b0\u8fc7\u4e0d\u4e86\u3002 \u540e\u6765\u8003\u8651\u6bcf\u4e2a\u70b9\u80af\u5b9a\u5728\u77e9\u5f62\u7684\u56db\u6761\u8fb9\u4e0a\uff0c\u90a3\u4e48\u6211\u4eec\u5bf9\u8fd9\u56db\u6761\u8fb9\u7684\u4e0a\u7684\u70b9\u5206\u522b\u6392\u5e8f\uff0c\u6700\u540e\u627e\u4e2a\u65b9\u5411\u5408\u5e76\u8d77\u6765\u3002 \u7136\u540e\u8ba1\u7b97\u76f8\u90bb\u4e24\u70b9\u4e4b\u95f4\u56f4\u6210\u7684\u53d8\u957f\u548c\u3002 \u8fd9\u91cc\u5176\u5b9e\u60c5\u51b5\u6709\u5f88\u591a\u79cd\uff0c\u4f46\u662f\u5982\u679c\u52a0\u5165\u77e9\u5f62\u7684\u56db\u4e2a\u89d2\u4f5c\u4e3a\u865a\u70b9\u3002 \u90a3\u4e48\u76f8\u90bb\u4eae\u70b9\u80af\u5b9a\u5728\u77e9\u5f62\u7684\u4e00\u6761\u8fb9\u4e0a\uff0c\u8fd9\u4e2a\u65f6\u5019\u6c42\u8ddd\u79bb\u5f88\u7b80\u5355\u3002 \u90a3\u4e48\u5c31\u8f6c\u5316\u6210\u4e86\u4e24\u4e2a\u5b9e\u70b9\u4e4b\u95f4\u76f8\u90bb\u4e24\u70b9\u7684\u8fb9\u957f\u548c\u3002 Code #include <bits/stdc++.h> using namespace std ; using db = long double ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const db eps = 1e-6 ; int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; return x < 0 ? -1 : 1 ; } const int N = 1e5 + 10 ; int w , h , n ; struct Point { db x , y ; int vis , tp ; Point ( db x = 0 , db y = 0 , int vis = 1 ) : x ( x ), y ( y ), vis ( vis ) {} void scan () { scanf ( \"%Lf%Lf\" , & x , & y ); } Point operator - ( const Point & b ) const { return Point ( x - b . x , y - b . y ); } bool operator < ( const Point & b ) const { return sgn ( x - b . x ) == 0 ? sgn ( y - b . y ) < 0 : x < b . x ; } db operator ^ ( const Point & b ) const { return x * b . y - y * b . x ; } db dis ( Point b ) { return hypot ( x - b . x , y - b . y ); } db dis2 ( Point b ) { return ( x - b . x ) * ( x - b . x ) + ( y - b . y ) * ( y - b . y ); } } p ; struct Line { Point s , e ; Line () {} Line ( Point s , Point e ) : s ( s ), e ( e ) {} }; struct Polygon { vector < Point > p ; Polygon () { p . clear (); } Polygon ( int n ) { p . clear (); p . resize ( n ); } void add ( Point x ) { p . push_back ( x ); } int sze () { return p . size (); } Point & operator []( int x ) { return p [( x + sze ()) % sze ()]; } struct cmpNorm { Point p ; cmpNorm ( Point p ) : p ( p ) {} bool operator ()( Point a , Point b ) { int d = sgn (( a - p ) ^ ( b - p )); if ( d == 0 ) { return sgn ( a . dis2 ( p ) - b . dis2 ( p )) < 0 ; } else { return d > 0 ; } } }; void norm () { Point mi = * p . begin (); for ( int i = 1 ; i < sze (); ++ i ) mi = min ( mi , p [ i ]); sort ( p . begin (), p . end (), cmpNorm ( mi )); } void norm ( Point mi ) { sort ( p . begin (), p . end (), cmpNorm ( mi )); } // int pointInConvex(Point q) { // int l = 1, r = sze() - 2; // while (r - l >= 0) { // int mid = (l + r) >> 1; // int a1 = sgn((p[mid] - p[0])) // } // } } po , _po ; db dis ( Point a ) { return ( p . x - a . x ) * ( p . x - a . x ) + ( p . y - a . y ) * ( p . y - a . y ); } Point getPoint ( Point a ) { db dis_x = fabs ( a . x - p . x ); db dis_y = fabs ( a . y - p . y ); // cout<<dis_x<<' '<<dis_y<<endl; if ( a . x == p . x && a . y > p . y ) return Point ( p . x , h ); else if ( a . y == p . y && a . x > p . x ) return Point ( w , p . y ); else if ( a . x == p . x && a . y < p . y ) return Point ( p . x , 0 ); else if ( a . y == p . y && a . x < p . x ) return Point ( 0 , p . y ); else if ( a . x > p . x && a . y > p . y ) { Point new1_a ; new1_a . x = w ; new1_a . y = p . y + ( w - p . x ) * dis_y / dis_x ; Point new2_a ; new2_a . x = p . x + ( h - p . y ) * dis_x / dis_y ; new2_a . y = h ; // cout<<dis(new1_a)<<' '<<dis(new2_a)<<endl; // cout<<new1_a.x<<' '<<new1_a.y<<endl; // cout<<new2_a.x<<' '<<new2_a.y<<endl; if ( sgn ( dis ( new1_a ) - dis ( new2_a )) <= 0 ) return new1_a ; else return new2_a ; } else if ( a . x > p . x && a . y < p . y ) { Point new1_a ; new1_a . x = w ; new1_a . y = p . y - ( w - p . x ) * dis_y / dis_x ; Point new2_a ; new2_a . x = p . x + p . y * dis_x / dis_y ; new2_a . y = 0 ; if ( sgn ( dis ( new1_a ) - dis ( new2_a )) <= 0 ) return new1_a ; else return new2_a ; } else if ( a . x < p . x && a . y > p . y ) { Point new1_a ; new1_a . x = 0 ; new1_a . y = p . y + p . x * dis_y / dis_x ; Point new2_a ; new2_a . x = p . x - ( h - p . y ) * dis_x / dis_y ; new2_a . y = h ; if ( sgn ( dis ( new1_a ) - dis ( new2_a )) <= 0 ) return new1_a ; else return new2_a ; } else if ( a . x < p . x && a . y < p . y ) { Point new1_a ; new1_a . x = 0 ; new1_a . y = p . y - p . x * dis_y / dis_x ; Point new2_a ; new2_a . x = p . x - p . y * dis_x / dis_y ; new2_a . y = 0 ; if ( sgn ( dis ( new1_a ) - dis ( new2_a )) <= 0 ) return new1_a ; else return new2_a ; } return Point ( 0 , 0 ); } db calc ( Point a , Point b ) { if ( sgn ( a . x - b . x ) == 0 || sgn ( a . y - b . y ) == 0 ) { return max ( fabs ( a . x - b . x ), fabs ( a . y - b . y )); } else { assert ( 0 ); } return 0 ; } int main () { int _T ; scanf ( \"%d\" , & _T ); for ( int CAS = 1 ; CAS <= _T ; ++ CAS ) { printf ( \"Case #%d: \" , CAS ); scanf ( \"%d%d\" , & w , & h ); p . scan (); scanf ( \"%d\" , & n ); po = Polygon ( n ); for ( int i = 0 ; i < n ; ++ i ) { po [ i - 1 ]. scan (); } po . norm ( p ); _po = Polygon ( n + 4 ); // dbg(n); for ( int i = 0 ; i < n ; ++ i ) { _po [ i ] = getPoint ( po [ i ]); // dbg(_po[i].x, _po[i].y); _po [ i ]. vis = 1 ; } _po [ n ] = Point ( 0 , 0 , 0 ); _po [ n + 1 ] = Point ( w , 0 , 0 ); _po [ n + 2 ] = Point ( w , h , 0 ); _po [ n + 3 ] = Point ( 0 , h , 0 ); for ( int i = 0 ; i < n + 4 ; ++ i ) { if ( sgn ( _po [ i ]. y ) == 0 ) _po [ i ]. tp = 1 ; else if ( sgn ( _po [ i ]. x - w ) == 0 ) _po [ i ]. tp = 2 ; else if ( sgn ( _po [ i ]. y - h ) == 0 ) _po [ i ]. tp = 3 ; else if ( sgn ( _po [ i ]. x ) == 0 ) _po [ i ]. tp = 4 ; } sort ( _po . p . begin (), _po . p . end (), [ & ]( Point a , Point b ) { if ( a . tp != b . tp ) return a . tp < b . tp ; if ( a . tp == 1 ) return sgn ( a . x - b . x ) <= 0 ; else if ( a . tp == 2 ) return sgn ( a . y - b . y ) <= 0 ; else if ( a . tp == 3 ) return sgn ( a . x - b . x ) >= 0 ; else if ( a . tp == 4 ) return sgn ( a . y - b . y ) >= 0 ; }); // for (int i = 1; i <= n + 4; ++i) { // dbg(i, _po[i].x, _po[i].y); // } db res = 0 ; for ( int i = 1 ; i <= n + 100 ; ++ i ) { int _j = i - 1 ; for ( int j = i - 1 ;; -- j ) { if ( _po [ j ]. vis == 1 ) { _j = j ; break ; } } db now = 0 ; for ( int j = i - 1 ; j >= _j ; -- j ) { now += calc ( _po [ j ], _po [ j + 1 ]); } res = max ( res , now ); } printf ( \"%.10Lf \\n \" , res ); } return 0 ; } Problem D. Defend City Upsolved By -. \u9898\u610f \u601d\u8def Problem E. Exam Results Solved By Dup4 & ltslts. 76(+1) \u9898\u610f \u7ed9\u51fa n n \u4e2a\u4eba\u548c\u4e00\u4e2a\u6982\u7387\u53c2\u6570 p p \u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u4eba\uff0c\u5728\u4e00\u573a\u8003\u8bd5\u4e2d\uff0c\u5982\u679c\u4ed6\u53d1\u6325\u7684\u597d\uff0c\u4ed6\u4f1a\u5f97\u5230 a_i a_i \u7684\u5206\u6570\uff0c\u5426\u5219\u5f97\u5230 b_i b_i \u7684\u5206\u6570\u3002 \u5728\u4e00\u573a\u8003\u8bd5\u4e2d\uff0c\u5047\u5b9a\u6700\u9ad8\u5206\u6570\u4e3a x x \uff0c\u90a3\u4e48\u53ea\u8981\u4e00\u4e2a\u4eba\u5f97\u5230\u7684\u5206\u6570\u5927\u4e8e\u7b49\u4e8e x \\cdot p\\% x \\cdot p\\% \uff0c\u90a3\u4e48\u4ed6\u5c31\u80fd\u901a\u8fc7\u8fd9\u573a\u8003\u8bd5\u3002 \u95ee\u6240\u6709 2^n 2^n \u7684\u60c5\u51b5\u4e2d\uff0c\u6700\u591a\u80fd\u6709\u591a\u5c11\u4eba\u901a\u8fc7\u8003\u8bd5\u3002 \u601d\u8def \u5c06\u6240\u6709\u5206\u6570\u6392\u5e8f\u3002 \u7136\u540e\u4ece\u5927\u5230\u5c0f\u679a\u4e3e x x \uff0c\u7136\u540e\u7ef4\u62a4\u4e24\u4e2a\u6307\u9488\u3002 \u4e00\u4e2a\u662f\u8981\u6240\u6709\u5927\u4e8e x x \u7684\u5206\u6570\u90fd\u4e0d\u80fd\u8981\u3002 \u4e00\u4e2a\u662f\u6240\u6709\u5c0f\u4e8e x \\cdot p\\% x \\cdot p\\% \u7684\u5206\u6570\u90fd\u4e0d\u80fd\u52a0\u5165\u3002 \u4f46\u662f\u8003\u8651 x x \u662f\u9012\u51cf\u7684\uff0c\u6240\u4ee5\u4e0b\u754c\u662f\u9010\u6e10\u51cf\u5c0f\uff0c\u6240\u4ee5\u662f\u6162\u6162\u52a0\u5165\u5f88\u591a\u53ef\u4ee5\u7684\u70b9\u3002 \u6240\u4ee5\u6bcf\u4e2a\u5206\u6570\u53ea\u4f1a\u88ab\u52a0\u5165\u4e00\u6b21\uff0c\u5254\u9664\u4e00\u6b21\u3002 \u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u4e00\u4e2a\u4eba\u4e24\u4e2a\u5206\u6570\u90fd\u56e0\u4e3a\u5927\u4e8e x x \u800c\u88ab\u5254\u9664\u6389\uff0c\u662f\u4e0d\u5408\u6cd5\u7684\u60c5\u51b5\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; using pII = pair < int , int > ; #define fi first #define se second #define SZ(x) (int(x.size())) const int N = 2e5 + 10 ; int n , p ; int a [ N ], b [ N ]; int f [ N ]; void gao () { for ( int i = 1 ; i <= n ; ++ i ) f [ i ] = 0 ; vector < pII > vec ; for ( int i = 1 ; i <= n ; ++ i ) { vec . push_back ( pII ( a [ i ], i )); vec . push_back ( pII ( b [ i ], i )); } sort ( vec . begin (), vec . end ()); int res = 0 , now = 0 ; int r = SZ ( vec ) - 1 , l = SZ ( vec ) - 1 ; int m = SZ ( vec ) - 1 ; int MaxScore = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { MaxScore = max ( MaxScore , min ({ a [ i ], b [ i ]})); } for ( int i = m ; i >= 0 ; -- i ) { int Max = vec [ i ]. fi ; if ( Max < MaxScore ) break ; ll pMax = 1l l * p * Max ; while ( l >= 0 && 1l l * vec [ l ]. fi * 100 >= pMax ) { int id = vec [ l ]. se ; ++ f [ id ]; if ( f [ id ] == 1 ) ++ now ; -- l ; } while ( r >= 0 && vec [ r ]. fi > Max ) { int id = vec [ r ]. se ; -- f [ id ]; if ( f [ id ] == 0 ) -- now ; -- r ; } res = max ( res , now ); } printf ( \"%d \\n \" , res ); } int main () { int _T ; scanf ( \"%d\" , & _T ); for ( int CAS = 1 ; CAS <= _T ; ++ CAS ) { printf ( \"Case #%d: \" , CAS ); scanf ( \"%d%d\" , & n , & p ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d%d\" , a + i , b + i ); } gao (); } return 0 ; } Problem F. Friendly Group Solved By Dup4 & ltslts. 44(+) \u9898\u610f \u7ed9\u51fa n n \u4e2a\u70b9\u548c m m \u6761\u8fb9\u3002 \u73b0\u5728\u8981\u7ed9\u51fa\u4e00\u4e2a\u5b50\u56fe\uff0c\u5b9a\u4e49\u4ef7\u503c\u4e3a\uff1a V = \\mbox{\u8fde\u63a5\u8fd9\u4e2a\u5b50\u56fe\u4e2d\u4e24\u70b9\u7684\u8fb9\u7684\u6570\u91cf} - \\mbox{\u70b9\u6570} - \\mbox{\u5176\u4e2d\u4e00\u4e2a\u70b9\u5728\u5b50\u56fe\u4e2d\uff0c\u53e6\u4e00\u4e2a\u70b9\u5728\u5b50\u56fe\u5916\u7684\u8fb9\u7684\u6570\u91cf} V = \\mbox{\u8fde\u63a5\u8fd9\u4e2a\u5b50\u56fe\u4e2d\u4e24\u70b9\u7684\u8fb9\u7684\u6570\u91cf} - \\mbox{\u70b9\u6570} - \\mbox{\u5176\u4e2d\u4e00\u4e2a\u70b9\u5728\u5b50\u56fe\u4e2d\uff0c\u53e6\u4e00\u4e2a\u70b9\u5728\u5b50\u56fe\u5916\u7684\u8fb9\u7684\u6570\u91cf} \u95ee\u5982\u4f55\u9009\u5b50\u56fe\uff0c\u4f7f\u5f97\u4ef7\u503c\u6700\u5927\uff1f \u601d\u8def \u8d2a\u5fc3\uff0c\u9009\u62e9\u6b63\u6536\u76ca\u7684\u6bcf\u4e00\u4e2a\u8fde\u901a\u5757\u3002 Code #include <bits/stdc++.h> using namespace std ; #define SZ(x) (int(x.size())) const int N = 3e5 + 10 ; int n , m ; vector < vector < int >> G , T ; struct UFS { int fa [ N ], sze [ N ]; void init ( int n ) { for ( int i = 1 ; i <= n ; ++ i ) { fa [ i ] = 0 ; sze [ i ] = 1 ; } } int find ( int u ) { return fa [ u ] ? fa [ u ] = find ( fa [ u ]) : u ; } void merge ( int u , int v ) { int fu = find ( u ), fv = find ( v ); if ( fu != fv ) { if ( sze [ fu ] > sze [ fv ]) { swap ( fu , fv ); } fa [ fv ] = fu ; sze [ fu ] += sze [ fv ]; } } } ufs ; int main () { int _T ; scanf ( \"%d\" , & _T ); for ( int CAS = 1 ; CAS <= _T ; ++ CAS ) { printf ( \"Case #%d: \" , CAS ); scanf ( \"%d%d\" , & n , & m ); G . clear (); G . resize ( n + 1 ); ufs . init ( n ); for ( int i = 1 , u , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); ufs . merge ( u , v ); } T . clear (); T . resize ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { T [ ufs . find ( i )]. push_back ( i ); } int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( ! T [ i ]. empty ()) { int E = 0 , V = SZ ( T [ i ]); for ( auto & it : T [ i ]) { E += SZ ( G [ it ]); } E /= 2 ; if ( E - V > 0 ) res += E - V ; } } printf ( \"%d \\n \" , res ); } return 0 ; } Problem G. Good Number Solved By Dup4. 34(+) \u9898\u610f \u7ed9\u51fa n n \u548c k k \u3002 \u7edf\u8ba1 [1, n] [1, n] \u4e2d\u6709\u591a\u5c11\u4e2a x x \u6ee1\u8db3 \\displaystyle \\lfloor \\sqrt[k]{x} \\rfloor \\;\\;|\\;\\; x \\displaystyle \\lfloor \\sqrt[k]{x} \\rfloor \\;\\;|\\;\\; x \u3002 \u601d\u8def k = 1 k = 1 \u7684\u65f6\u5019\u7279\u5224\u3002 \u8003\u8651 \\lfloor \\sqrt[k]{x} \\rfloor \\lfloor \\sqrt[k]{x} \\rfloor \u7684\u79cd\u7c7b\u53ea\u6709 \\lfloor \\sqrt[k]{n} \\rfloor \\lfloor \\sqrt[k]{n} \\rfloor \u79cd\u3002 \u90a3\u4e48\u5bf9\u4e8e i i \uff0c\u5b83\u638c\u7ba1\u7684\u8303\u56f4\u662f [i^k, (i + 1)^k) [i^k, (i + 1)^k) , \u76f4\u63a5\u7edf\u8ba1\u8fd9\u4e2a\u8303\u56f4\u5185\u6709\u591a\u5c11\u4e2a i i \u7684\u500d\u6570\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; int n , k ; ll calc ( int x ) { ll res = 1 ; for ( int i = 1 ; i <= k ; ++ i ) { res *= x ; if ( res > n ) return n + 1 ; } return res ; } ll gao ( ll x , ll y ) { return y / x ; } int main () { int _T ; scanf ( \"%d\" , & _T ); for ( int CAS = 1 ; CAS <= _T ; ++ CAS ) { printf ( \"Case #%d: \" , CAS ); scanf ( \"%d%d\" , & n , & k ); if ( k == 1 ) { printf ( \"%d \\n \" , n ); } else { int limit = ceil ( pow ( n , 1.0 / k )) + 10 ; limit = min ( limit , n ); ll res = 0 ; for ( int i = 1 ; i <= limit ; ++ i ) { ll l = calc ( i ); ll r = calc ( i + 1 ); if ( l < r ) { res += gao ( i , r - 1 ) - gao ( i , l - 1 ); } } printf ( \"%lld \\n \" , res ); } } return 0 ; } Problem H. Holy Sequence Upsolved By -. \u9898\u610f \u601d\u8def Problem I. Interstellar Hunter Upsolved By -. \u9898\u610f \u601d\u8def Problem J. Jewel Splitting Upsolved By -. \u9898\u610f \u601d\u8def Problem K. Kingdom\u2019s Power Upsolved By -. \u9898\u610f \u7ed9\u51fa n n \u4e2a\u70b9\u7684\u6709\u6839\u6811\uff0c\u6839\u4e3a 1 1 \u3002 \u5728\u6839\u7ed3\u70b9\uff0c\u6709\u65e0\u9650\u4e2a\u58eb\u5175\u3002 \u6bcf\u6b21\u53ef\u4ee5\u8c03\u914d\u4e00\u4e2a\u58eb\u5175\uff0c\u5411\u5b83\u76f8\u90bb\u7684\u70b9\u8d70\u4e00\u6b65\u3002 \u95ee\u6240\u6709\u70b9\u90fd\u81f3\u5c11\u88ab\u4e00\u4e2a\u58eb\u5175\u8bbf\u95ee\u8fc7\u7684\u6700\u5c0f\u6b21\u6570\u3002 \u601d\u8def Problem L. Lost Temple Upsolved By -. \u9898\u610f \u601d\u8def","title":"\u7b2c\u516d\u5c4a CCPC \u79e6\u7687\u5c9b"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#contest-info","text":"Practice Link Solved A B C D E F G H I J K L 5/12 O - O - O O O - - - - - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#solutions","text":"","title":"Solutions"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#problem-a-a-greeting-from-qinhuangdao","text":"Solved By Dup4. 9(+)","title":"Problem A. A Greeting from Qinhuangdao"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u9898\u610f","text":"\u7ed9\u51fa r r \u548c\u7ea2\u7403\uff0c b b \u4e2a\u84dd\u7403\uff0c\u95ee\u53d6\u4e24\u4e2a\u7403\uff0c\u90fd\u662f\u7ea2\u7403\u7684\u6982\u7387\u662f\u591a\u5c11\uff1f","title":"\u9898\u610f"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u601d\u8def","text":"\\displaystyle \\frac{r}{r + b} \\cdot \\frac{r - 1}{r + b - 1} \\displaystyle \\frac{r}{r + b} \\cdot \\frac{r - 1}{r + b - 1} Code #include <bits/stdc++.h> using namespace std ; int main () { int _T ; cin >> _T ; for ( int i = 1 ; i <= _T ; ++ i ) { printf ( \"Case #%d: \" , i ); int r , b ; scanf ( \"%d%d\" , & r , & b ); if ( r < 2 ) puts ( \"0/1\" ); else { int A = r * ( r - 1 ); int B = ( r + b ) * ( r + b - 1 ); int _g = __gcd ( A , B ); A /= _g ; B /= _g ; printf ( \"%d/%d \\n \" , A , B ); } } return 0 ; }","title":"\u601d\u8def"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#problem-b-bounding-wall","text":"Upsolved By -.","title":"Problem B. Bounding Wall"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u9898\u610f_1","text":"","title":"\u9898\u610f"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u601d\u8def_1","text":"","title":"\u601d\u8def"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#problem-c-cameraman","text":"Solved By Dup4 & groggy_. -","title":"Problem C. Cameraman"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u9898\u610f_2","text":"\u7ed9\u51fa\u4e00\u4e2a\u77e9\u5f62\uff0c\u5de6\u4e0b\u89d2\u662f (0, 0) (0, 0) , \u53f3\u4e0a\u89d2\u662f (w, h) (w, h) , \u5e76\u4e14\u7ed9\u51fa\u4e00\u4e2a\u70b9 (x, y)(1 \\leq x \\leq w - 1, 1 \\leq y \\leq h - 1) (x, y)(1 \\leq x \\leq w - 1, 1 \\leq y \\leq h - 1) \u3002 \u5728\u77e9\u5f62\u5185\u90e8\u6709 n n \u4e2a\u70b9\uff0c\u73b0\u5728\u8981\u627e\u4e2a\u70b9\u5c04\u51fa\u53bb\u4e24\u6761\u7ebf\uff0c\u4f7f\u5f97\u5c04\u7ebf\u4ee5\u53ca\u77e9\u5f62\u56f4\u6210\u7684\u95ed\u5408\u533a\u57df\u53ea\u6709 (x, y) (x, y) \u8fd9\u4e2a\u70b9\u3002 \u73b0\u5728\u8981\u6c42\u4e24\u6761\u5c04\u7ebf\u4e0e\u77e9\u5f62\u56f4\u6210\u7684\u95ed\u5408\u533a\u57df\u4e2d\uff0c\u77e9\u5f62\u90a3\u90e8\u5206\u7684\u53d8\u957f\u548c\u6700\u957f\u3002","title":"\u9898\u610f"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u601d\u8def_2","text":"\u5927\u529b\u731c\u6d4b\u8981\u627e\u7684\u90a3\u4e2a\u70b9\u5c31\u53ef\u4ee5\u662f (x, y) (x, y) \u3002 \u7136\u540e\u4ece (x, y) (x, y) \u5411\u5176\u5b83\u70b9\u8fde\u5c04\u7ebf\uff0c\u4ea4\u77e9\u5f62\u4e00\u4e2a\u70b9\u3002 \u5bf9\u6c42\u51fa\u7684\u70b9\u505a\u76f4\u89d2\u6392\u5e8f\u3002 \u6211\u4eec\u76f4\u63a5\u76f4\u89d2\u6392\u5e8f\u53d1\u73b0\u8fc7\u4e0d\u4e86\u3002 \u540e\u6765\u8003\u8651\u6bcf\u4e2a\u70b9\u80af\u5b9a\u5728\u77e9\u5f62\u7684\u56db\u6761\u8fb9\u4e0a\uff0c\u90a3\u4e48\u6211\u4eec\u5bf9\u8fd9\u56db\u6761\u8fb9\u7684\u4e0a\u7684\u70b9\u5206\u522b\u6392\u5e8f\uff0c\u6700\u540e\u627e\u4e2a\u65b9\u5411\u5408\u5e76\u8d77\u6765\u3002 \u7136\u540e\u8ba1\u7b97\u76f8\u90bb\u4e24\u70b9\u4e4b\u95f4\u56f4\u6210\u7684\u53d8\u957f\u548c\u3002 \u8fd9\u91cc\u5176\u5b9e\u60c5\u51b5\u6709\u5f88\u591a\u79cd\uff0c\u4f46\u662f\u5982\u679c\u52a0\u5165\u77e9\u5f62\u7684\u56db\u4e2a\u89d2\u4f5c\u4e3a\u865a\u70b9\u3002 \u90a3\u4e48\u76f8\u90bb\u4eae\u70b9\u80af\u5b9a\u5728\u77e9\u5f62\u7684\u4e00\u6761\u8fb9\u4e0a\uff0c\u8fd9\u4e2a\u65f6\u5019\u6c42\u8ddd\u79bb\u5f88\u7b80\u5355\u3002 \u90a3\u4e48\u5c31\u8f6c\u5316\u6210\u4e86\u4e24\u4e2a\u5b9e\u70b9\u4e4b\u95f4\u76f8\u90bb\u4e24\u70b9\u7684\u8fb9\u957f\u548c\u3002 Code #include <bits/stdc++.h> using namespace std ; using db = long double ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const db eps = 1e-6 ; int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; return x < 0 ? -1 : 1 ; } const int N = 1e5 + 10 ; int w , h , n ; struct Point { db x , y ; int vis , tp ; Point ( db x = 0 , db y = 0 , int vis = 1 ) : x ( x ), y ( y ), vis ( vis ) {} void scan () { scanf ( \"%Lf%Lf\" , & x , & y ); } Point operator - ( const Point & b ) const { return Point ( x - b . x , y - b . y ); } bool operator < ( const Point & b ) const { return sgn ( x - b . x ) == 0 ? sgn ( y - b . y ) < 0 : x < b . x ; } db operator ^ ( const Point & b ) const { return x * b . y - y * b . x ; } db dis ( Point b ) { return hypot ( x - b . x , y - b . y ); } db dis2 ( Point b ) { return ( x - b . x ) * ( x - b . x ) + ( y - b . y ) * ( y - b . y ); } } p ; struct Line { Point s , e ; Line () {} Line ( Point s , Point e ) : s ( s ), e ( e ) {} }; struct Polygon { vector < Point > p ; Polygon () { p . clear (); } Polygon ( int n ) { p . clear (); p . resize ( n ); } void add ( Point x ) { p . push_back ( x ); } int sze () { return p . size (); } Point & operator []( int x ) { return p [( x + sze ()) % sze ()]; } struct cmpNorm { Point p ; cmpNorm ( Point p ) : p ( p ) {} bool operator ()( Point a , Point b ) { int d = sgn (( a - p ) ^ ( b - p )); if ( d == 0 ) { return sgn ( a . dis2 ( p ) - b . dis2 ( p )) < 0 ; } else { return d > 0 ; } } }; void norm () { Point mi = * p . begin (); for ( int i = 1 ; i < sze (); ++ i ) mi = min ( mi , p [ i ]); sort ( p . begin (), p . end (), cmpNorm ( mi )); } void norm ( Point mi ) { sort ( p . begin (), p . end (), cmpNorm ( mi )); } // int pointInConvex(Point q) { // int l = 1, r = sze() - 2; // while (r - l >= 0) { // int mid = (l + r) >> 1; // int a1 = sgn((p[mid] - p[0])) // } // } } po , _po ; db dis ( Point a ) { return ( p . x - a . x ) * ( p . x - a . x ) + ( p . y - a . y ) * ( p . y - a . y ); } Point getPoint ( Point a ) { db dis_x = fabs ( a . x - p . x ); db dis_y = fabs ( a . y - p . y ); // cout<<dis_x<<' '<<dis_y<<endl; if ( a . x == p . x && a . y > p . y ) return Point ( p . x , h ); else if ( a . y == p . y && a . x > p . x ) return Point ( w , p . y ); else if ( a . x == p . x && a . y < p . y ) return Point ( p . x , 0 ); else if ( a . y == p . y && a . x < p . x ) return Point ( 0 , p . y ); else if ( a . x > p . x && a . y > p . y ) { Point new1_a ; new1_a . x = w ; new1_a . y = p . y + ( w - p . x ) * dis_y / dis_x ; Point new2_a ; new2_a . x = p . x + ( h - p . y ) * dis_x / dis_y ; new2_a . y = h ; // cout<<dis(new1_a)<<' '<<dis(new2_a)<<endl; // cout<<new1_a.x<<' '<<new1_a.y<<endl; // cout<<new2_a.x<<' '<<new2_a.y<<endl; if ( sgn ( dis ( new1_a ) - dis ( new2_a )) <= 0 ) return new1_a ; else return new2_a ; } else if ( a . x > p . x && a . y < p . y ) { Point new1_a ; new1_a . x = w ; new1_a . y = p . y - ( w - p . x ) * dis_y / dis_x ; Point new2_a ; new2_a . x = p . x + p . y * dis_x / dis_y ; new2_a . y = 0 ; if ( sgn ( dis ( new1_a ) - dis ( new2_a )) <= 0 ) return new1_a ; else return new2_a ; } else if ( a . x < p . x && a . y > p . y ) { Point new1_a ; new1_a . x = 0 ; new1_a . y = p . y + p . x * dis_y / dis_x ; Point new2_a ; new2_a . x = p . x - ( h - p . y ) * dis_x / dis_y ; new2_a . y = h ; if ( sgn ( dis ( new1_a ) - dis ( new2_a )) <= 0 ) return new1_a ; else return new2_a ; } else if ( a . x < p . x && a . y < p . y ) { Point new1_a ; new1_a . x = 0 ; new1_a . y = p . y - p . x * dis_y / dis_x ; Point new2_a ; new2_a . x = p . x - p . y * dis_x / dis_y ; new2_a . y = 0 ; if ( sgn ( dis ( new1_a ) - dis ( new2_a )) <= 0 ) return new1_a ; else return new2_a ; } return Point ( 0 , 0 ); } db calc ( Point a , Point b ) { if ( sgn ( a . x - b . x ) == 0 || sgn ( a . y - b . y ) == 0 ) { return max ( fabs ( a . x - b . x ), fabs ( a . y - b . y )); } else { assert ( 0 ); } return 0 ; } int main () { int _T ; scanf ( \"%d\" , & _T ); for ( int CAS = 1 ; CAS <= _T ; ++ CAS ) { printf ( \"Case #%d: \" , CAS ); scanf ( \"%d%d\" , & w , & h ); p . scan (); scanf ( \"%d\" , & n ); po = Polygon ( n ); for ( int i = 0 ; i < n ; ++ i ) { po [ i - 1 ]. scan (); } po . norm ( p ); _po = Polygon ( n + 4 ); // dbg(n); for ( int i = 0 ; i < n ; ++ i ) { _po [ i ] = getPoint ( po [ i ]); // dbg(_po[i].x, _po[i].y); _po [ i ]. vis = 1 ; } _po [ n ] = Point ( 0 , 0 , 0 ); _po [ n + 1 ] = Point ( w , 0 , 0 ); _po [ n + 2 ] = Point ( w , h , 0 ); _po [ n + 3 ] = Point ( 0 , h , 0 ); for ( int i = 0 ; i < n + 4 ; ++ i ) { if ( sgn ( _po [ i ]. y ) == 0 ) _po [ i ]. tp = 1 ; else if ( sgn ( _po [ i ]. x - w ) == 0 ) _po [ i ]. tp = 2 ; else if ( sgn ( _po [ i ]. y - h ) == 0 ) _po [ i ]. tp = 3 ; else if ( sgn ( _po [ i ]. x ) == 0 ) _po [ i ]. tp = 4 ; } sort ( _po . p . begin (), _po . p . end (), [ & ]( Point a , Point b ) { if ( a . tp != b . tp ) return a . tp < b . tp ; if ( a . tp == 1 ) return sgn ( a . x - b . x ) <= 0 ; else if ( a . tp == 2 ) return sgn ( a . y - b . y ) <= 0 ; else if ( a . tp == 3 ) return sgn ( a . x - b . x ) >= 0 ; else if ( a . tp == 4 ) return sgn ( a . y - b . y ) >= 0 ; }); // for (int i = 1; i <= n + 4; ++i) { // dbg(i, _po[i].x, _po[i].y); // } db res = 0 ; for ( int i = 1 ; i <= n + 100 ; ++ i ) { int _j = i - 1 ; for ( int j = i - 1 ;; -- j ) { if ( _po [ j ]. vis == 1 ) { _j = j ; break ; } } db now = 0 ; for ( int j = i - 1 ; j >= _j ; -- j ) { now += calc ( _po [ j ], _po [ j + 1 ]); } res = max ( res , now ); } printf ( \"%.10Lf \\n \" , res ); } return 0 ; }","title":"\u601d\u8def"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#problem-d-defend-city","text":"Upsolved By -.","title":"Problem D. Defend City"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u9898\u610f_3","text":"","title":"\u9898\u610f"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u601d\u8def_3","text":"","title":"\u601d\u8def"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#problem-e-exam-results","text":"Solved By Dup4 & ltslts. 76(+1)","title":"Problem E. Exam Results"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u9898\u610f_4","text":"\u7ed9\u51fa n n \u4e2a\u4eba\u548c\u4e00\u4e2a\u6982\u7387\u53c2\u6570 p p \u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u4eba\uff0c\u5728\u4e00\u573a\u8003\u8bd5\u4e2d\uff0c\u5982\u679c\u4ed6\u53d1\u6325\u7684\u597d\uff0c\u4ed6\u4f1a\u5f97\u5230 a_i a_i \u7684\u5206\u6570\uff0c\u5426\u5219\u5f97\u5230 b_i b_i \u7684\u5206\u6570\u3002 \u5728\u4e00\u573a\u8003\u8bd5\u4e2d\uff0c\u5047\u5b9a\u6700\u9ad8\u5206\u6570\u4e3a x x \uff0c\u90a3\u4e48\u53ea\u8981\u4e00\u4e2a\u4eba\u5f97\u5230\u7684\u5206\u6570\u5927\u4e8e\u7b49\u4e8e x \\cdot p\\% x \\cdot p\\% \uff0c\u90a3\u4e48\u4ed6\u5c31\u80fd\u901a\u8fc7\u8fd9\u573a\u8003\u8bd5\u3002 \u95ee\u6240\u6709 2^n 2^n \u7684\u60c5\u51b5\u4e2d\uff0c\u6700\u591a\u80fd\u6709\u591a\u5c11\u4eba\u901a\u8fc7\u8003\u8bd5\u3002","title":"\u9898\u610f"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u601d\u8def_4","text":"\u5c06\u6240\u6709\u5206\u6570\u6392\u5e8f\u3002 \u7136\u540e\u4ece\u5927\u5230\u5c0f\u679a\u4e3e x x \uff0c\u7136\u540e\u7ef4\u62a4\u4e24\u4e2a\u6307\u9488\u3002 \u4e00\u4e2a\u662f\u8981\u6240\u6709\u5927\u4e8e x x \u7684\u5206\u6570\u90fd\u4e0d\u80fd\u8981\u3002 \u4e00\u4e2a\u662f\u6240\u6709\u5c0f\u4e8e x \\cdot p\\% x \\cdot p\\% \u7684\u5206\u6570\u90fd\u4e0d\u80fd\u52a0\u5165\u3002 \u4f46\u662f\u8003\u8651 x x \u662f\u9012\u51cf\u7684\uff0c\u6240\u4ee5\u4e0b\u754c\u662f\u9010\u6e10\u51cf\u5c0f\uff0c\u6240\u4ee5\u662f\u6162\u6162\u52a0\u5165\u5f88\u591a\u53ef\u4ee5\u7684\u70b9\u3002 \u6240\u4ee5\u6bcf\u4e2a\u5206\u6570\u53ea\u4f1a\u88ab\u52a0\u5165\u4e00\u6b21\uff0c\u5254\u9664\u4e00\u6b21\u3002 \u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u4e00\u4e2a\u4eba\u4e24\u4e2a\u5206\u6570\u90fd\u56e0\u4e3a\u5927\u4e8e x x \u800c\u88ab\u5254\u9664\u6389\uff0c\u662f\u4e0d\u5408\u6cd5\u7684\u60c5\u51b5\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; using pII = pair < int , int > ; #define fi first #define se second #define SZ(x) (int(x.size())) const int N = 2e5 + 10 ; int n , p ; int a [ N ], b [ N ]; int f [ N ]; void gao () { for ( int i = 1 ; i <= n ; ++ i ) f [ i ] = 0 ; vector < pII > vec ; for ( int i = 1 ; i <= n ; ++ i ) { vec . push_back ( pII ( a [ i ], i )); vec . push_back ( pII ( b [ i ], i )); } sort ( vec . begin (), vec . end ()); int res = 0 , now = 0 ; int r = SZ ( vec ) - 1 , l = SZ ( vec ) - 1 ; int m = SZ ( vec ) - 1 ; int MaxScore = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { MaxScore = max ( MaxScore , min ({ a [ i ], b [ i ]})); } for ( int i = m ; i >= 0 ; -- i ) { int Max = vec [ i ]. fi ; if ( Max < MaxScore ) break ; ll pMax = 1l l * p * Max ; while ( l >= 0 && 1l l * vec [ l ]. fi * 100 >= pMax ) { int id = vec [ l ]. se ; ++ f [ id ]; if ( f [ id ] == 1 ) ++ now ; -- l ; } while ( r >= 0 && vec [ r ]. fi > Max ) { int id = vec [ r ]. se ; -- f [ id ]; if ( f [ id ] == 0 ) -- now ; -- r ; } res = max ( res , now ); } printf ( \"%d \\n \" , res ); } int main () { int _T ; scanf ( \"%d\" , & _T ); for ( int CAS = 1 ; CAS <= _T ; ++ CAS ) { printf ( \"Case #%d: \" , CAS ); scanf ( \"%d%d\" , & n , & p ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d%d\" , a + i , b + i ); } gao (); } return 0 ; }","title":"\u601d\u8def"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#problem-f-friendly-group","text":"Solved By Dup4 & ltslts. 44(+)","title":"Problem F. Friendly Group"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u9898\u610f_5","text":"\u7ed9\u51fa n n \u4e2a\u70b9\u548c m m \u6761\u8fb9\u3002 \u73b0\u5728\u8981\u7ed9\u51fa\u4e00\u4e2a\u5b50\u56fe\uff0c\u5b9a\u4e49\u4ef7\u503c\u4e3a\uff1a V = \\mbox{\u8fde\u63a5\u8fd9\u4e2a\u5b50\u56fe\u4e2d\u4e24\u70b9\u7684\u8fb9\u7684\u6570\u91cf} - \\mbox{\u70b9\u6570} - \\mbox{\u5176\u4e2d\u4e00\u4e2a\u70b9\u5728\u5b50\u56fe\u4e2d\uff0c\u53e6\u4e00\u4e2a\u70b9\u5728\u5b50\u56fe\u5916\u7684\u8fb9\u7684\u6570\u91cf} V = \\mbox{\u8fde\u63a5\u8fd9\u4e2a\u5b50\u56fe\u4e2d\u4e24\u70b9\u7684\u8fb9\u7684\u6570\u91cf} - \\mbox{\u70b9\u6570} - \\mbox{\u5176\u4e2d\u4e00\u4e2a\u70b9\u5728\u5b50\u56fe\u4e2d\uff0c\u53e6\u4e00\u4e2a\u70b9\u5728\u5b50\u56fe\u5916\u7684\u8fb9\u7684\u6570\u91cf} \u95ee\u5982\u4f55\u9009\u5b50\u56fe\uff0c\u4f7f\u5f97\u4ef7\u503c\u6700\u5927\uff1f","title":"\u9898\u610f"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u601d\u8def_5","text":"\u8d2a\u5fc3\uff0c\u9009\u62e9\u6b63\u6536\u76ca\u7684\u6bcf\u4e00\u4e2a\u8fde\u901a\u5757\u3002 Code #include <bits/stdc++.h> using namespace std ; #define SZ(x) (int(x.size())) const int N = 3e5 + 10 ; int n , m ; vector < vector < int >> G , T ; struct UFS { int fa [ N ], sze [ N ]; void init ( int n ) { for ( int i = 1 ; i <= n ; ++ i ) { fa [ i ] = 0 ; sze [ i ] = 1 ; } } int find ( int u ) { return fa [ u ] ? fa [ u ] = find ( fa [ u ]) : u ; } void merge ( int u , int v ) { int fu = find ( u ), fv = find ( v ); if ( fu != fv ) { if ( sze [ fu ] > sze [ fv ]) { swap ( fu , fv ); } fa [ fv ] = fu ; sze [ fu ] += sze [ fv ]; } } } ufs ; int main () { int _T ; scanf ( \"%d\" , & _T ); for ( int CAS = 1 ; CAS <= _T ; ++ CAS ) { printf ( \"Case #%d: \" , CAS ); scanf ( \"%d%d\" , & n , & m ); G . clear (); G . resize ( n + 1 ); ufs . init ( n ); for ( int i = 1 , u , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); ufs . merge ( u , v ); } T . clear (); T . resize ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { T [ ufs . find ( i )]. push_back ( i ); } int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( ! T [ i ]. empty ()) { int E = 0 , V = SZ ( T [ i ]); for ( auto & it : T [ i ]) { E += SZ ( G [ it ]); } E /= 2 ; if ( E - V > 0 ) res += E - V ; } } printf ( \"%d \\n \" , res ); } return 0 ; }","title":"\u601d\u8def"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#problem-g-good-number","text":"Solved By Dup4. 34(+)","title":"Problem G. Good Number"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u9898\u610f_6","text":"\u7ed9\u51fa n n \u548c k k \u3002 \u7edf\u8ba1 [1, n] [1, n] \u4e2d\u6709\u591a\u5c11\u4e2a x x \u6ee1\u8db3 \\displaystyle \\lfloor \\sqrt[k]{x} \\rfloor \\;\\;|\\;\\; x \\displaystyle \\lfloor \\sqrt[k]{x} \\rfloor \\;\\;|\\;\\; x \u3002","title":"\u9898\u610f"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u601d\u8def_6","text":"k = 1 k = 1 \u7684\u65f6\u5019\u7279\u5224\u3002 \u8003\u8651 \\lfloor \\sqrt[k]{x} \\rfloor \\lfloor \\sqrt[k]{x} \\rfloor \u7684\u79cd\u7c7b\u53ea\u6709 \\lfloor \\sqrt[k]{n} \\rfloor \\lfloor \\sqrt[k]{n} \\rfloor \u79cd\u3002 \u90a3\u4e48\u5bf9\u4e8e i i \uff0c\u5b83\u638c\u7ba1\u7684\u8303\u56f4\u662f [i^k, (i + 1)^k) [i^k, (i + 1)^k) , \u76f4\u63a5\u7edf\u8ba1\u8fd9\u4e2a\u8303\u56f4\u5185\u6709\u591a\u5c11\u4e2a i i \u7684\u500d\u6570\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; int n , k ; ll calc ( int x ) { ll res = 1 ; for ( int i = 1 ; i <= k ; ++ i ) { res *= x ; if ( res > n ) return n + 1 ; } return res ; } ll gao ( ll x , ll y ) { return y / x ; } int main () { int _T ; scanf ( \"%d\" , & _T ); for ( int CAS = 1 ; CAS <= _T ; ++ CAS ) { printf ( \"Case #%d: \" , CAS ); scanf ( \"%d%d\" , & n , & k ); if ( k == 1 ) { printf ( \"%d \\n \" , n ); } else { int limit = ceil ( pow ( n , 1.0 / k )) + 10 ; limit = min ( limit , n ); ll res = 0 ; for ( int i = 1 ; i <= limit ; ++ i ) { ll l = calc ( i ); ll r = calc ( i + 1 ); if ( l < r ) { res += gao ( i , r - 1 ) - gao ( i , l - 1 ); } } printf ( \"%lld \\n \" , res ); } } return 0 ; }","title":"\u601d\u8def"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#problem-h-holy-sequence","text":"Upsolved By -.","title":"Problem H. Holy Sequence"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u9898\u610f_7","text":"","title":"\u9898\u610f"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u601d\u8def_7","text":"","title":"\u601d\u8def"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#problem-i-interstellar-hunter","text":"Upsolved By -.","title":"Problem I. Interstellar Hunter"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u9898\u610f_8","text":"","title":"\u9898\u610f"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u601d\u8def_8","text":"","title":"\u601d\u8def"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#problem-j-jewel-splitting","text":"Upsolved By -.","title":"Problem J. Jewel Splitting"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u9898\u610f_9","text":"","title":"\u9898\u610f"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u601d\u8def_9","text":"","title":"\u601d\u8def"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#problem-k-kingdoms-power","text":"Upsolved By -.","title":"Problem K. Kingdom\u2019s Power"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u9898\u610f_10","text":"\u7ed9\u51fa n n \u4e2a\u70b9\u7684\u6709\u6839\u6811\uff0c\u6839\u4e3a 1 1 \u3002 \u5728\u6839\u7ed3\u70b9\uff0c\u6709\u65e0\u9650\u4e2a\u58eb\u5175\u3002 \u6bcf\u6b21\u53ef\u4ee5\u8c03\u914d\u4e00\u4e2a\u58eb\u5175\uff0c\u5411\u5b83\u76f8\u90bb\u7684\u70b9\u8d70\u4e00\u6b65\u3002 \u95ee\u6240\u6709\u70b9\u90fd\u81f3\u5c11\u88ab\u4e00\u4e2a\u58eb\u5175\u8bbf\u95ee\u8fc7\u7684\u6700\u5c0f\u6b21\u6570\u3002","title":"\u9898\u610f"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u601d\u8def_10","text":"","title":"\u601d\u8def"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#problem-l--lost-temple","text":"Upsolved By -.","title":"Problem L.  Lost Temple"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u9898\u610f_11","text":"","title":"\u9898\u610f"},{"location":"2020/onsite/6th-CCPC-Qinhuangdao-Site/#\u601d\u8def_11","text":"","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/","text":"\u7b2c\u5341\u4e03\u5c4a\u4e2d\u56fd\u8ba1\u91cf\u5927\u5b66\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b Contents Contest Info Solutions Problem A \u9898\u610f \u601d\u8def Problem B \u9898\u610f \u601d\u8def Problem C \u9898\u610f \u601d\u8def Problem D \u9898\u610f \u601d\u8def Problem E \u9898\u610f \u601d\u8def Problem F \u9898\u610f \u601d\u8def Problem G \u9898\u610f \u601d\u8def Problem H \u9898\u610f \u601d\u8def Problem I \u9898\u610f \u601d\u8def Problem J \u9898\u610f \u601d\u8def Problem K \u9898\u610f \u601d\u8def Problem L \u9898\u610f \u601d\u8def Problem M \u9898\u610f \u601d\u8def Problem N \u9898\u610f \u601d\u8def Contest Info Practice Link Solved A B C D E F G H I J K L M N 12/14 O O O O O O \u00d8 O O O O O - - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions Problem A Solved By Dup4. 01:49(+) \u9898\u610f \u62bd\u8c61\u4e00\u4e0b\uff0c\u5c31\u662f\u6811\u4e0a\u7684 DFS\u5e8f \u4e0a\u533a\u95f4\u66f4\u65b0\uff0c\u5355\u70b9\u67e5\u8be2\u3002 \u601d\u8def \u968f\u4fbf\u641e\u4e2a\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u4e00\u4e0b\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m , in [ N ], out [ N ]; vector < vector < int >> G ; struct BIT { ll a [ N ]; void init () { memset ( a , 0 , sizeof a ); } void update ( int x , ll v ) { for (; x < N ; x += x & - x ) a [ x ] += v ; } ll query ( int x ) { ll res = 0 ; for (; x ; x -= x & - x ) res += a [ x ]; return res ; } void update ( int l , int r , ll v ) { // dbg(l, r, v); if ( l > r ) return ; update ( l , v ); update ( r + 1 , - v ); } } bit ; void dfs ( int u ) { in [ u ] = ++* in ; for ( auto & v : G [ u ]) { dfs ( v ); } out [ u ] = * in ; } void run () { rd ( n , m ); G . clear (); G . resize ( n + 1 ); bit . init (); int rt = -1 ; for ( int i = 1 , fa ; i <= n ; ++ i ) { rd ( fa ); if ( fa ) G [ fa ]. push_back ( i ); else rt = i ; } * in = 0 ; // dbg(rt); dfs ( rt ); // for (int i = 1; i <= n; ++i) dbg(i, in[i], out[i]); for ( int i = 1 , u , x , v ; i <= m ; ++ i ) { rd ( u , x , v ); pt ( bit . query ( in [ v ])); bit . update ( in [ u ], out [ u ], x ); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem B Solved By Dup4. 01:16(+) \u9898\u610f \u7ed9\u51fa\u4e24\u4e2a 01 \u4e32 A A \u548c B B \uff0c\u6bcf\u6b21\u53ef\u4ee5\u6267\u884c\u7684\u64cd\u4f5c\u6709\uff1a \u5c06\u6240\u6709\u4f4d\u90fd\u53d8\u6210 0 0 \u3002 \u7ffb\u8f6c\u4e00\u4e2a\u540e\u7f00\u7684\u72b6\u6001\u3002 \u95ee\u5c06 A A \u53d8\u6210 B B \u6700\u5c11\u7684\u64cd\u4f5c\u6b65\u9aa4\u3002 \u601d\u8def \u5982\u679c\u9700\u8981\u6267\u884c\u7b2c\u4e00\u79cd\u64cd\u4f5c\uff0c\u663e\u7136\u80af\u5b9a\u662f\u7b2c\u4e00\u6b21\u6267\u884c\u3002 \u6839\u636e\u8fd9\u4e2a\u8ba8\u8bba\u4e24\u79cd\u60c5\u51b5\uff0c\u53d1\u73b0\u53ea\u7528\u7b2c\u4e8c\u79cd\u64cd\u4f5c\uff0c\u6700\u5c11\u6b65\u6570\u662f\u56fa\u5b9a\u7684\uff0c\u80af\u5b9a\u662f\u4ece\u524d\u5f80\u540e\u53bb\u7ffb\u8f6c\uff0c\u56e0\u4e3a\u4e00\u6b21\u7ffb\u8f6c\u53ea\u4f1a\u5f71\u54cd\u540e\u7f00\uff0c\u524d\u9762\u7684\u4f4d\u662f\u4e0d\u4f1a\u53d8\u7684\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; string a , b ; vector < int > gao () { int f = 0 ; vector < int > res ; for ( int i = 0 ; i < SZ ( a ); ++ i ) { int _a = a [ i ] - '0' ; int _b = b [ i ] - '0' ; if ( _a != ( _b ^ f )) { f ^= 1 ; res . push_back ( i + 1 ); } } return res ; } vector < int > gao1 () { int f = 0 ; vector < int > res ; res . push_back ( 0 ); for ( int i = 0 ; i < SZ ( a ); ++ i ) { int _a = a [ i ] - '0' ; int _b = 0 ; if ( _a != ( _b ^ f )) { f ^= 1 ; res . push_back ( i + 1 ); } } return res ; } void run () { cin >> a >> b ; swap ( a , b ); vector < vector < int >> vec ( 2 ); vec [ 0 ] = gao (); vec [ 1 ] = gao1 (); if ( SZ ( vec [ 0 ]) > SZ ( vec [ 1 ])) vec [ 0 ] = vec [ 1 ]; pt ( vec [ 0 ]); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem C Solved By Dup4. 01:03(+) \u9898\u610f \u8981\u70e4\u725b\u6392\uff0c\u6709 n n \u4e2a\u6b65\u9aa4\uff0c\u9700\u8981\u5728\u6bcf\u4e2a\u6b65\u9aa4\u70e4\u5236\u4e00\u5206\u949f\u3002 \u7b2c i i \u4e2a\u6b65\u9aa4\u6709\u6e29\u5ea6\u8981\u6c42 [l_i, r_i] [l_i, r_i] \uff0c\u5f53\u70e4\u8089\u673a\u7684\u6e29\u5ea6\u5728\u8fd9\u4e2a\u8303\u56f4\u5185\u624d\u80fd\u70e4\u5236\u4e00\u5206\u949f\u5e76\u4e14\u5230\u4e0b\u4e00\u4e2a\u6b65\u9aa4\u3002 \u6bcf\u5206\u949f\u53ef\u4ee5\u5c06\u70e4\u8089\u673a\u7684\u6e29\u5ea6\u5347\u9ad8\u6216\u8005\u964d\u4f4e 1 1 \u5ea6\u3002 \u521a\u5f00\u59cb\u7684\u6e29\u5ea6\u662f 0 0 \u3002 \u601d\u8def \u521a\u5f00\u59cb\u7684\u6e29\u5ea6\u56fa\u5b9a\uff0c\u663e\u7136\u5c31\u6709\u8d2a\u5fc3\u7b56\u7565\uff1a\u5bf9\u4e8e\u6bcf\u4e2a\u6b65\u9aa4\uff0c\u5982\u679c\u6e29\u5ea6\u7b26\u5408\uff0c\u5c31\u4e0d\u53d8\uff0c\u5426\u5219\u6839\u636e\u5c0f\u4e8e\u6216\u8005\u5927\u4e8e\uff0c\u521a\u597d\u53d8\u5316\u5230\u5f53\u524d\u6b65\u9aa4\u7684\u8fb9\u754c\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; pII a [ N ]; void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]. fi , a [ i ]. se ); ll res = 0 ; ll t = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( t < a [ i ]. fi ) { res += a [ i ]. fi - t ; t = a [ i ]. fi ; } else if ( t > a [ i ]. se ) { res += t - a [ i ]. se ; t = a [ i ]. se ; } ++ res ; } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem D Solved By ltslts. 02:55(+) \u9898\u610f \u53d6\u77f3\u5b50\uff0c\u6bcf\u6b21\u53ea\u80fd\u9009\u62e9\u4e00\u5806\uff0c\u9009\u53d6\u4e0d\u5c11\u4e8e\u4e0a\u6b21\u62ff\u7684\u6570\u3002\u7136\u540e\u6700\u540e\u5982\u679c\u6709\u5269\u4f59\u7684\u77f3\u5b50\uff0c\u6700\u540e\u4e00\u4e2a\u4eba\u5fc5\u987b\u53d6\u5b8c\u3002\u53d6\u5b8c\u7684\u4eba\u8f93\uff0c\u95ee\u5148\u624b\u7b2c\u4e00\u6b21\u53d6\u591a\u5c11\u4e2a\u624d\u80fd\u5fc5\u8d62\uff0c\u5982\u679c\u4e0d\u80fd\u8f93\u51fa -1 -1 . \u601d\u8def \u5982\u679c\u6700\u5927\u6570\u91cf\u7684\u5806\u6709\u5947\u6570\u4e2a\uff0c\u90a3\u4e48\u5148\u624b\u53d6\u6700\u5927\u7684\u6570\u91cf\u5373\u5fc5\u80dc\u7b56\u7565\uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0c\u964d\u5e8f\u7684\u77f3\u5806\u4e2d\u5982\u679c\u6709\u67d0\u4e2a\u6570\u91cf\u662f\u5947\u6570\uff0c\u90a3\u4e48\u5148\u624b\u7684\u5373\u53d6\u8be5\u6570\u91cf\u7684\u77f3\u5b50\u3002 \u7279\u6b8a\u7684\uff0c\u5982\u679c\u6240\u6709\u6570\u91cf\u7684\u77f3\u5806\u90fd\u662f\u5076\u6570\u4e2a\uff0c\u90a3\u4e48\u5148\u624b\u5fc5\u80dc\uff0c\u5982\u679c\u5148\u624b\u53d6\u7684\u662f\u6700\u5c0f\u6570\u91cf\u7684\u77f3\u5806\uff0c\u5e76\u4e14\u6700\u5c0f\u6570\u91cf\u7684\u77f3\u5806\u4e2a\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u5148\u624b\u5fc5\u8d25\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , a [ N ]; void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]); sort ( a + 1 , a + 1 + n ); reverse ( a + 1 , a + 1 + n ); int cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( i == 1 || a [ i ] == a [ i - 1 ]) ++ cnt ; else { if ( cnt & 1 ) return pt ( a [ i - 1 ]); cnt = 1 ; } } if ( cnt & 1 ) return pt ( -1 ); pt ( a [ n ]); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem E Solved By groggy_. 03:53(+) \u9898\u610f \u4e00\u6761\u94fe\uff0c\u6bcf\u4e2a\u8282\u70b9\u6570\u5b57\u8868\u793a\u8282\u70b9\u9644\u5c5e\u7684\u5b50\u8282\u70b9\uff0c\u672b\u5c3e\u8282\u70b9\u4e00\u5b9a\u5305\u542b\u4e00\u4e2a\u5b50\u8282\u70b9\u3002 \u4e24\u4e2a\u4eba\u8f6e\u6d41\u4ece\u672b\u5c3e\u8282\u70b9\u7684\u5b50\u8282\u70b9\u53d6\u82e5\u5e72\u4e2a\uff0c\u5f53\u672b\u5c3e\u8282\u70b9\u65e0\u5b50\u8282\u70b9\u65f6\uff0c\u672b\u5c3e\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9\u6210\u4e3a\u65b0\u7684\u672b\u5c3e\u8282\u70b9\u3002 \u6700\u540e\u62ff\u5b8c\u7684\u4eba\u8f93\uff0c\u6c42\u5148\u624b\u8005\u80fd\u5426\u80dc\u5229\u3002 \u601d\u8def \u6839\u636e\u5b50\u8282\u70b9\u662f\u5426\u552f\u4e00\u53ef\u4ee5\u5224\u65ad\u662f\u5426\u6539\u53d8\u5148\u540e\u624b\uff0c\u9012\u63a8\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , a [ N ]; void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) { a [ i ] = nextInt () + 1 ; } int f = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( a [ i ] == 1 ) f ^= 1 ; else f = 1 ; } if ( f ) pt ( \"these are sweet grapes\" ); else pt ( \"these are sour grapes\" ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem F Solved By Dup4. 00:13(+) \u9898\u610f \u7b7e\u5230\u3002 \u601d\u8def Code print ( 'e' ) Problem G Upsolved By Dup4. \u9898\u610f \u7ed9\u51fa\u4e00\u5f20 n n \u4e2a\u70b9 m m \u6761\u8fb9\u7684\u65e0\u5411\u56fe\uff0c\u6bcf\u4e2a\u70b9\u6709\u4e00\u79cd\u989c\u8272 a_i a_i \uff0c\u6709 q q \u6b21\u64cd\u4f5c\uff1a 1 u x , \u5c06\u70b9 u u \u7684\u989c\u8272\u67d3\u6210 x x \u3002 2 u \uff0c\u8be2\u95ee\u5982\u679c\u5c06\u70b9 u u \u91cd\u65b0\u67d3\u8272\uff0c\u5e76\u4e14\u4e0d\u548c\u70b9 u u \u76f8\u90bb\u7684\u4efb\u610f\u4e00\u70b9\u7684\u989c\u8272\u4e00\u6837\uff0c\u90a3\u4e48\u53ef\u67d3\u8272\u7684\u989c\u8272\u4e2d\uff0c\u7f16\u53f7\u6700\u5c0f\u7684\u662f\u591a\u5c11\uff1f \u601d\u8def \u6839\u636e\u5ea6\u6570\u5206\u6210\u5927\u70b9\u548c\u5c0f\u70b9\u3002 \u663e\u7136\u5c0f\u70b9\u7684\u7b54\u6848\u5f88\u597d\u7b97\uff0c\u590d\u6742\u5ea6 \\mathcal{O}(\\sqrt{n}) \\mathcal{O}(\\sqrt{n}) \u3002 \u5bf9\u4e8e\u5927\u70b9\uff0c\u53ea\u6709 \\sqrt{n} \\sqrt{n} \u4e2a\u5927\u70b9\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u5927\u70b9\u90fd\u7ef4\u62a4\u4e00\u4e2a BitSet \uff0c\u7136\u540e\u5bf9\u4e8e\u6bcf\u6b21\u66f4\u65b0\u989c\u8272\u90fd\u4fee\u6539\u4e00\u4e0b\u5927\u70b9\u7684 BitSet \u4e2d\u7684\u5bf9\u5e94\u4f4d\u7f6e\u3002 \u6211\u4e0d\u77e5\u9053 C++ \u4e2d\u7684 BitSet \u600e\u4e48\u5b9e\u73b0\u7684\uff0c\u4e5f\u4e0d\u77e5\u9053\u4fee\u6539\u5355\u70b9\u4fe1\u606f\u7684\u590d\u6742\u5ea6\u662f\u591a\u5c11\uff0c\u4f46\u662f\u5982\u679c\u81ea\u5df1\u5199\u4e00\u4e2a BitSet \uff0c\u4fee\u6539\u5355\u70b9\u4fe1\u606f\u662f\u80fd\u591f\u505a\u5230 \\mathcal{O}(1) \\mathcal{O}(1) \u7684\u3002 \u5bf9\u4e8e\u5927\u70b9\u7b54\u6848\u7684\u67e5\u8be2\uff0c\u590d\u6742\u5ea6\u662f \\mathcal{O}(\\frac{n}{w}) \\mathcal{O}(\\frac{n}{w}) \u3002 \u6240\u4ee5\u6700\u4f18\u60c5\u51b5\u4e0b\uff0c\u80fd\u591f\u505a\u5230 \\displaystyle \\mathcal{O} (\\frac{n^2}{w} + n \\cdot \\sqrt{n}) \\displaystyle \\mathcal{O} (\\frac{n^2}{w} + n \\cdot \\sqrt{n}) \u3002 \u5176\u5b9e\u4e5f\u53ef\u4ee5\u7528\u6811\u72b6\u6570\u7ec4\u6765\u7ef4\u62a4\uff0c\u67e5\u8be2\u7684\u65f6\u5019\u4e8c\u5206\u5373\u53ef\uff0c\u8fd9\u6837\u590d\u6742\u5ea6\u662f \\mathcal{\\log^2 n} \\mathcal{\\log^2 n} \uff0c\u5982\u679c\u7528\u7ebf\u6bb5\u6811\u7684\u8bdd\uff0c\u67e5\u8be2\u590d\u6742\u5ea6\u80fd\u591f\u505a\u5230 \\mathcal{o}(\\log n) \\mathcal{o}(\\log n) \u3002\u4f46\u662f\u66f4\u65b0\u7684\u65f6\u5019\u7ebf\u6bb5\u6811\u5e38\u6570\u5927\uff0c\u6811\u72b6\u6570\u7ec4\u5e38\u6570\u5c0f\u3002\u611f\u89c9\u6ca1\u4ec0\u4e48\u5dee\u522b\u3002\u8fd9\u6837\u7684\u8bdd\uff0c\u590d\u6742\u5ea6\u80fd\u591f\u505a\u5230 \\mathcal{O}(n \\cdot \\sqrt{n} \\cdot \\log n + n \\cdot \\log^2 n) \\mathcal{O}(n \\cdot \\sqrt{n} \\cdot \\log n + n \\cdot \\log^2 n) \u3002 \u6211\u611f\u89c9\u9898\u610f\u6709\u70b9\u95ee\u9898\uff1a > * Type 1: 1 u x ( 0 \\leq x \\leq 10^9 0 \\leq x \\leq 10^9 )\u2013Change the colour of area u u to x x . > * Type 2: 2 u \u2013At this time, the little beauty wants to draw area u, YHH will pass a brush according to the above rules, which number is what you should print. \u8bf4\u5b9e\u8bdd\uff0c\u4ece\u8fd9\u4e24\u53e5\u8bdd\u6211\u770b\u4e0d\u51fa\u7b2c 2 2 \u79cd\u64cd\u4f5c\u540e\u4e5f\u9700\u8981\u5c06 u u \u7684\u989c\u8272\u66f4\u6539\u4e3a\u8be2\u95ee\u7684\u7b54\u6848\uff0c\u4f46\u662f\u5b9e\u9645\u4e0a\u662f\u8981\u8fd9\u4e48\u505a\u7684\uff0c\u4f46\u662f\u8fd9\u597d\u50cf\u7ed9\u300c\u5f3a\u5236\u5728\u7ebf\u300d\u63d0\u4f9b\u4e86\u4e00\u79cd\u6bd4\u8f83\u597d\u7684\u601d\u8def\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; constexpr int S = 450 ; int n , m , q , a [ N ], f [ N ], id [ N ], fid [ N ], sze [ N ]; bool isBig [ N ]; vector < vector < int >> G , T , H ; bitset < N > b [ 2 * ( N / S ) + 10 ]; void run () { rd ( n , m ); memset ( isBig , 0 , sizeof isBig ); G . clear (); G . resize ( n + 1 ); T . clear (); T . resize ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]); for ( int i = 1 , u , v ; i <= m ; ++ i ) { rd ( u , v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } * id = 0 ; H . clear (); H . resize ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) { if ( SZ ( G [ i ]) > S ) { isBig [ i ] = 1 ; id [ i ] = ++* id ; fid [ * id ] = i ; sze [ * id ] = SZ ( G [ i ]) + 5 ; b [ * id ]. set (); H . push_back ( vector < int > ( sze [ * id ], 0 )); } } for ( int u = 1 ; u <= n ; ++ u ) { for ( auto & v : G [ u ]) { if ( isBig [ v ]) { int _v = id [ v ]; T [ u ]. push_back ( _v ); int x = a [ u ]; if ( x < sze [ _v ]) { ++ H [ _v ][ x ]; if ( H [ _v ][ x ] == 1 ) b [ _v ][ x ] = 0 ; } } } } rd ( q ); for ( int i = 1 , op , u , x ; i <= q ; ++ i ) { rd ( op , u ); if ( op == 1 ) { rd ( x ); } else { if ( isBig [ u ]) { x = b [ id [ u ]]. _Find_first (); } else { int _sze = SZ ( G [ u ]) + 5 ; for ( int i = 0 ; i <= _sze ; ++ i ) f [ i ] = 0 ; for ( auto & v : G [ u ]) { if ( a [ v ] < _sze ) { f [ a [ v ]] = 1 ; } } for ( int i = 0 ; i <= _sze ; ++ i ) if ( ! f [ i ]) { x = i ; break ; } } pt ( x ); } int pre = a [ u ]; a [ u ] = x ; for ( auto & it : T [ u ]) { if ( pre < sze [ it ]) { -- H [ it ][ pre ]; if ( H [ it ][ pre ] == 0 ) b [ it ][ pre ] = 1 ; } if ( x < sze [ it ]) { ++ H [ it ][ x ]; if ( H [ it ][ x ] == 1 ) b [ it ][ x ] = 0 ; } } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem H Solved By Dup4. 01:27(+) \u9898\u610f \u601d\u8def \u7ebf\u6bb5\u6811\u533a\u95f4\u66f4\u65b0\uff0c\u5168\u5c40\u67e5\u8be2\u3002 \u53ef\u80fd\u6709\u66f4\u7b80\u77ed\u7684\u505a\u6cd5\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; constexpr int INF = 0x3f3f3f3f ; int n , m ; int a [ N ]; struct SEG { struct node { int Max , lazy ; node () { Max = 0 , lazy = INF ; } void up () { Max = 0 ; lazy = 0 ; } node operator + ( const node & other ) const { node res = node (); res . Max = max ( Max , other . Max ); return res ; } } t [ N << 2 ]; void down ( int id ) { int lazy = t [ id ]. lazy ; if ( lazy != INF ) { t [ id << 1 ]. up (); t [ id << 1 | 1 ]. up (); } } void build ( int id , int l , int r ) { t [ id ] = node (); if ( l == r ) { t [ id ]. Max = a [ l ]; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } void update ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) { t [ id ]. Max = t [ id ]. lazy = 0 ; return ; } int mid = ( l + r ) >> 1 ; down ( id ); if ( ql <= mid ) update ( id << 1 , l , mid , ql , qr ); if ( qr > mid ) update ( id << 1 | 1 , mid + 1 , r , ql , qr ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } } seg ; void run () { rd ( n , m ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]); seg . build ( 1 , 1 , n ); for ( int i = 1 , l , r ; i <= m ; ++ i ) { rd ( l , r ); seg . update ( 1 , 1 , n , l , r ); pt ( seg . t [ 1 ]. Max ); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem I Solved By all. 01:56(+6) \u9898\u610f \u7ed9\u51fa n n \u4e2a\u70b9\uff0c\u95ee\u4f60\u662f\u5426\u6709\u4e00\u79cd\u65b9\u6848\uff0c\u4f7f\u5f97\u8fd9 n n \u4e2a\u70b9\u4e0d\u91cd\u53e0\uff0c\u5e76\u4e14\u4efb\u610f\u4e24\u70b9\u7684\u4e2d\u5782\u7ebf\u4e4b\u95f4\u90fd\u81f3\u5c11\u6709\u4e00\u4e2a\u70b9\u3002 \u601d\u8def $ n geq 3 $ \u65f6\u7b54\u6848\u4e3a Yes \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; void run () { rd ( n ); if ( n >= 3 ) pt ( \"Yes\" ); else pt ( \"No\" ); // if (n == 1) return pt(\"No\"); // if (n % 2 || n == 4 || n == 6) pt(\"Yes\"); // else pt(\"No\"); // if (n != 1 && (n < 3 || n > 7)) pt(\"No\"); // else pt(\"Yes\"); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem J Solved By Dup4. 03:22(+1) \u9898\u610f \u7ed9\u51fa n n \u4e2a\u4eba\uff0c\u8981\u6c42\u7ec4\u6210\u4e0d\u8d85\u8fc7\u4e24\u652f\u961f\u4f0d\uff0c\u5e76\u4e14\u6bcf\u4e2a\u4eba\u90fd\u8981\u5728\u4e00\u652f\u961f\u4f0d\u4e2d\u3002\u73b0\u5728\u7ed9\u51fa m m \u6761\u5173\u7cfb (a_i, b_i, t_i) (a_i, b_i, t_i) \uff0c\u8868\u793a a_i a_i \u548c b_i b_i \u8981\u60f3\u5728\u4e00\u652f\u961f\u4f0d\u7684\u8bdd\uff0c\u81f3\u5c11\u9700\u8981 t_i t_i \u7684\u65f6\u95f4\u53bb\u78e8\u5408\u3002 \u5982\u679c\u5bf9\u4e8e\u4e00\u5bf9 a_j, b_j a_j, b_j \u6ca1\u6709\u5728 m m \u6761\u5173\u7cfb\u4e2d\u7ed9\u51fa\uff0c\u53ef\u4ee5\u7406\u89e3\u4e3a\u8fd9\u4e24\u4e2a\u4eba\u4e0d\u9700\u8981\u65f6\u95f4\u78e8\u5408\u3002 \u4e00\u652f\u961f\u4f0d\u7684\u78e8\u5408\u65f6\u95f4\u4e3a\u961f\u4f0d\u4e2d\u4efb\u610f\u4e24\u4eba\u6240\u9700\u78e8\u5408\u65f6\u95f4\u7684\u6700\u5927\u503c\u3002 \u73b0\u5728\u95ee\u6240\u6709\u4eba\u90fd\u6709\u961f\u4f0d\u5e76\u4e14\u78e8\u5408\u5b8c\u6bd5\u7684\u6700\u5c11\u65f6\u95f4\u662f\u591a\u5c11\u3002 \u601d\u8def \u4e8c\u5206\u7b54\u6848 x x \uff0c\u7136\u540e\u8003\u8651\u8865\u56fe\uff0c\u5373\u4fdd\u7559\u6240\u6709\u8fb9\u6743\u5927\u4e8e x x \u7684\u8fb9\uff0c\u5728\u8865\u56fe\u4e2d\u8fde\u8fb9\u7b49\u4ef7\u4e8e\u8fd9\u4e24\u4e2a\u4eba\u4e0d\u80fd\u5728\u4e00\u4e2a\u961f\u4f0d\u91cc\uff0c\u90a3\u4e48\u4e8c\u5206\u56fe\u67d3\u8272\u5224\u65ad\u662f\u5426\u662f\u4e8c\u5206\u56fe\u5c31\u53ef\u4ee5\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m , col [ N ]; vector < vector < int >> G ; struct Edge { int u , v , w ; Edge () {} Edge ( int u , int v , int w ) : u ( u ), v ( v ), w ( w ) {} } e [ N ]; int res ; void dfs ( int u ) { for ( auto & v : G [ u ]) { if ( col [ v ] != -1 ) { if ( col [ u ] == col [ v ]) res = 0 ; } else { col [ v ] = col [ u ] ^ 1 ; dfs ( v ); } } } bool ok ( int x ) { G . clear (); G . resize ( n + 1 ); memset ( col , -1 , sizeof col ); for ( int i = 1 ; i <= m ; ++ i ) { int u = e [ i ]. u , v = e [ i ]. v , w = e [ i ]. w ; if ( w > x ) { G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } } res = 1 ; for ( int i = 1 ; i <= n ; ++ i ) if ( col [ i ] == -1 ) dfs ( i ); return res ; } void run () { rd ( n , m ); for ( int i = 1 ; i <= m ; ++ i ) { rd ( e [ i ]. u , e [ i ]. v , e [ i ]. w ); } int l = 0 , r = 1e9 , res = r ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( ok ( mid )) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem K Solved By ltslts and Dup4. 01:33(+2) \u9898\u610f \u7ed9\u51fa\u82e5\u5e72\u4e2a\u8eab\u4efd\u8bc1\u53f7\uff0c\u5224\u65ad\u6709\u591a\u5c11\u4e2a\u5b50\u4e32\u662f\u5408\u6cd5\u7684\u56de\u6587\u65e5\u671f\u3002 \u601d\u8def \u66b4\u529b\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; string s ; bool isYEAP ( int year ) { if (( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ) return true ; return false ; } int Mon [ 2 ][ 13 ] = { 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 0 , 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , }; int ok ( string t ) { string _t = t ; reverse ( all ( _t )); if ( t != _t ) return false ; int year = atoi ( t . substr ( 0 , 4 ). c_str ()); int month = atoi ( t . substr ( 4 , 2 ). c_str ()); int day = atoi ( t . substr ( 6 , 2 ). c_str ()); if ( year < 1 || month < 1 || day < 1 ) return false ; if ( month > 12 ) return false ; if ( day > Mon [ isYEAP ( year )][ month ]) return false ; return true ; } void run () { if ( s == \"#\" ) return ; stringstream ss ; ss . clear (); ss . str ( \"\" ); ss << s ; int res = 0 ; while ( ss >> s ) { for ( int i = 0 ; i + 8 <= SZ ( s ); ++ i ) { // cout << s.substr(i, 8) << endl; res += ok ( s . substr ( i , 8 )); } } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); while ( getline ( cin , s )) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } Problem L Solved By Dup4. 04:29(+1) \u9898\u610f \u7ed9\u51fa\u82e5\u5e72\u4e2a\u8eab\u4efd\u8bc1\u53f7\uff0c\u5224\u65ad\u6709\u591a\u5c11\u4e2a\u5b50\u5e8f\u5217\u662f\u5408\u6cd5\u7684\u56de\u6587\u65e5\u671f\u3002 \u601d\u8def \u5728\u9898\u610f\u9650\u5b9a\u65e5\u671f\u8303\u56f4\u5185\uff0c\u5408\u6cd5\u56de\u6587\u65e5\u671f\u53ea\u6709 12 12 \u4e2a\uff0c\u90a3\u4e48\u76f4\u63a5\u8f6c\u5316\u6210\u7ed9\u51fa\u4e24\u4e2a\u5b57\u7b26\u4e32 S S \u548c T T \uff0c\u95ee S S \u4e2d\u6709\u591a\u5c11\u4e2a\u5b50\u5e8f\u5217\u662f T T \uff0c\u76f4\u63a5 DP \u5373\u53ef\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 \\mathcal{O}(|S||T|) \\mathcal{O}(|S||T|) \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; vector < string > obj ; string s , t ; int f [ N ][ 10 ]; bool isYEAP ( int year ) { if (( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ) return true ; return false ; } int Mon [ 2 ][ 13 ] = { 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 0 , 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , }; int ok ( string t ) { string _t = t ; reverse ( all ( _t )); if ( t != _t ) return false ; int year = atoi ( t . substr ( 0 , 4 ). c_str ()); int month = atoi ( t . substr ( 4 , 2 ). c_str ()); int day = atoi ( t . substr ( 6 , 2 ). c_str ()); if ( year < 1 || month < 1 || day < 1 ) return false ; if ( month > 12 ) return false ; if ( day > Mon [ isYEAP ( year )][ month ]) return false ; return true ; } inline int calc ( string s , string t ) { int lens = SZ ( s ), lent = SZ ( t ); for ( int i = 0 ; i <= lens ; ++ i ) f [ i ][ 0 ] = 1 ; for ( int i = 1 ; i <= lens ; ++ i ) { for ( int j = 1 ; j <= lent ; ++ j ) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( s [ i - 1 ] == t [ j - 1 ]) { chadd ( f [ i ][ j ], f [ i - 1 ][ j - 1 ]); } } } return f [ lens ][ lent ]; } void run () { if ( s == \"#\" ) return ; string _s = \"\" ; for ( auto & ch : s ) if ( ch != ' ' ) _s += ch ; int res = 0 ; for ( auto & it : obj ) chadd ( res , calc ( _s , it )); pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); for ( int i = 2000 ; i <= 2099 ; ++ i ) { for ( int j = 1 ; j <= 12 ; ++ j ) { for ( int k = 1 ; k <= 31 ; ++ k ) { char t [ 10 ]; sprintf ( t , \"%04d%02d%02d\" , i , j , k ); // string _t = string(t); // cout << _t << endl; if ( ok ( string ( t ))) { obj . push_back ( string ( t )); } } } } while ( getline ( cin , s )) run (); return 0 ; } Problem M Solved By . 0:00(+) \u9898\u610f \u601d\u8def Problem N Solved By . 0:00(+) \u9898\u610f \u601d\u8def","title":"\u7b2c\u5341\u4e03\u5c4a\u4e2d\u56fd\u8ba1\u91cf\u5927\u5b66\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b"},{"location":"2020/random-trainings/17th-cjlu-cpc/#contest-info","text":"Practice Link Solved A B C D E F G H I J K L M N 12/14 O O O O O O \u00d8 O O O O O - - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"2020/random-trainings/17th-cjlu-cpc/#solutions","text":"","title":"Solutions"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-a","text":"Solved By Dup4. 01:49(+)","title":"Problem A"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f","text":"\u62bd\u8c61\u4e00\u4e0b\uff0c\u5c31\u662f\u6811\u4e0a\u7684 DFS\u5e8f \u4e0a\u533a\u95f4\u66f4\u65b0\uff0c\u5355\u70b9\u67e5\u8be2\u3002","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def","text":"\u968f\u4fbf\u641e\u4e2a\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u4e00\u4e0b\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m , in [ N ], out [ N ]; vector < vector < int >> G ; struct BIT { ll a [ N ]; void init () { memset ( a , 0 , sizeof a ); } void update ( int x , ll v ) { for (; x < N ; x += x & - x ) a [ x ] += v ; } ll query ( int x ) { ll res = 0 ; for (; x ; x -= x & - x ) res += a [ x ]; return res ; } void update ( int l , int r , ll v ) { // dbg(l, r, v); if ( l > r ) return ; update ( l , v ); update ( r + 1 , - v ); } } bit ; void dfs ( int u ) { in [ u ] = ++* in ; for ( auto & v : G [ u ]) { dfs ( v ); } out [ u ] = * in ; } void run () { rd ( n , m ); G . clear (); G . resize ( n + 1 ); bit . init (); int rt = -1 ; for ( int i = 1 , fa ; i <= n ; ++ i ) { rd ( fa ); if ( fa ) G [ fa ]. push_back ( i ); else rt = i ; } * in = 0 ; // dbg(rt); dfs ( rt ); // for (int i = 1; i <= n; ++i) dbg(i, in[i], out[i]); for ( int i = 1 , u , x , v ; i <= m ; ++ i ) { rd ( u , x , v ); pt ( bit . query ( in [ v ])); bit . update ( in [ u ], out [ u ], x ); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-b","text":"Solved By Dup4. 01:16(+)","title":"Problem B"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f_1","text":"\u7ed9\u51fa\u4e24\u4e2a 01 \u4e32 A A \u548c B B \uff0c\u6bcf\u6b21\u53ef\u4ee5\u6267\u884c\u7684\u64cd\u4f5c\u6709\uff1a \u5c06\u6240\u6709\u4f4d\u90fd\u53d8\u6210 0 0 \u3002 \u7ffb\u8f6c\u4e00\u4e2a\u540e\u7f00\u7684\u72b6\u6001\u3002 \u95ee\u5c06 A A \u53d8\u6210 B B \u6700\u5c11\u7684\u64cd\u4f5c\u6b65\u9aa4\u3002","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def_1","text":"\u5982\u679c\u9700\u8981\u6267\u884c\u7b2c\u4e00\u79cd\u64cd\u4f5c\uff0c\u663e\u7136\u80af\u5b9a\u662f\u7b2c\u4e00\u6b21\u6267\u884c\u3002 \u6839\u636e\u8fd9\u4e2a\u8ba8\u8bba\u4e24\u79cd\u60c5\u51b5\uff0c\u53d1\u73b0\u53ea\u7528\u7b2c\u4e8c\u79cd\u64cd\u4f5c\uff0c\u6700\u5c11\u6b65\u6570\u662f\u56fa\u5b9a\u7684\uff0c\u80af\u5b9a\u662f\u4ece\u524d\u5f80\u540e\u53bb\u7ffb\u8f6c\uff0c\u56e0\u4e3a\u4e00\u6b21\u7ffb\u8f6c\u53ea\u4f1a\u5f71\u54cd\u540e\u7f00\uff0c\u524d\u9762\u7684\u4f4d\u662f\u4e0d\u4f1a\u53d8\u7684\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; string a , b ; vector < int > gao () { int f = 0 ; vector < int > res ; for ( int i = 0 ; i < SZ ( a ); ++ i ) { int _a = a [ i ] - '0' ; int _b = b [ i ] - '0' ; if ( _a != ( _b ^ f )) { f ^= 1 ; res . push_back ( i + 1 ); } } return res ; } vector < int > gao1 () { int f = 0 ; vector < int > res ; res . push_back ( 0 ); for ( int i = 0 ; i < SZ ( a ); ++ i ) { int _a = a [ i ] - '0' ; int _b = 0 ; if ( _a != ( _b ^ f )) { f ^= 1 ; res . push_back ( i + 1 ); } } return res ; } void run () { cin >> a >> b ; swap ( a , b ); vector < vector < int >> vec ( 2 ); vec [ 0 ] = gao (); vec [ 1 ] = gao1 (); if ( SZ ( vec [ 0 ]) > SZ ( vec [ 1 ])) vec [ 0 ] = vec [ 1 ]; pt ( vec [ 0 ]); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-c","text":"Solved By Dup4. 01:03(+)","title":"Problem C"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f_2","text":"\u8981\u70e4\u725b\u6392\uff0c\u6709 n n \u4e2a\u6b65\u9aa4\uff0c\u9700\u8981\u5728\u6bcf\u4e2a\u6b65\u9aa4\u70e4\u5236\u4e00\u5206\u949f\u3002 \u7b2c i i \u4e2a\u6b65\u9aa4\u6709\u6e29\u5ea6\u8981\u6c42 [l_i, r_i] [l_i, r_i] \uff0c\u5f53\u70e4\u8089\u673a\u7684\u6e29\u5ea6\u5728\u8fd9\u4e2a\u8303\u56f4\u5185\u624d\u80fd\u70e4\u5236\u4e00\u5206\u949f\u5e76\u4e14\u5230\u4e0b\u4e00\u4e2a\u6b65\u9aa4\u3002 \u6bcf\u5206\u949f\u53ef\u4ee5\u5c06\u70e4\u8089\u673a\u7684\u6e29\u5ea6\u5347\u9ad8\u6216\u8005\u964d\u4f4e 1 1 \u5ea6\u3002 \u521a\u5f00\u59cb\u7684\u6e29\u5ea6\u662f 0 0 \u3002","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def_2","text":"\u521a\u5f00\u59cb\u7684\u6e29\u5ea6\u56fa\u5b9a\uff0c\u663e\u7136\u5c31\u6709\u8d2a\u5fc3\u7b56\u7565\uff1a\u5bf9\u4e8e\u6bcf\u4e2a\u6b65\u9aa4\uff0c\u5982\u679c\u6e29\u5ea6\u7b26\u5408\uff0c\u5c31\u4e0d\u53d8\uff0c\u5426\u5219\u6839\u636e\u5c0f\u4e8e\u6216\u8005\u5927\u4e8e\uff0c\u521a\u597d\u53d8\u5316\u5230\u5f53\u524d\u6b65\u9aa4\u7684\u8fb9\u754c\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; pII a [ N ]; void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]. fi , a [ i ]. se ); ll res = 0 ; ll t = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( t < a [ i ]. fi ) { res += a [ i ]. fi - t ; t = a [ i ]. fi ; } else if ( t > a [ i ]. se ) { res += t - a [ i ]. se ; t = a [ i ]. se ; } ++ res ; } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-d","text":"Solved By ltslts. 02:55(+)","title":"Problem D"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f_3","text":"\u53d6\u77f3\u5b50\uff0c\u6bcf\u6b21\u53ea\u80fd\u9009\u62e9\u4e00\u5806\uff0c\u9009\u53d6\u4e0d\u5c11\u4e8e\u4e0a\u6b21\u62ff\u7684\u6570\u3002\u7136\u540e\u6700\u540e\u5982\u679c\u6709\u5269\u4f59\u7684\u77f3\u5b50\uff0c\u6700\u540e\u4e00\u4e2a\u4eba\u5fc5\u987b\u53d6\u5b8c\u3002\u53d6\u5b8c\u7684\u4eba\u8f93\uff0c\u95ee\u5148\u624b\u7b2c\u4e00\u6b21\u53d6\u591a\u5c11\u4e2a\u624d\u80fd\u5fc5\u8d62\uff0c\u5982\u679c\u4e0d\u80fd\u8f93\u51fa -1 -1 .","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def_3","text":"\u5982\u679c\u6700\u5927\u6570\u91cf\u7684\u5806\u6709\u5947\u6570\u4e2a\uff0c\u90a3\u4e48\u5148\u624b\u53d6\u6700\u5927\u7684\u6570\u91cf\u5373\u5fc5\u80dc\u7b56\u7565\uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0c\u964d\u5e8f\u7684\u77f3\u5806\u4e2d\u5982\u679c\u6709\u67d0\u4e2a\u6570\u91cf\u662f\u5947\u6570\uff0c\u90a3\u4e48\u5148\u624b\u7684\u5373\u53d6\u8be5\u6570\u91cf\u7684\u77f3\u5b50\u3002 \u7279\u6b8a\u7684\uff0c\u5982\u679c\u6240\u6709\u6570\u91cf\u7684\u77f3\u5806\u90fd\u662f\u5076\u6570\u4e2a\uff0c\u90a3\u4e48\u5148\u624b\u5fc5\u80dc\uff0c\u5982\u679c\u5148\u624b\u53d6\u7684\u662f\u6700\u5c0f\u6570\u91cf\u7684\u77f3\u5806\uff0c\u5e76\u4e14\u6700\u5c0f\u6570\u91cf\u7684\u77f3\u5806\u4e2a\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u5148\u624b\u5fc5\u8d25\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , a [ N ]; void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]); sort ( a + 1 , a + 1 + n ); reverse ( a + 1 , a + 1 + n ); int cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( i == 1 || a [ i ] == a [ i - 1 ]) ++ cnt ; else { if ( cnt & 1 ) return pt ( a [ i - 1 ]); cnt = 1 ; } } if ( cnt & 1 ) return pt ( -1 ); pt ( a [ n ]); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-e","text":"Solved By groggy_. 03:53(+)","title":"Problem E"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f_4","text":"\u4e00\u6761\u94fe\uff0c\u6bcf\u4e2a\u8282\u70b9\u6570\u5b57\u8868\u793a\u8282\u70b9\u9644\u5c5e\u7684\u5b50\u8282\u70b9\uff0c\u672b\u5c3e\u8282\u70b9\u4e00\u5b9a\u5305\u542b\u4e00\u4e2a\u5b50\u8282\u70b9\u3002 \u4e24\u4e2a\u4eba\u8f6e\u6d41\u4ece\u672b\u5c3e\u8282\u70b9\u7684\u5b50\u8282\u70b9\u53d6\u82e5\u5e72\u4e2a\uff0c\u5f53\u672b\u5c3e\u8282\u70b9\u65e0\u5b50\u8282\u70b9\u65f6\uff0c\u672b\u5c3e\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9\u6210\u4e3a\u65b0\u7684\u672b\u5c3e\u8282\u70b9\u3002 \u6700\u540e\u62ff\u5b8c\u7684\u4eba\u8f93\uff0c\u6c42\u5148\u624b\u8005\u80fd\u5426\u80dc\u5229\u3002","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def_4","text":"\u6839\u636e\u5b50\u8282\u70b9\u662f\u5426\u552f\u4e00\u53ef\u4ee5\u5224\u65ad\u662f\u5426\u6539\u53d8\u5148\u540e\u624b\uff0c\u9012\u63a8\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , a [ N ]; void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) { a [ i ] = nextInt () + 1 ; } int f = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( a [ i ] == 1 ) f ^= 1 ; else f = 1 ; } if ( f ) pt ( \"these are sweet grapes\" ); else pt ( \"these are sour grapes\" ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-f","text":"Solved By Dup4. 00:13(+)","title":"Problem F"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f_5","text":"\u7b7e\u5230\u3002","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def_5","text":"Code print ( 'e' )","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-g","text":"Upsolved By Dup4.","title":"Problem G"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f_6","text":"\u7ed9\u51fa\u4e00\u5f20 n n \u4e2a\u70b9 m m \u6761\u8fb9\u7684\u65e0\u5411\u56fe\uff0c\u6bcf\u4e2a\u70b9\u6709\u4e00\u79cd\u989c\u8272 a_i a_i \uff0c\u6709 q q \u6b21\u64cd\u4f5c\uff1a 1 u x , \u5c06\u70b9 u u \u7684\u989c\u8272\u67d3\u6210 x x \u3002 2 u \uff0c\u8be2\u95ee\u5982\u679c\u5c06\u70b9 u u \u91cd\u65b0\u67d3\u8272\uff0c\u5e76\u4e14\u4e0d\u548c\u70b9 u u \u76f8\u90bb\u7684\u4efb\u610f\u4e00\u70b9\u7684\u989c\u8272\u4e00\u6837\uff0c\u90a3\u4e48\u53ef\u67d3\u8272\u7684\u989c\u8272\u4e2d\uff0c\u7f16\u53f7\u6700\u5c0f\u7684\u662f\u591a\u5c11\uff1f","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def_6","text":"\u6839\u636e\u5ea6\u6570\u5206\u6210\u5927\u70b9\u548c\u5c0f\u70b9\u3002 \u663e\u7136\u5c0f\u70b9\u7684\u7b54\u6848\u5f88\u597d\u7b97\uff0c\u590d\u6742\u5ea6 \\mathcal{O}(\\sqrt{n}) \\mathcal{O}(\\sqrt{n}) \u3002 \u5bf9\u4e8e\u5927\u70b9\uff0c\u53ea\u6709 \\sqrt{n} \\sqrt{n} \u4e2a\u5927\u70b9\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u5927\u70b9\u90fd\u7ef4\u62a4\u4e00\u4e2a BitSet \uff0c\u7136\u540e\u5bf9\u4e8e\u6bcf\u6b21\u66f4\u65b0\u989c\u8272\u90fd\u4fee\u6539\u4e00\u4e0b\u5927\u70b9\u7684 BitSet \u4e2d\u7684\u5bf9\u5e94\u4f4d\u7f6e\u3002 \u6211\u4e0d\u77e5\u9053 C++ \u4e2d\u7684 BitSet \u600e\u4e48\u5b9e\u73b0\u7684\uff0c\u4e5f\u4e0d\u77e5\u9053\u4fee\u6539\u5355\u70b9\u4fe1\u606f\u7684\u590d\u6742\u5ea6\u662f\u591a\u5c11\uff0c\u4f46\u662f\u5982\u679c\u81ea\u5df1\u5199\u4e00\u4e2a BitSet \uff0c\u4fee\u6539\u5355\u70b9\u4fe1\u606f\u662f\u80fd\u591f\u505a\u5230 \\mathcal{O}(1) \\mathcal{O}(1) \u7684\u3002 \u5bf9\u4e8e\u5927\u70b9\u7b54\u6848\u7684\u67e5\u8be2\uff0c\u590d\u6742\u5ea6\u662f \\mathcal{O}(\\frac{n}{w}) \\mathcal{O}(\\frac{n}{w}) \u3002 \u6240\u4ee5\u6700\u4f18\u60c5\u51b5\u4e0b\uff0c\u80fd\u591f\u505a\u5230 \\displaystyle \\mathcal{O} (\\frac{n^2}{w} + n \\cdot \\sqrt{n}) \\displaystyle \\mathcal{O} (\\frac{n^2}{w} + n \\cdot \\sqrt{n}) \u3002 \u5176\u5b9e\u4e5f\u53ef\u4ee5\u7528\u6811\u72b6\u6570\u7ec4\u6765\u7ef4\u62a4\uff0c\u67e5\u8be2\u7684\u65f6\u5019\u4e8c\u5206\u5373\u53ef\uff0c\u8fd9\u6837\u590d\u6742\u5ea6\u662f \\mathcal{\\log^2 n} \\mathcal{\\log^2 n} \uff0c\u5982\u679c\u7528\u7ebf\u6bb5\u6811\u7684\u8bdd\uff0c\u67e5\u8be2\u590d\u6742\u5ea6\u80fd\u591f\u505a\u5230 \\mathcal{o}(\\log n) \\mathcal{o}(\\log n) \u3002\u4f46\u662f\u66f4\u65b0\u7684\u65f6\u5019\u7ebf\u6bb5\u6811\u5e38\u6570\u5927\uff0c\u6811\u72b6\u6570\u7ec4\u5e38\u6570\u5c0f\u3002\u611f\u89c9\u6ca1\u4ec0\u4e48\u5dee\u522b\u3002\u8fd9\u6837\u7684\u8bdd\uff0c\u590d\u6742\u5ea6\u80fd\u591f\u505a\u5230 \\mathcal{O}(n \\cdot \\sqrt{n} \\cdot \\log n + n \\cdot \\log^2 n) \\mathcal{O}(n \\cdot \\sqrt{n} \\cdot \\log n + n \\cdot \\log^2 n) \u3002 \u6211\u611f\u89c9\u9898\u610f\u6709\u70b9\u95ee\u9898\uff1a > * Type 1: 1 u x ( 0 \\leq x \\leq 10^9 0 \\leq x \\leq 10^9 )\u2013Change the colour of area u u to x x . > * Type 2: 2 u \u2013At this time, the little beauty wants to draw area u, YHH will pass a brush according to the above rules, which number is what you should print. \u8bf4\u5b9e\u8bdd\uff0c\u4ece\u8fd9\u4e24\u53e5\u8bdd\u6211\u770b\u4e0d\u51fa\u7b2c 2 2 \u79cd\u64cd\u4f5c\u540e\u4e5f\u9700\u8981\u5c06 u u \u7684\u989c\u8272\u66f4\u6539\u4e3a\u8be2\u95ee\u7684\u7b54\u6848\uff0c\u4f46\u662f\u5b9e\u9645\u4e0a\u662f\u8981\u8fd9\u4e48\u505a\u7684\uff0c\u4f46\u662f\u8fd9\u597d\u50cf\u7ed9\u300c\u5f3a\u5236\u5728\u7ebf\u300d\u63d0\u4f9b\u4e86\u4e00\u79cd\u6bd4\u8f83\u597d\u7684\u601d\u8def\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; constexpr int S = 450 ; int n , m , q , a [ N ], f [ N ], id [ N ], fid [ N ], sze [ N ]; bool isBig [ N ]; vector < vector < int >> G , T , H ; bitset < N > b [ 2 * ( N / S ) + 10 ]; void run () { rd ( n , m ); memset ( isBig , 0 , sizeof isBig ); G . clear (); G . resize ( n + 1 ); T . clear (); T . resize ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]); for ( int i = 1 , u , v ; i <= m ; ++ i ) { rd ( u , v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } * id = 0 ; H . clear (); H . resize ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) { if ( SZ ( G [ i ]) > S ) { isBig [ i ] = 1 ; id [ i ] = ++* id ; fid [ * id ] = i ; sze [ * id ] = SZ ( G [ i ]) + 5 ; b [ * id ]. set (); H . push_back ( vector < int > ( sze [ * id ], 0 )); } } for ( int u = 1 ; u <= n ; ++ u ) { for ( auto & v : G [ u ]) { if ( isBig [ v ]) { int _v = id [ v ]; T [ u ]. push_back ( _v ); int x = a [ u ]; if ( x < sze [ _v ]) { ++ H [ _v ][ x ]; if ( H [ _v ][ x ] == 1 ) b [ _v ][ x ] = 0 ; } } } } rd ( q ); for ( int i = 1 , op , u , x ; i <= q ; ++ i ) { rd ( op , u ); if ( op == 1 ) { rd ( x ); } else { if ( isBig [ u ]) { x = b [ id [ u ]]. _Find_first (); } else { int _sze = SZ ( G [ u ]) + 5 ; for ( int i = 0 ; i <= _sze ; ++ i ) f [ i ] = 0 ; for ( auto & v : G [ u ]) { if ( a [ v ] < _sze ) { f [ a [ v ]] = 1 ; } } for ( int i = 0 ; i <= _sze ; ++ i ) if ( ! f [ i ]) { x = i ; break ; } } pt ( x ); } int pre = a [ u ]; a [ u ] = x ; for ( auto & it : T [ u ]) { if ( pre < sze [ it ]) { -- H [ it ][ pre ]; if ( H [ it ][ pre ] == 0 ) b [ it ][ pre ] = 1 ; } if ( x < sze [ it ]) { ++ H [ it ][ x ]; if ( H [ it ][ x ] == 1 ) b [ it ][ x ] = 0 ; } } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-h","text":"Solved By Dup4. 01:27(+)","title":"Problem H"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f_7","text":"","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def_7","text":"\u7ebf\u6bb5\u6811\u533a\u95f4\u66f4\u65b0\uff0c\u5168\u5c40\u67e5\u8be2\u3002 \u53ef\u80fd\u6709\u66f4\u7b80\u77ed\u7684\u505a\u6cd5\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; constexpr int INF = 0x3f3f3f3f ; int n , m ; int a [ N ]; struct SEG { struct node { int Max , lazy ; node () { Max = 0 , lazy = INF ; } void up () { Max = 0 ; lazy = 0 ; } node operator + ( const node & other ) const { node res = node (); res . Max = max ( Max , other . Max ); return res ; } } t [ N << 2 ]; void down ( int id ) { int lazy = t [ id ]. lazy ; if ( lazy != INF ) { t [ id << 1 ]. up (); t [ id << 1 | 1 ]. up (); } } void build ( int id , int l , int r ) { t [ id ] = node (); if ( l == r ) { t [ id ]. Max = a [ l ]; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } void update ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) { t [ id ]. Max = t [ id ]. lazy = 0 ; return ; } int mid = ( l + r ) >> 1 ; down ( id ); if ( ql <= mid ) update ( id << 1 , l , mid , ql , qr ); if ( qr > mid ) update ( id << 1 | 1 , mid + 1 , r , ql , qr ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } } seg ; void run () { rd ( n , m ); for ( int i = 1 ; i <= n ; ++ i ) rd ( a [ i ]); seg . build ( 1 , 1 , n ); for ( int i = 1 , l , r ; i <= m ; ++ i ) { rd ( l , r ); seg . update ( 1 , 1 , n , l , r ); pt ( seg . t [ 1 ]. Max ); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-i","text":"Solved By all. 01:56(+6)","title":"Problem I"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f_8","text":"\u7ed9\u51fa n n \u4e2a\u70b9\uff0c\u95ee\u4f60\u662f\u5426\u6709\u4e00\u79cd\u65b9\u6848\uff0c\u4f7f\u5f97\u8fd9 n n \u4e2a\u70b9\u4e0d\u91cd\u53e0\uff0c\u5e76\u4e14\u4efb\u610f\u4e24\u70b9\u7684\u4e2d\u5782\u7ebf\u4e4b\u95f4\u90fd\u81f3\u5c11\u6709\u4e00\u4e2a\u70b9\u3002","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def_8","text":"$ n geq 3 $ \u65f6\u7b54\u6848\u4e3a Yes \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; void run () { rd ( n ); if ( n >= 3 ) pt ( \"Yes\" ); else pt ( \"No\" ); // if (n == 1) return pt(\"No\"); // if (n % 2 || n == 4 || n == 6) pt(\"Yes\"); // else pt(\"No\"); // if (n != 1 && (n < 3 || n > 7)) pt(\"No\"); // else pt(\"Yes\"); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-j","text":"Solved By Dup4. 03:22(+1)","title":"Problem J"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f_9","text":"\u7ed9\u51fa n n \u4e2a\u4eba\uff0c\u8981\u6c42\u7ec4\u6210\u4e0d\u8d85\u8fc7\u4e24\u652f\u961f\u4f0d\uff0c\u5e76\u4e14\u6bcf\u4e2a\u4eba\u90fd\u8981\u5728\u4e00\u652f\u961f\u4f0d\u4e2d\u3002\u73b0\u5728\u7ed9\u51fa m m \u6761\u5173\u7cfb (a_i, b_i, t_i) (a_i, b_i, t_i) \uff0c\u8868\u793a a_i a_i \u548c b_i b_i \u8981\u60f3\u5728\u4e00\u652f\u961f\u4f0d\u7684\u8bdd\uff0c\u81f3\u5c11\u9700\u8981 t_i t_i \u7684\u65f6\u95f4\u53bb\u78e8\u5408\u3002 \u5982\u679c\u5bf9\u4e8e\u4e00\u5bf9 a_j, b_j a_j, b_j \u6ca1\u6709\u5728 m m \u6761\u5173\u7cfb\u4e2d\u7ed9\u51fa\uff0c\u53ef\u4ee5\u7406\u89e3\u4e3a\u8fd9\u4e24\u4e2a\u4eba\u4e0d\u9700\u8981\u65f6\u95f4\u78e8\u5408\u3002 \u4e00\u652f\u961f\u4f0d\u7684\u78e8\u5408\u65f6\u95f4\u4e3a\u961f\u4f0d\u4e2d\u4efb\u610f\u4e24\u4eba\u6240\u9700\u78e8\u5408\u65f6\u95f4\u7684\u6700\u5927\u503c\u3002 \u73b0\u5728\u95ee\u6240\u6709\u4eba\u90fd\u6709\u961f\u4f0d\u5e76\u4e14\u78e8\u5408\u5b8c\u6bd5\u7684\u6700\u5c11\u65f6\u95f4\u662f\u591a\u5c11\u3002","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def_9","text":"\u4e8c\u5206\u7b54\u6848 x x \uff0c\u7136\u540e\u8003\u8651\u8865\u56fe\uff0c\u5373\u4fdd\u7559\u6240\u6709\u8fb9\u6743\u5927\u4e8e x x \u7684\u8fb9\uff0c\u5728\u8865\u56fe\u4e2d\u8fde\u8fb9\u7b49\u4ef7\u4e8e\u8fd9\u4e24\u4e2a\u4eba\u4e0d\u80fd\u5728\u4e00\u4e2a\u961f\u4f0d\u91cc\uff0c\u90a3\u4e48\u4e8c\u5206\u56fe\u67d3\u8272\u5224\u65ad\u662f\u5426\u662f\u4e8c\u5206\u56fe\u5c31\u53ef\u4ee5\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n , m , col [ N ]; vector < vector < int >> G ; struct Edge { int u , v , w ; Edge () {} Edge ( int u , int v , int w ) : u ( u ), v ( v ), w ( w ) {} } e [ N ]; int res ; void dfs ( int u ) { for ( auto & v : G [ u ]) { if ( col [ v ] != -1 ) { if ( col [ u ] == col [ v ]) res = 0 ; } else { col [ v ] = col [ u ] ^ 1 ; dfs ( v ); } } } bool ok ( int x ) { G . clear (); G . resize ( n + 1 ); memset ( col , -1 , sizeof col ); for ( int i = 1 ; i <= m ; ++ i ) { int u = e [ i ]. u , v = e [ i ]. v , w = e [ i ]. w ; if ( w > x ) { G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } } res = 1 ; for ( int i = 1 ; i <= n ; ++ i ) if ( col [ i ] == -1 ) dfs ( i ); return res ; } void run () { rd ( n , m ); for ( int i = 1 ; i <= m ; ++ i ) { rd ( e [ i ]. u , e [ i ]. v , e [ i ]. w ); } int l = 0 , r = 1e9 , res = r ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( ok ( mid )) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-k","text":"Solved By ltslts and Dup4. 01:33(+2)","title":"Problem K"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f_10","text":"\u7ed9\u51fa\u82e5\u5e72\u4e2a\u8eab\u4efd\u8bc1\u53f7\uff0c\u5224\u65ad\u6709\u591a\u5c11\u4e2a\u5b50\u4e32\u662f\u5408\u6cd5\u7684\u56de\u6587\u65e5\u671f\u3002","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def_10","text":"\u66b4\u529b\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; string s ; bool isYEAP ( int year ) { if (( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ) return true ; return false ; } int Mon [ 2 ][ 13 ] = { 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 0 , 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , }; int ok ( string t ) { string _t = t ; reverse ( all ( _t )); if ( t != _t ) return false ; int year = atoi ( t . substr ( 0 , 4 ). c_str ()); int month = atoi ( t . substr ( 4 , 2 ). c_str ()); int day = atoi ( t . substr ( 6 , 2 ). c_str ()); if ( year < 1 || month < 1 || day < 1 ) return false ; if ( month > 12 ) return false ; if ( day > Mon [ isYEAP ( year )][ month ]) return false ; return true ; } void run () { if ( s == \"#\" ) return ; stringstream ss ; ss . clear (); ss . str ( \"\" ); ss << s ; int res = 0 ; while ( ss >> s ) { for ( int i = 0 ; i + 8 <= SZ ( s ); ++ i ) { // cout << s.substr(i, 8) << endl; res += ok ( s . substr ( i , 8 )); } } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); while ( getline ( cin , s )) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-l","text":"Solved By Dup4. 04:29(+1)","title":"Problem L"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f_11","text":"\u7ed9\u51fa\u82e5\u5e72\u4e2a\u8eab\u4efd\u8bc1\u53f7\uff0c\u5224\u65ad\u6709\u591a\u5c11\u4e2a\u5b50\u5e8f\u5217\u662f\u5408\u6cd5\u7684\u56de\u6587\u65e5\u671f\u3002","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def_11","text":"\u5728\u9898\u610f\u9650\u5b9a\u65e5\u671f\u8303\u56f4\u5185\uff0c\u5408\u6cd5\u56de\u6587\u65e5\u671f\u53ea\u6709 12 12 \u4e2a\uff0c\u90a3\u4e48\u76f4\u63a5\u8f6c\u5316\u6210\u7ed9\u51fa\u4e24\u4e2a\u5b57\u7b26\u4e32 S S \u548c T T \uff0c\u95ee S S \u4e2d\u6709\u591a\u5c11\u4e2a\u5b50\u5e8f\u5217\u662f T T \uff0c\u76f4\u63a5 DP \u5373\u53ef\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 \\mathcal{O}(|S||T|) \\mathcal{O}(|S||T|) \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; vector < string > obj ; string s , t ; int f [ N ][ 10 ]; bool isYEAP ( int year ) { if (( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ) return true ; return false ; } int Mon [ 2 ][ 13 ] = { 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 0 , 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , }; int ok ( string t ) { string _t = t ; reverse ( all ( _t )); if ( t != _t ) return false ; int year = atoi ( t . substr ( 0 , 4 ). c_str ()); int month = atoi ( t . substr ( 4 , 2 ). c_str ()); int day = atoi ( t . substr ( 6 , 2 ). c_str ()); if ( year < 1 || month < 1 || day < 1 ) return false ; if ( month > 12 ) return false ; if ( day > Mon [ isYEAP ( year )][ month ]) return false ; return true ; } inline int calc ( string s , string t ) { int lens = SZ ( s ), lent = SZ ( t ); for ( int i = 0 ; i <= lens ; ++ i ) f [ i ][ 0 ] = 1 ; for ( int i = 1 ; i <= lens ; ++ i ) { for ( int j = 1 ; j <= lent ; ++ j ) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( s [ i - 1 ] == t [ j - 1 ]) { chadd ( f [ i ][ j ], f [ i - 1 ][ j - 1 ]); } } } return f [ lens ][ lent ]; } void run () { if ( s == \"#\" ) return ; string _s = \"\" ; for ( auto & ch : s ) if ( ch != ' ' ) _s += ch ; int res = 0 ; for ( auto & it : obj ) chadd ( res , calc ( _s , it )); pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); for ( int i = 2000 ; i <= 2099 ; ++ i ) { for ( int j = 1 ; j <= 12 ; ++ j ) { for ( int k = 1 ; k <= 31 ; ++ k ) { char t [ 10 ]; sprintf ( t , \"%04d%02d%02d\" , i , j , k ); // string _t = string(t); // cout << _t << endl; if ( ok ( string ( t ))) { obj . push_back ( string ( t )); } } } } while ( getline ( cin , s )) run (); return 0 ; }","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-m","text":"Solved By . 0:00(+)","title":"Problem M"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f_12","text":"","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def_12","text":"","title":"\u601d\u8def"},{"location":"2020/random-trainings/17th-cjlu-cpc/#problem-n","text":"Solved By . 0:00(+)","title":"Problem N"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u9898\u610f_13","text":"","title":"\u9898\u610f"},{"location":"2020/random-trainings/17th-cjlu-cpc/#\u601d\u8def_13","text":"","title":"\u601d\u8def"}]}